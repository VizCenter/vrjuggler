<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>Tweek</title>

    <subtitle>The Programmer&#39;s Guide</subtitle>

    <authorgroup>
      <author>
        <firstname>Patrick</firstname>

        <surname>Hartling</surname>
      </author>
    </authorgroup>

    <releaseinfo>0.16</releaseinfo>

    <pubdate>$Date$</pubdate>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <para>This book is the programmer&#39;s guide for Tweek. The main focus is
    how to use the features and capabilities of Tweek to enable cross-platform
    Java graphical user interfaces (GUIs) to communicate with C++
    applications.</para>

    <para>The history of Tweek dates back to April 2000, though the basis for
    its existence comes from circa 1997. At Iowa State University&#39;s
    Virtual Reality Applications Center, the idea of using a Java GUI to
    communicate with, and possibly perform manipulations on, C++ applications
    is the foundation for dynamic reconfiguration of VR Juggler. To that end,
    the Java application VjControl was developed specifically for that
    purpose. VjControl was started in 1997 and has been under development ever
    since.</para>

    <para>Building on the basic idea of a Java GUI that could communicate with
    a C++ application, a viewer was written for the Distributed Shared Object
    (DSO) software system written in April 2000. This iteration of DSO was for
    a class project (Computer Science 552 taught by Dr. Johnny Wong). At the
    time, we (Allen Bierbaum and I) felt that CORBA could be used as a way to
    share arbitrary object-based information between applications on a
    network. The Java GUI was used to visualize the network of CORBA-connected
    nodes and to manipulate the network by disconnecting and reconnecting the
    nodes. In the end, CORBA was not the right solution to this problem, but
    the basis for network visualization was founded. Using CORBA for
    communication between the C++ code and Java code was relatively easy,
    however.</para>

    <para>In April 2001, we were again faced with a class project. Based on
    the results of the CORBA-based DSO, we felt that it would be best to
    implement a peer-to-peer software multicasting system that would be more
    efficient than CORBA. This new system, called Plexus, would still offer
    the same capabilities of cross-platform data distribution, but we had to
    give up the inherent cross-language support offered by CORBA. Again, we
    wanted a Java GUI for visualizing the network, and we started with the DSO
    viewer code. Instead of using CORBA, which we had had some difficulties
    with the previous year, we chose to use Java&#39;s built-in Remote Method
    Invocation (RMI) system. While RMI is very easy to use between two Java
    applications, Java to C++ communication is difficult. It requires the use
    of the Java Native Interface (JNI) so that natively compiled C++ code can
    communicate in memory with a loaded Java virtual machine (JVM). All of the
    Java code and RMI was collected into a package called PlxView (<quote>plex-view</quote>).</para>

    <para>Despite the difficulty of writing JNI code, the RMI solution was
    effective, for the most part. In September 2001, yet another project
    loomed. By this time, we were fed up with RMI, and we decided to go back
    to CORBA solely for communicating between Java and C++. Indeed, by using
    CORBA, we could write network visualization software in
    <emphasis>any</emphasis> language and communicate through the same
    channels.</para>

    <para>Beyond just communicating with the C++ applications, we had high
    hopes for using RMI to download Java code at run time to add custom
    visualization panels to the Java GUI dynamically. The Java code would come
    in the form of JavaBeans. While PlxView was designed to be modular from
    the start, we had not implemented the code for downloading the JavaBeans.
    To begin that work, I started writing code on a flight from Dallas/Ft.
    Worth to London, England, the evening of October 1, 2001. While at a CAVE
    workshop in Stockholm, Sweden, I took advantage of down time and late
    nights to extend PlxView to load and use JavaBeans.</para>

    <para>When I returned to the United States after the week in Stockholm,
    PlxView had evolved into what could be called version 0.0.0 of the Tweek
    Java GUI (sans CORBA, however). Its primary purpose was still Plexus
    network visualization. Design discussions with other members of the
    Juggler Team evolved the code into what is now the Tweek Java API. The
    Plexus-specific parts were separated into what is now the PlxView Bean,
    and the remaining code was moved into the new Tweek source tree.</para>

    <para>The only remaining piece was CORBA support. Another student, Andrew
    Schwantes, had been experimenting with CORBA in a smaller system, and his
    C++ CORBA code was used as a starting point for the Tweek C++ API. After
    much discussion with Allen Bierbaum, the code was re-written entirely to
    make use of the Observer design pattern, and the Subject Manager was
    added. After all of that, the Java CORBA code was relatively trivial to
    add. And thus, the foundation for Tweek was in place by November 2001. By
    this time, it was already in use by the Fall 2001 Plexus class project.</para>
  </preface>

  <part>
    <title>Introduction</title>

    <chapter id="intro.tweek.chapter">
      <title>Tweek</title>

      <para>Programmers using Tweek must first understand what it is and what
      at does, at least at a conceptual level. Tweek has two parts: a Java
      <glossterm linkend="gloss.api">API</glossterm> and a C++ API. The two
      provide very distinct functionality, but they share a common bond
      through the use of remote method calls on shared objects. Objects
      defined in the C++ programming language can be accessed by objects
      defined in the Java programming language. Similarly, objects defined in
      Java can be accessed by C++ code. The C++ objects may be visualized and
      manipulated using the Tweek Java <glossterm linkend="gloss.gui">graphical
      user interface</glossterm> (GUI), a tool written using the Tweek Java
      API. This cross-language functionality is achieved through the use of
      remote method calls.</para>

      <para>Some readers may be familiar with remote procedure calls (RPC), a
      remote programming system first introduced by Sun Microsystems that uses
      the procedural programming paradigm. Remote method calls differ
      primarily through the use of the object-oriented programming paradigm.
      Tweek is implemented in two object-oriented languages and thus lends
      itself very well to a system implementing remote method calls.</para>

      <para>In the remainder of this chapter, we present a high-level
      description of the Tweek C++ API. The Java API design is much more
      complex and is not included in this chapter. (Refer to <xref
      linkend="prog.java.chapter" /> for details on using the Java API.) Most
      users of Tweek need to know more about the C++ side of Tweek than the
      Java side. This is because Tweek is designed around the philosophy of a
      simple Java GUI interacting with a potentially complex C++ application.</para>

      <section id="intro.design.section">
        <title>C++ API Design Overview</title>

        <para>The heart of the Tweek software system implements the Observer
        pattern <xref linkend="Gam95" />. This design pattern is used to
        define the relationship between the Java GUI (observer) and the C++
        application (subject). Within this section, we explain how the subject
        and observer are used. Moving beyond the subject/observer pattern, we
        also explain the <firstterm>Subject Manager</firstterm><indexterm><primary>Subject
        Manager</primary></indexterm> and the <firstterm>CORBA Manager</firstterm><indexterm><primary>CORBA
        Manager</primary></indexterm>. These four components make up the
        entirety of the C++ design.</para>

        <section>
          <title>Subject</title>

          <indexterm>
            <primary>subject</primary>

            <secondary>design and use</secondary>
          </indexterm>

          <para>The subjects in Tweek are part of the C++ applications. The
          communication <quote>channels</quote> are defined by the
          subjects&#39; interfaces. An observer is attached to a subject, and
          whenever the state of a subject changes, it notifies all of its
          attached observers.</para>

          <para>The Tweek C++ API defines the basic subject interface (<interfacename>tweek::Subject</interfacename><indexterm><primary>interfaces</primary><secondary>tweek::Subject</secondary></indexterm>)
          that implements the subject pattern <xref linkend="Gam95" />. Users
          of the Tweek C++ API derive from the base subject implementation (<classname>tweek::SubjectImpl</classname><indexterm><primary>classes</primary><secondary>tweek::SubjectImpl</secondary></indexterm>)
          and extend it by adding their own interface methods. This extension
          is twofold. First, an interface must be defined using the <glossterm
          linkend="gloss.idl">Interface Definition Language</glossterm> (IDL)<indexterm><primary>IDL</primary></indexterm>.
          Then, the interface must be implemented in C++ code. (Refer to <xref
          linkend="intro.corba.idl.section" /> for more information about IDL
          in Tweek.)</para>
        </section>

        <section>
          <title>Observer</title>

          <indexterm>
            <primary>observer</primary>

            <secondary>design and use</secondary>
          </indexterm>

          <para>The observers in Tweek are (traditionally) part of the Java
          GUI<footnote><para>Beginning with Tweek 0.13, helper classes for
          writing C++ observers are included with the C++ API. Users of older
          versions can make use of observers written in C++ (or any other
          programming language with a CORBA implementation), but the
          application developers will have to write the CORBA client code
          entirely from scratch.</para></footnote>. They observe the state of
          the remote subjects and can provide a visual rendering of that
          state.</para>

          <para>Programmers <emphasis>do not</emphasis> define interfaces for
          the observers. Instead, the Tweek C++ API defines a basic observer
          interface called <interfacename>tweek::Observer</interfacename><indexterm><primary>interfaces</primary><secondary>tweek::Observer</secondary></indexterm>.
          There is no <quote>standard</quote> observer implementation that
          corresponds to <classname>tweek::SubjectImpl</classname><indexterm><primary>classes</primary><secondary>tweek::SubjectImpl</secondary></indexterm>.
          By design, observers must correspond directly with subjects, but
          there is no need to extend the basic observer interface using IDL.
          Observer implementations simply inherit from the basic observer
          class (<classname>tweek.ObserverPOA</classname><indexterm><primary>classes</primary><secondary>tweek.ObserverPOA</secondary></indexterm>
          in Java or <classname>POA_tweek::Observer</classname><indexterm><primary>classes</primary><secondary>POA_tweek::Observer</secondary></indexterm>
          in C++) and implement the <methodname>update()</methodname> method.
          Other extensions can be added in the custom observer class, of
          course, but an implementation of <methodname>update()</methodname>
          is always required.</para>
        </section>

        <section>
          <title>CORBA Manager</title>

          <indexterm>
            <primary>CORBA Manager</primary>

            <secondary>design and use</secondary>
          </indexterm>

          <para><glossterm linkend="gloss.corba">CORBA</glossterm> tends to
          have a high learning curve. It is a very powerful system, but that
          power leads to a lot of complexity. To reduce the complexity of
          starting and using an <glossterm linkend="gloss.orb">ORB</glossterm>,
          Tweek provides a CORBA Manager. Its primary function is to
          initialize a local ORB. It does this by creating the <glossterm
          linkend="gloss.poa">Portable Object Adapter</glossterm> (POA),
          resolving the initial reference to the Naming Service, and starting
          a thread for the ORB to handle requests.</para>

          <note>
            <para>An explanation of the POA is beyond the scope of this book.
            Users of Tweek do not have to use the POA directly because the
            CORBA Manager and Subject Manager hide these details. Interested
            readers are referred to <xref linkend="Hen99" /> for more
            information about the POA and CORBA in general.</para>
          </note>

          <para>Once the local ORB is initialized, the Subject Manager
          (discussed next) must be created. This is also done through the
          CORBA Manager because the Subject Manager is a CORBA object. The
          newly created Subject Manager will be a <glossterm
          linkend="gloss.servant">servant</glossterm> object to which CORBA
          references can be created.</para>

          <para>Refer to <xref linkend="intro.corba.section" /> for more
          information about CORBA and its use in Tweek. For the most part, the
          use of CORBA is an implementation detail. Users of the Tweek C++ API
          must initialize the CORBA Manager, however, and it is important to
          understand its place in the overall system.</para>
        </section>

        <section>
          <title>Subject Manager</title>

          <indexterm>
            <primary>Subject Manager</primary>

            <secondary>design and use</secondary>
          </indexterm>

          <para>The Tweek Subject Manager exists to simplify the use of CORBA
          further. At a very high level, it acts as a simplified, specialized
          CORBA Naming Service. Users of Tweek register subject servants with
          the Subject Manager. The Subject Manager handles the CORBA
          registration and activation of the servants. After being registered,
          subjects are accessed using symbolic strings. The strings are
          user-defined and do not necessarily conform to any CORBA-related
          standard. They are, in essence, identifiers used to look up the
          subject within the Subject Manager&#39;s collection of known
          subjects.</para>
        </section>
      </section>

      <section id="intro.corba.section">
        <title>CORBA</title>

        <indexterm>
          <primary>CORBA</primary>

          <secondary>use in Tweek</secondary>
        </indexterm>

        <para>CORBA, the <glossterm linkend="gloss.corba">Common Object
        Request Broker Architecture</glossterm>, is a powerful tool for
        <glossterm linkend="gloss.distrib-programming">distributed programming</glossterm>.
        It is a <emphasis>language-independent</emphasis> standard specified
        by the <ulink url="http://www.omg.org/">Object Management Group</ulink>
        (OMG). Many CORBA implementations, both free and commercial, exist for
        a wide variety of languages (e.g., C, C++, Java, Perl, Python, and
        Smalltalk). CORBA allows communication between software written in any
        programming language running on any operating system on any hardware
        architecture. It handles all serialization and de-serialization of
        objects and method parameters so that programmers do not have to worry
        about endian issues and other system incompatibilities.</para>

        <para>Before going further with the discussion of CORBA in Tweek,
        readers must be familiar with some terminology. In CORBA, the physical
        object to which references are made is called a <glossterm
        linkend="gloss.servant"><firstterm>servant</firstterm></glossterm>.
        The servant is an instance of some class that implements an interface
        and derives from <classname>CORBA::Object</classname> (or
        <classname>org.omg.CORBA.Object</classname> in Java). The actual
        details of servant implementations are postponed for later sections.
        For now, it is important to remember that there will be an object
        located in physical memory on some machine, and <emphasis>references</emphasis>
        will be made to that object through CORBA. Users acquire references by
        looking up the object by name in what is known as the CORBA
        <firstterm>Naming Service</firstterm>. The Naming Service has objects
        registered within its database, and clients request references from
        the database. When the reference is made available, methods may be
        invoked on it. Since the physical object resides in another memory
        space, this will create network traffic, though it is entirely
        transparent to the programmer.</para>

        <para>CORBA uses <glossterm linkend="gloss.orb">Object Request Brokers</glossterm>
        (ORBs) to manage locally registered objects and to communicate with
        remote objects. The remote objects are managed by ORBs that reside
        locally on the machines that have the servants. Two ORBs communicate
        with each other using a standard protocol. In this case, that protocol
        is the <glossterm linkend="gloss.iiop">Internet Inter-ORB Protocol</glossterm>
        (IIOP). IIOP is a new addition to Version 2.3 of the CORBA standard.
        It allows two ORBs written by different vendors to communicate and
        inter-operate. This capability is crucial to the correct functionality
        of Tweek and many other CORBA-based software systems.</para>

        <para>Within the scope of Tweek, CORBA is used to enable transparent
        communication between C++ applications and the Tweek Java GUI. C++
        objects registered with a local ORB are made available to the Java GUI
        through the Subject Manager. Beyond this, CORBA exists mostly
        &#34;behind the scenes&#34; so that developers of Tweek-based software
        do not have to learn very much about CORBA. Programmers must
        understand the Interface Definition Language, however, and this is
        explained next.</para>

        <section id="intro.corba.idl.section">
          <title>Interface Definition Language</title>

          <para>The <glossterm linkend="gloss.idl">Interface Definition
          Language</glossterm> (IDL)<indexterm><primary>IDL</primary></indexterm>
          is used by the CORBA standard to define the <emphasis>interfaces</emphasis>
          for remotely accessible objects. An IDL file looks very much like a
          simple C++ class declaration in a header file, though data members
          are not allowed in the interface. Thus, IDL is used exclusively to
          define the methods of the objects and external data structures that
          may be passed as arguments to those methods.</para>

          <para>The interfaces alone are not sufficient to implement objects
          that may be handled by CORBA. A language-specific implementation
          must be written so that servants can be instantiated and registered
          with an ORB. To implement an interface, an <glossterm
          linkend="gloss.idl-compiler">IDL compiler</glossterm> must first be
          used to generate skeleton code for a specific language from the IDL
          file. Using the generated code, an implementation is then written.
          In <xref linkend="prog.idl.chapter" />, we explain in more detail
          how to use IDL to define interfaces.</para>
        </section>

        <section>
          <title>Supported Languages</title>

          <para>As discussed above, a very powerful feature of CORBA is its
          language independence. As of this writing, Tweek itself includes
          support for C++ and Java as the primary langauges. Support for
          generating the stub code needed to access Tweek Subjects through
          Python was added in early August 2003, and a PyQt-based GUI is being
          written so that developers can use Python and Qt for making GUI
          panels instead of Java. There is no restriction, other than time and
          resources, that prevents the addition of support for other
          languages. In this section, we explain how C++, Java, and Python are
          used in Tweek.</para>

          <section>
            <title>C++</title>

            <para>A key part of the overall Tweek design is that complex,
            high-performance applications will be written in C++. While this
            may not necessarily be the case in every situation, this is the
            assumption made for the design and implementation of the Tweek C++
            API. As mentioned previously, support could be added for other
            languages so that they too may fulfill the role of C++ in Tweek.</para>

            <section>
              <title>C++ Subjects</title>

              <para>Using the C++ API on the server side to create subjects,
              programmers activate a local ORB using the CORBA Manager. Once
              an ORB is available, servants that will act as subjects can be
              registered with the Subject Manager. The subjects are activated
              within the local POA by the Subject Manager, thus alleviating
              some work for programmers. Once activated, the subjects may be
              accessed remotely through CORBA by code written in any
              language—including C++.</para>
            </section>

            <section>
              <title>C++ Observers</title>

              <para>Using the C++ API on the client side to create observers,
              programmers again activate a local ORB using the CORBA Service.
              Once an ORB is available, servants that will act as observers
              can be registered with the local POA via the CORBA Service. Once
              activated, the observers can be attached to remote subjects that
              may be written in any langauge. C++ observer code is very
              similar to Java observer code.</para>
            </section>
          </section>

          <section>
            <title>Java</title>

            <para>In the Java programming language, the Swing API provides
            developers with a very nice suite of classes for writing
            cross-platform GUIs. When developing Tweek, we took advantage of
            Swing and JavaBeans technology <xref linkend="Jbe02" /> to write a
            generalized GUI framework. Users can plug components (Beans) into
            this framework at runtime to extend its functionality. The Beans
            can get access to remote C++ objects through the CORBA services
            provided by the Tweek Java API. Similar to the C++ API, the use of
            CORBA in Java has been simplified so that programmers can use it
            with little effort and without a comprehensive understanding of
            CORBA in general.</para>

            <para>Programmers will use Java as part of their Tweek programming
            to write JavaBeans. Compared to the potential complexity of the
            GUI code for Beans, little CORBA programming must be done in Java.
            Beans may be as simple or as complex as necessary to meet the
            needs of individual projects. More information about JavaBeans is
            provided in <xref linkend="intro.javabeans.chapter" />.</para>
          </section>

          <section>
            <title>Python</title>

            <para>With Python, we use PyQt <xref linkend="Pyq03" /> as the GUI
            interface. PyQt is highly portable, and a GPL version makes it
            easy to develop non-commercial, high-performance user interfaces.
            Because PyQt wraps Qt which in turn utilizes the native windowing
            system, user interfaces developed with PyQt tend to perform much
            better than Swing-based Java GUIs. Of course, natively compiled
            C++ that uses Qt directly would perform better still, but Python
            provides a degree of portability not offered (directly) by C++. We
            have used PyQt successfully to develop GUIs that run on desktops
            as well as on PDAs that include Qtopia.</para>
          </section>
        </section>
      </section>
    </chapter>

    <chapter id="intro.javabeans.chapter">
      <title>JavaBeans</title>

      <para>The Tweek Java GUI uses JavaBeans to be more flexible and
      accessible to programmers. The GUI is a framework into which graphical
      and non-graphical components may be <quote>plugged</quote>. Graphical
      components add interaction functionality. Non-graphical components
      extend internal functionality, oftentimes needed by the graphical
      components. Conceptually, this follows the traditional use of plug-in
      architectures wherein the components are discovered dynamically and
      added into the larger framework. In the case of the Tweek Java GUI, the
      plug-ins will fit into one of four categories, the most important of
      which is <firstterm>Panel Bean</firstterm>.</para>

      <section>
        <title>Bean Categories</title>

        <para>There are four types of Beans that may be loaded by the Tweek
        Java GUI. They are categorized based on functionality and what is
        known about them in advance. The following lists the four categories
        in order of decreasing <foreignphrase>a priori</foreignphrase>
        knowledge.</para>

        <orderedlist>
          <listitem>
            <para>Service Beans</para>
          </listitem>

          <listitem>
            <para>Viewer Beans</para>
          </listitem>

          <listitem>
            <para>Panel Beans</para>
          </listitem>

          <listitem>
            <para>Generic Beans</para>
          </listitem>
        </orderedlist>

        <section>
          <title>Service Beans</title>

          <indexterm>
            <primary>Service Beans</primary>
          </indexterm>

          <para>Services encapsulate functionality that may be useful to other
          parts of the Tweek system or dynamically loaded code. The entire
          interface for Service Beans must be known when the code using the
          service is compiled. This is because the using code needs to be able
          to take advantage of the service. Because Service Beans may be
          loaded dynamically, using code must be prepared for the case when
          the Bean containing the service was not found. In other words, code
          that uses services cannot necessarily assume that the service will
          be available.</para>

          <para>Not all services are loaded dynamically as Beans. Some
          services are loaded statically because they are needed by core
          components. These include the Environment Service and the Global
          Preferences Service. There is a guarantee that the code for these
          services will always be available. This guarantee is especially
          important because the Tweek core needs to add information to the
          Environment Service at startup. The Global Preferences Service is
          needed to configure the overall behavior of the Tweek GUI.</para>
        </section>

        <section>
          <title>Viewer Beans</title>

          <indexterm>
            <primary>Viewer Beans</primary>
          </indexterm>

          <para>Viewer Beans provide a rendering of the tree of Panel Beans
          (discussed next). They provide the viewer component of the
          model/view pattern <xref linkend="Gam95" />. All Viewer Beans are
          loaded dynamically, and the active viewer can be changed at runtime
          by editing the global preferences. This feature is realized through
          the flexibility of the model/view pattern.</para>

          <para>Viewer Beans must implement the
          <interfacename>org.vrjuggler.tweek.beans.BeanModelViewer</interfacename>
          interface. To simplify implementation, they may be derived from
          <classname>org.vrjuggler.tweek.beans.DefaultBeanModelViewer</classname>,
          a class that implements aspects of the interface that are unlikely
          to vary between viewer implementations. The use of the interface is
          needed so that the GUI frame can assume certain behaviors about the
          viewer.</para>
        </section>

        <section>
          <title>Panel Beans</title>

          <indexterm>
            <primary>Panel Beans</primary>
          </indexterm>

          <para>Most programmers using Tweek will write Panel Beans. These
          provide custom interfaces for whatever users need. In most cases, a
          Panel Bean will provide a graphical interface that can manipulate
          and/or control a C++ application, but developers are not strictly
          limited to this use.</para>

          <para>Only one assumption is made about Panel Beans: the primary
          class for the Bean must be a subclass of <classname>javax.swing.JComponent</classname>.
          Optionally, the primary class may implement one or more publicly
          provided interfaces that provide the Java GUI with more information
          about the capabilities of the Bean. When loaded, the GUI checks to
          see what, if any, interfaces are implemented by the Bean. Based on
          the results, special actions may be taken to provide the Bean with
          extended functionality.</para>

          <para>For example, Beans that can load files should implement
          <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>.
          When the Bean is focused in the viewer, the <guimenu>File</guimenu>
          menu will be modified to enable the <guimenuitem>Open</guimenuitem>,
          <guimenuitem>Save</guimenuitem>, and <guimenuitem>Close</guimenuitem>
          items. If the user selects one of these items, the Bean is informed
          and can take appropriate customized actions. The result in this case
          is context-specific loading and unloading of files.</para>
        </section>

        <section>
          <title>Generic Beans</title>

          <indexterm>
            <primary>Generic Beans</primary>
          </indexterm>

          <para>Nothing at all is assumed about Generic Beans. This Bean
          category is provided so that other Beans can do their own dynamic
          code loading. For example, a Bean that uses a factory pattern may
          want to have the <quote>workers</quote> loaded dynamically based on
          some criteria. Thus, the functionality of the factory can be changed
          dynamically.</para>

          <para>The Tweek Java GUI does not use Generic Beans itself. These
          are provided more for users of the Tweek Java API. It is up to those
          programmers to decide how to handle the Generic Beans on a
          case-by-case basis.</para>
        </section>
      </section>

      <section>
        <title>XML</title>

        <indexterm>
          <primary>Bean descriptions</primary>

          <secondary>using XML</secondary>
        </indexterm>

        <para>All JavaBeans loaded by the Tweek Java GUI are describe by at
        least one <glossterm linkend="gloss.xml.main">XML</glossterm> file<indexterm><primary>XML</primary></indexterm>.
        The XML file can contain information about many Beans or about a
        single Bean. The XML file itself is a <quote>beanlist</quote>
        document. The four Bean categories, described above, each have an XML
        element that has children giving information about the specific Bean.
        The elements are <sgmltag>&#60;service&#62;</sgmltag>,
        <sgmltag>&#60;viewer&#62;</sgmltag>, <sgmltag>&#60;guipanel&#62;</sgmltag>,
        and <sgmltag>&#60;generic&#62;</sgmltag>.</para>

        <para>All Bean XML entries must contain a <sgmltag>&#60;file&#62;</sgmltag>
        element. Through its <literal>source</literal> attribute, this element
        provides the path to the JAR file that contains the full Bean code.
        When specifying the JAR file path, environment variables may be used.
        They must use the syntax <envar>${ENV_VAR}</envar> (the curly braces
        are required). The <literal>class</literal> element gives the fully
        qualified name of the class stored within the JAR file that will be
        instantiated. The extension <filename>.class</filename> must not be
        specified. This is to allow the use of serialized classes which have
        the extension <filename>.ser</filename>. The Tweek Bean-loading code
        will figure out what is available and take the right actions.</para>

        <para>In addition to the <sgmltag>&#60;file&#62;</sgmltag> element, a
        &#60;dependencies&#62; element may be specified. Dependencies of the
        Bean may be named as external JAR files or other Beans may be listed
        therein. The &#60;dependencies&#62; element may contain zero of more
        elements of type &#60;jar&#62; and/or &#60;bean&#62;. The
        &#60;jar&#62; element has a single attribute, <literal>path</literal>,
        which gives the path (a semi-colon separated list of directories)
        where the JAR file may be found. The contents of the &#60;jar&#62;
        element defines the name of the JAR file. The &#60;bean&#62;
        element&#39;s contents defines the name of the Bean that the current
        Bean depends on.</para>

        <para>Of the four Bean categories, the XML for Panel Beans can contain
        the most information. In addition to the previously mentioned
        elements, Panel Bean entries may have two optional elements:
        <sgmltag>&#60;tree&#62;</sgmltag> and <sgmltag>&#60;icon&#62;</sgmltag>.
        The element <sgmltag>&#60;tree&#62;</sgmltag> specifies the path
        within the Bean tree hierarchy where the Panel Bean will be placed.
        The path is given as a /-separated list of directories. If the named
        path does not exist when the Bean is loaded, it will be created. The
        element <sgmltag>&#60;icon&#62;</sgmltag> names a custom icon for the
        Bean and a tool-tip. An example of a Panel Bean XML entry is shown in
        <xref linkend="PlexusGraphView.xml.example" />. Note that this is not
        the full file—it is only the <sgmltag>&#60;guipanel&#62;</sgmltag>
        element for a single Bean.</para>

        <example id="PlexusGraphView.xml.example">
          <title>PlexusGraphView.xml snippet</title>

          <programlisting>&#60;guipanel name=&#34;Graph View&#34;&#62;
  &#60;file name=&#34;${PLX_BASE_DIR}/bin/beans/PlexusGraphView.jar&#34; 
        class=&#34;plx.graphview.GraphView&#34; /&#62;
  &#60;tree path=&#34;/&#34; /&#62;
  &#60;dependencies&#62;
    &#60;jar path=&#34;${PLX_BASE_DIR}/bin&#34;&#62;openjgraph.jar&#60;/jar&#62;
    &#60;jar path=&#34;${PLX_BASE_DIR}/bin&#34;&#62;jgraph.jar&#60;/jar&#62;
    &#60;jar path=&#34;${PLX_BASE_DIR}/bin&#34;&#62;PlexusComm.jar&#60;/jar&#62;
  &#60;/dependencies&#62;
  &#60;icon source=&#34;jar:file:${PLX_BASE_DIR}/bin/beans/PlexusGraphView.jar!/plx/graphview/icon.gif&#34;
        tooltip=&#34;Plexus Network Graph Visualization&#34; /&#62;
&#60;/guipanel&#62;</programlisting>
        </example>

        <para>This shows the use of all the elements that may be children of
        <sgmltag>&#60;guipanel&#62;</sgmltag>. Note that the
        <literal>source</literal> attribute of <sgmltag>&#60;icon&#62;</sgmltag>
        gets its icon image using a JAR URL.</para>

        <para>Another example XML file is shown in <xref
        linkend="Viewers.xml.example" />. This is the actual file used to load
        the two Viewer Beans that come with the Tweek distribution. This is a
        complete file containing two Viewer Bean entries.</para>

        <example id="Viewers.xml.example">
          <title>Viewers.xml</title>

          <programlisting>&#60;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&#62;
&#60;beanlist xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
          xsi:noNamespaceSchemaLocation=&#34;http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd&#34;&#62;
  &#60;viewer name=&#34;Tree Viewer&#34;&#62;
    &#60;file name=&#34;${TWEEK_BASE_DIR}/bin/beans/Viewers.jar&#34; 
          class=&#34;org.vrjuggler.tweek.treeviewer.BeanTreeViewer&#34; /&#62;
  &#60;/viewer&#62;
  &#60;viewer name=&#34;Icon Viewer&#34;&#62;
    &#60;file name=&#34;${TWEEK_BASE_DIR}/bin/beans/Viewers.jar&#34; 
          class=&#34;org.vrjuggler.tweek.iconviewer.BeanIconViewer&#34; /&#62;
  &#60;/viewer&#62;
&#60;/beanlist&#62;</programlisting>
        </example>
      </section>
    </chapter>
  </part>

  <part>
    <title>Programming</title>

    <partintro>
      <para>In the following chapters, we present the basic information needed
      to start programming with Tweek. There will be discussion covering IDL,
      C++, Java, and CORBA. To use Tweek effectively, a good understanding of
      C++ and Java is required. The IDL aspect of Tweek is minimal, and
      programmers familiar with basic object-oriented concepts should be able
      to understand IDL code easily. Discussion related to CORBA is based on
      the brief introduction given in <xref linkend="intro.corba.section" />.
      The Tweek Java and C++ APIs are designed to hide most CORBA details.
      Whenever possible, references are given to good sources of information
      on all of the aforementioned topics.</para>

      <para>Before proceeding, it is important to know that Tweek is designed
      and implemented to work with VR Juggler 1.1 and 2.0. It can be used with
      VR Juggler 1.0, but there have been reports of conflicts occurring
      between VR Juggler 1.0 and the VR Juggler Portable Runtime (VPR) that is
      part of VR Juggler 1.1. The Tweek C++ code uses VPR for threading, but
      it is possible to replace the VPR objects with VR Juggler 1.0 thread
      objects.</para>
    </partintro>

    <chapter id="prog.idl.chapter">
      <title>IDL</title>

      <para>In this chapter, we present the basic information needed to define
      interfaces that will be used by Tweek. This is not a detailed
      introduction to IDL programming. Readers are referred to <xref
      linkend="Hen99" />.</para>

      <para>IDL <quote>programming</quote> means defining <glossterm
      linkend="gloss.interface">interfaces</glossterm>. In the scope of Tweek
      and CORBA, the interfaces declare what operations may be performed on
      CORBA references. The arguments and return values may be of several
      basic types including, but not limited to, <type>string</type>,
      <type>int</type>, <type>long</type>, and <type>float</type>. These types
      are specified in a language-independent manner. When the IDL compiler
      generates the code for a specific language, the language-specific types
      that correspond to the IDL types are used.</para>

      <para>In <xref linkend="Subject.idl.example" />, we show the Tweek
      <interfacename>Subject</interfacename><indexterm><primary>interfaces</primary><secondary>tweek::Subject</secondary></indexterm>
      interface. Note the similarity to a C++ header file. The IDL file can be
      included by other IDL files, and thus it must <quote>protect</quote> the
      contents in the same manner as a header file. The actual
      <interfacename>Subject</interfacename> interface is defined within the
      <literal>tweek</literal> module. An IDL module corresponds to a C++
      namespace or to a Java package. The interface itself has three methods:
      <methodname>attach()</methodname>, <methodname>detach()</methodname>,
      and <methodname>notify()</methodname>. The first two take a read-only
      argument of type <interfacename>Observer</interfacename>. The fact that
      the argument is read-only (to the server) is specified by the
      <literal>in</literal> modifier. Other modifiers are <literal>out</literal>
      (sent from server to client) and <literal>inout</literal> (initialized
      by the client, writable by the server). The third method,
      <methodname>notify()</methodname>, takes no arguments, and none of the
      methods have a return type.</para>

      <example id="Subject.idl.example">
        <title>Subject.idl</title>

        <indexterm>
          <primary>tweek::Subject</primary>

          <secondary>IDL definition</secondary>
        </indexterm>

        <programlisting>#ifndef _TWEEK_SUBJECT_IDL_
#define _TWEEK_SUBJECT_IDL_

#include &#60;tweek/idl/Observer.idl&#62;

module tweek
{

interface Subject
{
   void attach(in Observer o);
   void detach(in Observer o);
   void notify();
};

};

#endif</programlisting>
      </example>

      <para>By definition, all objects are passed by reference in CORBA. The
      modifier stating the readability and/or writability in the IDL file
      determines how the referenced object may be modified, if at all, within
      the method.</para>

      <para>Applications that make use of Tweek will define custom interfaces
      that extend the <interfacename>Subject</interfacename> interface. For
      example, consider a custom subject that maintains a floating-point
      value. It could have the following interface:</para>

      <example id="CustomSubject.idl.example">
        <title>CustomSubject.idl</title>

        <programlisting>#ifndef _CUSTOM_SUBJECT_IDL_
#define _CUSTOM_SUBJECT_IDL_

#include &#60;tweek/idl/Subject.idl&#62;

module mymod
{

interface CustomSubject : tweek::Subject
{
   float getValue();
   void setValue(in float v);
};

};

#endif</programlisting>
      </example>

      <para>In this interface, we define two methods:
      <methodname>getValue()</methodname> and <methodname>setValue()</methodname>.
      The implementation of this interface would of course include these
      methods and would derive from the implementation of the
      <interfacename>Subject</interfacename> interface.</para>
    </chapter>

    <chapter id="prog.cplusplus.chapter">
      <title>C++</title>

      <indexterm>
        <primary>C++ server API</primary>
      </indexterm>

      <para>Writing C++ code that makes use of Tweek is not difficult, though
      it often requires some good planning. With the current code base, the
      C++ side of things maintains the state information through an
      implementation of the Tweek <interfacename>Subject</interfacename><indexterm><primary>interfaces</primary><secondary>tweek::Subject</secondary></indexterm>
      interface. Instances of such an implementation may need to communicate
      with other parts of a given application, and it is important to define
      these relationships well. In other words, as a maintainer of application
      state information, the subject implementation should have easy access to
      that state information.</para>

      <para>Furthermore, developers must keep in mind that there may be
      asynchronous execution of application code as a result of using Tweek.
      The local ORB runs in its own thread, and as such, it executes methods
      of <glossterm linkend="gloss.servant">servants</glossterm> from that
      thread. Whatever the servant does, it should be thread-safe with respect
      to the rest of the application.</para>

      <para>In this chapter, we cover each aspect of writing C++ code that
      uses the Tweek API. We begin by explaining how to make a custom subject
      implementation. Then, we discuss the use of the CORBA Manager from
      user-level code. We conclude the chapter with an overview of using the
      Subject Manager.</para>

      <section>
        <title>Deriving from <classname>tweek::SubjectImpl</classname></title>

        <indexterm>
          <primary>tweek::SubjectImpl</primary>

          <secondary>deriving from</secondary>
        </indexterm>

        <para>To create a custom subject implementation, you must derive from
        two classes: the abstract class that defines the custom interface and
        <classname>tweek::SubjectImpl</classname>. Referring back to the
        interface shown in <xref linkend="CustomSubject.idl.example" />, the
        basic C++ class declaration would appear as follows:</para>

        <example id="CustomSubjectImpl.h.example">
          <title>CustomSubjectImpl.h</title>

          <programlisting linenumbering="numbered">#ifndef _CUSTOM_SUBJECT_IMPL_H_
#define _CUSTOM_SUBJECT_IMPL_H_

#include &#60;tweek/CORBA/SubjectImpl.h&#62;
#include &#60;CustomSubject.h&#62;

namespace mymod
{

class CustomSubjectImpl : public POA_mymod::CustomSubject,      <co
id="CustomSubjectImpl.interface.line"
linkends="CustomSubjectImpl.superclass.co" />
                          public tweek::SubjectImpl             <co
id="CustomSubjectImpl.SubjectImpl.line"
linkends="CustomSubjectImpl.superclass.co" />
public:
   CustomSubjectImpl() : mValue(0.0f)
   {
      ;
   }

   virtual ~CustomSubjectImpl()
   {
      ;
   }

   virtual float getValue();                                    <co
id="CustomSubjectImpl.setValue.decl"
linkends="CustomSubjectImpl.interface.methods.co" />

   virtual void setValue(float v);                              <co
id="CustomSubjectImpl.getValue.decl"
linkends="CustomSubjectImpl.interface.methods.co" />

   mymod::CustomSubject_ptr _this()                             <co
id="CustomSubjectImpl._this.decl" linkends="CustomSubjectImpl._this.hack.co" />
   {
      return POA_mymod::CustomSubject::_this();
   }

private:
   float mValue;
};

}

#endif</programlisting>

          <calloutlist>
            <callout
            arearefs="CustomSubjectImpl.interface.line CustomSubjectImpl.SubjectImpl.line"
            id="CustomSubjectImpl.superclass.co">
              <para>Here we declare our parent classes,
              <classname>POA_mymod::CustomSubject</classname> and
              <classname>tweek::SubjectImpl</classname>. The first is code
              generated by the IDL compiler, and the second is included as
              part of the Tweek C++ API. Both are necessary for this custom
              interface to work correctly as a Tweek subject.</para>
            </callout>

            <callout
            arearefs="CustomSubjectImpl.setValue.decl CustomSubjectImpl.getValue.decl"
            id="CustomSubjectImpl.interface.methods.co">
              <para>These two declarations correspond to the
              <interfacename>CustomSubject</interfacename> interface defined
              in <xref linkend="CustomSubject.idl.example" />. The
              implementations of these methods are not shown here, but they
              are required for the code to compile. That is, the declarations
              in <classname>POA_mymod::CustomSubject</classname> are pure
              virtual methods, and an instance of <classname>mymod::CustomSubjectImpl</classname>
              cannot be created unless these methods are implemented.</para>
            </callout>

            <callout arearefs="CustomSubjectImpl._this.decl"
            id="CustomSubjectImpl._this.hack.co">
              <para>Overriding the method named <methodname>_this()</methodname>
              is required due to the diamond inheritance tree created by
              deriving from <classname>POA_mymod::CustomSubject</classname>
              and <classname>tweek::SubjectImpl</classname>. Both of these
              classes derive from <classname>tweek::Subject</classname>. The
              <methodname>_this()</methodname> method plays a critical role in
              the CORBA communication, and it is imperative that it return the
              correct type to the caller when invoked on a servant instance.
              Without this override, the returned type will be
              <classname>tweek::Subject_ptr</classname>, and attempts to
              narrow to <classname>mymod::CustomSubject_ptr</classname> will
              fail.</para>

              <para>Note the namespaces used on this method. The return type
              is <classname>mymod::CustomSubject_ptr</classname>, which
              corresponds to the namespace in which the classes
              <classname>CustomSubjectImpl</classname> and
              <classname>CustomSubject</classname> are defined. To get the
              actual value to return, <classname>POA_mymod::CustomSubject</classname>
              (one of the two parent classes) is used.</para>
            </callout>
          </calloutlist>
        </example>

        <para>The implementations of <methodname>getValue()</methodname> and
        <methodname>setValue()</methodname> are fairly obvious, though they
        are presented here for the sake of completeness. Note, however, that
        <methodname>setValue()</methodname> changes the state of the subject,
        and thus any observers must be notified of the change. The
        implementations are shown in the following example.</para>

        <example>
          <title>CustomSubjectImpl.cpp</title>

          <programlisting>#include &#60;CustomSubjectImpl.h&#62;

namespace mymod
{

float CustomSubjectImpl::getValue()
{
   return mValue;
}

void CustomSubjectImpl::setValue(float v)
{
   mValue = v;
   tweek::SubjectImpl::notify();
}

}</programlisting>
        </example>

        <para>The key point to note is the call to <methodname>tweek::SubjectImpl::notify()</methodname>
        in the <methodname>setValue()</methodname> implementation. In general,
        anything that modifies the state of the subject requires that this
        method be invoked. Note also that the method is fully qualified so
        that we are sure to call the correct implementation.</para>
      </section>

      <section>
        <title>Using the CORBA Manager</title>

        <indexterm>
          <primary>CORBA Manager</primary>

          <secondary>use of</secondary>
        </indexterm>

        <para>Initializing the CORBA Manager is straightforward, but it does
        require exception handling. If the exceptions are not handled
        correctly, applications will abort if an exception is thrown but not
        caught. Refer to a C++ reference for more information about exceptions
        and exception handling in C++.</para>

        <para>The following example shows a <function>main()</function>
        function for an application that performs all the Tweek initialization
        steps. We separate the discussion into two parts: one part for the
        CORBA Manager and one part for the Subject Manager (discussed in the
        next section).</para>

        <example id="TweekApp.cpp.CORBA-Manager.example">
          <title>TweekApp.cpp</title>

          <programlisting linenumbering="numbered">#include &#60;vpr/vpr.h&#62;
#include &#60;vpr/Thread/Thread.h&#62;
#include &#60;vpr/Util/Debug.h&#62;
#include &#60;tweek/CORBA/CorbaManager.h&#62;                                        <co
id="TweekApp.cpp.includes.tweek" linkends="TweekApp.cpp.includes.co" />

#include &#60;CustomSubjectImpl.h&#62;                                               <co
id="TweekApp.cpp.includes.gen" linkends="TweekApp.cpp.includes.co" />

/**
 * This application starts the CORBA server for the C++ side of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;                                                  <co
id="TweekApp.cpp.corbamgr.decl" linkends="TweekApp.cpp.corbamgr.decl.co" />

   // The first thing we have to do is initialize the Tweek CORBA Manager.
   // If this fails, we&#39;re out of luck.
   try                                                                       <co
id="TweekApp.cpp.big-try-catch.try" linkends="TweekApp.cpp.big-try-catch.co" />
   {
      if ( mgr.init(&#34;example&#34;, argc, argv).success() )                       <co
id="TweekApp.cpp.corbamgr.init" linkends="TweekApp.cpp.corbamgr.init.co" />
      {
         vpr::ReturnStatus status;

         // Once the CORBA Manager is initialized, we need to create a
         // Subject Manager.  This will hold our CustomSubject object.
         try
         {
            status = mgr.createSubjectManager();

            // If we were able to create the Subject Manager, now we register
            // our objects with it.
            if ( status.success() )
            {
               // First, create real instances of the C++ object that will
               // be the CORBA servant.  This must be allocated on the heap.
               mymod::CustomubjectImpl* custom_subj =
                  new mymod::CustomSubjectImpl();

               // Now we try to register the subject and give it a symbolic,
               // easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&#62;registerSubject(slider_subj,
                                                           &#34;CustomSubject&#34;);
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &#60;&#60; &#34;Failed to register subject\n&#34; &#60;&#60; vprDEBUG_FLUSH;
               }
            }
         }
         catch (CORBA::Exception&#38; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &#60;&#60; &#34;Caught an unknown CORBA exception when trying to register!\n&#34;
               &#60;&#60; vprDEBUG_FLUSH;
         }

         if ( ! status.success() )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &#60;&#60; &#34;Failed to register Subject Manager instance\n&#34;
               &#60;&#60; vprDEBUG_FLUSH;
         }

         std::cout &#60;&#60; &#34;Press &#39;x&#39; to exit&#34; &#60;&#60; std::endl;
         char input;

         // Loop forever so that we can act sort of like a server.
         while ( 1 )
         {
            std::cin &#62;&#62; input;
            if ( input == &#39;x&#39; )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &#60;&#60; &#34;CORBA failed to initialize\n&#34; &#60;&#60; vprDEBUG_FLUSH;
      }
   }
   catch (...)                                                               <co
id="TweekApp.cpp.big-try-catch.catch" linkends="TweekApp.cpp.big-try-catch.co" />
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &#60;&#60; &#34;Caught an unknown exception!\n&#34; &#60;&#60; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL) &#60;&#60; &#34;Exiting\n&#34; &#60;&#60; vprDEBUG_FLUSH;

   return 0;
}</programlisting>

          <calloutlist>
            <callout
            arearefs="TweekApp.cpp.includes.tweek TweekApp.cpp.includes.gen"
            id="TweekApp.cpp.includes.co">
              <para>These two headers are typically needed. The first includes
              the declaration of the Tweek CORBA Manager, and the second is
              the subject implementation declaration, shown in <xref
              linkend="CustomSubjectImpl.h.example" />.</para>
            </callout>

            <callout arearefs="TweekApp.cpp.corbamgr.decl"
            id="TweekApp.cpp.corbamgr.decl.co">
              <para>In order to use CORBA through Tweek, the CORBA Manager
              must be created and initialized. Any number of these may be
              created, but in general, only one is needed per application.
              Here, we declare an instance of <classname>tweek::CorbaManager</classname>
              on the stack.</para>
            </callout>

            <callout arearefs="TweekApp.cpp.corbamgr.init"
            id="TweekApp.cpp.corbamgr.init.co">
              <para>Next, we must initialize the CORBA Manager using the
              method <methodname>tweek::CorbaManager::init()</methodname>. The
              first argument provides a unique (ideally) identifier for the
              local Portable Object Adapter (POA). The second and third
              arguments are <varname>argc</varname> and <varname>argv</varname>
              respectively. They come in through the argument list of
              <function>main()</function> and represent the command-line
              arguments. Any arguments relevant to ORB initialization are
              removed from <varname>argv</varname>, and <varname>argc</varname>
              is decremented accordingly (it is passed by reference).</para>
            </callout>

            <callout
            arearefs="TweekApp.cpp.big-try-catch.try TweekApp.cpp.big-try-catch.catch"
            id="TweekApp.cpp.big-try-catch.co">
              <para>To ensure that no exceptions go uncaught, we enclose the
              bulk of <function>main()</function> in a try/catch block that
              catches any exception. This is handled by the argument list
              passed to the catch block, <literal>(...)</literal>. This is the
              equivalent of catching <classname>java.lang.Exception</classname>
              in Java.</para>
            </callout>
          </calloutlist>
        </example>
      </section>

      <section>
        <title>Using the Subject Manager</title>

        <indexterm>
          <primary>Subject Manager</primary>

          <secondary>use of</secondary>
        </indexterm>

        <para>To demonstrate use of the Subject Manager, we begin by
        revisiting the <function>main()</function> function examined in the
        previous section. This time, we will focus our attention on the code
        related to the Subject Manager only. We will also explain how to use
        the extended API of the Subject Manager implementation.</para>

        <para>It is important to know that the Subject Manager is a CORBA
        object that can be accessed by remote code. In the following example,
        the methods used are defined in the class <classname>tweek::SubjectManagerImpl</classname>,
        the C++ implementation of the <interfacename>tweek::SubjectManager</interfacename>
        interface. The details of how the Subject Manager is handled through
        CORBA are largely irrelevant for most users of Tweek. Simply bear in
        mind that the Subject Manager is accessibly remotely and that it
        simplifies the use of CORBA in general.</para>

        <section>
          <title>Subject Manager Initialization</title>

          <para>In order to use the Tweek Subject Manager, it must be
          initialized. Each CORBA Manager should have a single Subject Manager
          associated with it. If not, use of Tweek will be much more difficult
          because the CORBA Manager and the Subject Manager together hide most
          of the details relating to the use of CORBA. The following example
          shows how to initialize the Subject Manager using the CORBA Manager
          object created earlier.</para>

          <example id="TweekApp.cpp.Subject-Manager.example">
            <title>TweekApp.cpp</title>

            <programlisting linenumbering="numbered">#include &#60;vpr/vpr.h&#62;
#include &#60;vpr/Thread/Thread.h&#62;
#include &#60;vpr/Util/Debug.h&#62;
#include &#60;tweek/CORBA/CorbaManager.h&#62;

#include &#60;CustomSubjectImpl.h&#62;

/**
 * This application starts the CORBA server for the C++ side of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;

   // The first thing we have to do is initialize the Tweek CORBA Manager.
   // If this fails, we&#39;re out of luck.
   try
   {
      if ( mgr.init(&#34;corba_test&#34;, argc, argv).success() )
      {
         vpr::ReturnStatus status;

         // Once the CORBA Manager is initialized, we need to create a
         // Subject Manager.  This will hold our CustomSubject object.
         try
         {
            status = mgr.createSubjectManager();                             <co
id="TweekApp.cpp.subjectmgr.create"
linkends="TweekApp.cpp.subjectmgr.create.co" />

            // If we were able to create the Subject Manager, now we register
            // our objects with it.
            if ( status.success() )
            {
               // First, create real instances of the C++ object that will
               // be the CORBA servant.  This must be allocated on the heap.
               mymod::CustomubjectImpl* custom_subj =
                  new mymod::CustomSubjectImpl();                            <co
id="TweekApp.cpp.subject.create" linkends="TweekApp.cpp.subject.create.co" />

               // Now we try to register the subject and give it a symbolic,
               // easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&#62;registerSubject(custom_subj,
                                                           &#34;CustomSubject&#34;); <co
id="TweekApp.cpp.subject.register" linkends="TweekApp.cpp.subject.register.co" />
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &#60;&#60; &#34;Failed to register subject\n&#34; &#60;&#60; vprDEBUG_FLUSH;
               }
            }
         }
         catch (CORBA::Exception&#38; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &#60;&#60; &#34;Caught an unknown CORBA exception when trying to register!\n&#34;
               &#60;&#60; vprDEBUG_FLUSH;
         }

         if ( ! status.success() )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &#60;&#60; &#34;Failed to register Subject Manager instance\n&#34;
               &#60;&#60; vprDEBUG_FLUSH;
         }

         std::cout &#60;&#60; &#34;Press &#39;x&#39; to exit&#34; &#60;&#60; std::endl;
         char input;

         // Loop forever so that we can act sort of like a server.
         while ( 1 )                                                         <co
id="TweekApp.cpp.loop" linkends="TweekApp.cpp.loop.co" />
         {
            std::cin &#62;&#62; input;
            if ( input == &#39;x&#39; )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &#60;&#60; &#34;CORBA failed to initialize\n&#34; &#60;&#60; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &#60;&#60; &#34;Caught an unknown exception!\n&#34; &#60;&#60; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL) &#60;&#60; &#34;Exiting\n&#34; &#60;&#60; vprDEBUG_FLUSH;

   return 0;
}</programlisting>

            <calloutlist>
              <callout arearefs="TweekApp.cpp.subjectmgr.create"
              id="TweekApp.cpp.subjectmgr.create.co">
                <para>After the COBRA Manager has been initialized
                successfully, the Tweek Subject Manager must be created. We do
                this by invoking the method <methodname>tweek::CorbaManager::createSubjectManager()</methodname>
                on our <methodname>tweek::CorbaManager</methodname> instance.</para>
              </callout>

              <callout arearefs="TweekApp.cpp.subject.create"
              id="TweekApp.cpp.subject.create.co">
                <para>Once we have a valid Subject Manager, we must register
                subjects with it in order for object references to be passed
                out by CORBA. This creates the <glossterm
                linkend="gloss.servant">servant</glossterm> to which
                <interfacename>mymod::CustomSubject</interfacename> references
                will be made.</para>
              </callout>

              <callout arearefs="TweekApp.cpp.subject.register"
              id="TweekApp.cpp.subject.register.co">
                <para>Once the servant is created, it is registered with the
                Subject Manager. The Subject Manager will activate the servant
                within the POA so that references to it can be created and
                returned to clients. We register it with the symbolic name
                <quote>CustomSubject</quote> that can be referenced later by
                remote objects.</para>
              </callout>

              <callout arearefs="TweekApp.cpp.loop" id="TweekApp.cpp.loop.co">
                <para>After the subject is registered, all the work is done.
                This simple application now just waits for clients to request
                references. It will exit when the user enters &#39;<literal>x</literal>&#39;.</para>
              </callout>
            </calloutlist>
          </example>

          <para>Note that all the code relating to the Subject Manager is
          enclosed within another try/catch block. This block only catches
          exceptions of type <classname>CORBA::Exception</classname>. Anything
          more general is caught by the larger try/catch block.</para>
        </section>

        <section>
          <title>tweek::SubjectManagerImpl API</title>

          <para>The class <classname>tweek::SubjectManagerImpl</classname> has
          some methods that are not part of the IDL-specified interface. One
          such method is <methodname>registerSubject()</methodname>, which was
          used in the preceding example. Some other methods that may be of
          interest to users are described in the following subsections.</para>

          <section>
            <title><methodname>setApplicationName()</methodname></title>

            <indexterm>
              <primary>tweek::SubjectManagerImpl</primary>

              <secondary>setApplicationName() method</secondary>
            </indexterm>

            <methodsynopsis>
              <modifier>public</modifier>

              <type>void</type>

              <methodname>setApplicationName</methodname>

              <methodparam>
                <type>const std::string&#38;</type>

                <parameter>appName</parameter>
              </methodparam>
            </methodsynopsis>

            <para>This method can be used to set one of the
            application-specific identifiers within the Subject Manager.
            Namely, it sets the application name identifier. These identifiers
            are used to aid users in choosing a Subject Manager instance when
            making remote connections to applications.</para>
          </section>

          <section>
            <title><methodname>setUserName()</methodname></title>

            <indexterm>
              <primary>tweek::SubjectManagerImpl</primary>

              <secondary>setUserName() method</secondary>
            </indexterm>

            <methodsynopsis>
              <modifier>public</modifier>

              <type>void</type>

              <methodname>setUserName</methodname>

              <methodparam>
                <type>const std::string&#38;</type>

                <parameter>userName</parameter>
              </methodparam>
            </methodsynopsis>

            <para>Similar to <methodname>setApplicationName()</methodname>,
            this method allows users to tell the Subject Manager their user
            name. When multiple users are all running the same application
            (and are thus using the same parameter to
            <methodname>setApplicationName()</methodname>), this provides
            another level of uniqueness. If this method is not used, the
            Subject Manager will try to get the user name through the
            <envar>$USER</envar> environment variable.</para>
          </section>

          <section>
            <title><methodname>addInfoItem()</methodname></title>

            <indexterm>
              <primary>tweek::SubjectManagerImpl</primary>

              <secondary>addInfoItem() method</secondary>
            </indexterm>

            <methodsynopsis>
              <modifier>public</modifier>

              <type>void</type>

              <methodname>addInfoItem</methodname>

              <methodparam>
                <type>const std::string&#38;</type>

                <parameter>key</parameter>
              </methodparam>

              <methodparam>
                <type>const std::string&#38;</type>

                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>

            <para>If the previous two built-in Subject Manager identifiers are
            not enough, the method <methodname>addInfoItem()</methodname>
            allows users to define their own unique identifiers. The first
            parameter is the identifier, and the second is its (ideally)
            unique value. Users are free to add any key/value pairs they need
            in order to aid in the selection of a Subject Manager at runtime.</para>
          </section>
        </section>
      </section>
    </chapter>

    <chapter id="prog.java.chapter">
      <title>Java</title>

      <indexterm>
        <primary>Java client API</primary>
      </indexterm>

      <para></para>

      <section>
        <title>Java Libraries</title>

        <para>The Tweek Java API is broken up into a collection of Java class
        libraries, each packaged in a unique JAR file. Programmers can choose
        the library or libraries they need when writing Java code that uses
        Tweek. It is possible to write JavaBeans that do not use any of the
        Tweek Java libraries, but such Beans may not be very full-featured. On
        the other hand, because the Tweek Java GUI is capable of loading any
        JavaBean, there is no reason that a fully functional Bean must be
        written to take advantage of Tweek services and utilities.</para>

        <section id="bean.library.section">
          <title>Bean Library</title>

          <indexterm>
            <primary>Java libraries</primary>

            <secondary>Bean</secondary>
          </indexterm>

          <para></para>
        </section>

        <section id="event.library.section">
          <title>Event Library</title>

          <indexterm>
            <primary>Java libraries</primary>

            <secondary>Event</secondary>
          </indexterm>

          <para></para>
        </section>

        <section id="gui.library.section">
          <title>GUI Library</title>

          <indexterm>
            <primary>Java libraries</primary>

            <secondary>GUI</secondary>
          </indexterm>

          <para></para>
        </section>

        <section id="network.library.section">
          <title>Network Library</title>

          <indexterm>
            <primary>Java libraries</primary>

            <secondary>Network</secondary>
          </indexterm>

          <para></para>
        </section>

        <section id="beandelivery.library.section">
          <title>Bean Delivery Library</title>

          <indexterm>
            <primary>Java libraries</primary>

            <secondary>Bean Delivery</secondary>
          </indexterm>

          <para>The Bean Delivery Library makes use of the Bean Library and
          the Network Library to allow JavaBeans to be transferred across the
          network. More specifically, a remote subject, most likely written in
          C++, can <quote>push</quote> JavaBeans to the Tweek GUI where they
          can be handled as though they were loaded from the local disk.</para>
        </section>
      </section>
    </chapter>

    <chapter id="prog.all.chapter">
      <title>Putting It All Together</title>

      <para>Based on the information presented in the previous chapters, we
      can combine everything into an examples. In this chapter, we present the
      step-by-step process for using the Tweek Java and C++ APIs.</para>

      <section id="collab.slider.section">
        <title>Collaborative Slider</title>

        <para>In this example, we explain how to develop a simple Tweek
        interface. The goal is to have a <quote>collaborative</quote> slider
        in a Java GUI component. The value displayed by the slider is retained
        by a C++ application so that multiple independent sliders can show the
        same value. The steps explained here are highly representative of the
        normal steps to be followed when using the Tweek Java and C++ APIs.
        The structure of the following sections lays out the order of the
        steps taken. An example makefile that goes along with the code
        presented can be found in <xref
        linkend="SliderSubject.makefile.section" /> of <xref
        linkend="makefile.appendix" />. The full source for the examples
        presented in this section can be found in <filename>$TWEEK_BASE_DIR/share/test/NetworkTestBean</filename>.</para>

        <section>
          <title>The Subject</title>

          <para>To begin, the subject interface must be defined in IDL and
          implemented in C++. The interface itself will be <quote>compiled</quote>
          into Java and C++ code. Both ends of the communication channels must
          know the interface in order for the references to be used, thus
          requiring the generation of code for both languages.</para>

          <section>
            <title>Creating the Interface</title>

            <para>Creating an IDL interface involves writing an IDL file. For
            this example, we will be storing an integer variable in a C++
            servant. The Java GUIs will need to read and write the value, so
            we need two methods: <methodname>getValue()</methodname> and
            <methodname>setValue()</methodname>. The type being passed between
            <glossterm linkend="gloss.orb">ORBs</glossterm> will be
            <type>long</type>, a 32-bit integer. Depending on the target
            language, this will map to the corresponding type of the same
            size.</para>

            <example id="SliderSubject.idl.example">
              <title>SliderSubject.idl</title>

              <programlisting linenumbering="numbered">#ifndef _NETWORK_TEST_SLIDER_SUBJECT_IDL_    <co
id="cpp.ifndef.line" linkends="cpp.protection.co" />
#define _NETWORK_TEST_SLIDER_SUBJECT_IDL_    <co id="cpp.define.line"
linkends="cpp.protection.co" />

#include &#60;tweek/idl/Subject.idl&#62;             <co
id="tweek.subject.idl.include" linkends="tweek.subject.idl.include.co" />

module networktest                           <co id="idl.module.block"
linkends="idl.module.block.co" />
{
   interface SliderSubject : tweek::Subject  <co id="idl.interface.decl"
linkends="idl.interface.decl.co" />
   {
      void setValue(in long val);            <co
id="SliderSubject.setValue.decl" linkends="SliderSubject.methods.co" />
      long getValue();                       <co
id="SliderSubject.getValue.decl" linkends="SliderSubject.methods.co" />
   };
};

#endif                                       <co id="cpp.endif.line"
linkends="cpp.protection.co" />
</programlisting>

              <calloutlist>
                <callout
                arearefs="cpp.ifndef.line cpp.define.line cpp.endif.line"
                id="cpp.protection.co">
                  <para>IDL files are run through the C preprocessor so that
                  they may include external files. To prevent including the
                  same source multiple times, the file must be enclosed in the
                  traditional preprocessor protection block. This is exactly
                  what is done in C/C++ header files.</para>
                </callout>

                <callout arearefs="tweek.subject.idl.include"
                id="tweek.subject.idl.include.co">
                  <para>All Tweek subject IDL files must include
                  <filename>tweek/idl/Subject.idl</filename>. This is required
                  so that the interface being defined can inherit from
                  <interfacename>tweek::Subject</interfacename>.</para>
                </callout>

                <callout arearefs="idl.module.block" id="idl.module.block.co">
                  <para>Typically, using a module to contain the interface is
                  recommended. Using a module defines a Java package and a C++
                  namespace (named <literal>networktest</literal> in this
                  case).</para>
                </callout>

                <callout arearefs="idl.interface.decl"
                id="idl.interface.decl.co">
                  <para>The definition of the subject interface must inherit
                  from <interfacename>tweek::Subject</interfacename>. If this
                  is not done, there is no way that the subject interface will
                  plug into the Subject Manager.</para>
                </callout>

                <callout
                arearefs="SliderSubject.setValue.decl SliderSubject.getValue.decl"
                id="SliderSubject.methods.co">
                  <para>This simple interface has only two functions:
                  <methodname>setValue()</methodname> and
                  <methodname>getValue()</methodname>. The method getValue()
                  takes a single read-only parameter of type <type>long</type>;
                  <methodname>getValue()</methodname> returns a value of the
                  same type.</para>
                </callout>
              </calloutlist>
            </example>

            <para>The file <filename>SliderSubject.idl</filename> must be
            <quote>compiled</quote> by an <glossterm
            linkend="gloss.idl-compiler">IDL compiler</glossterm>. For use
            with Tweek, the interface must be compiled into Java and C++ code.
            The generated Java code will be used solely for communicating with
            CORBA <interfacename>networktest.SliderSubject</interfacename>
            references. The generated C++ code will be extended to provide an
            implementation of the <interfacename>networktest::SliderSubject</interfacename>
            interface. (The implementation will be a CORBA <glossterm
            linkend="gloss.servant">servant</glossterm> object to which
            references will be made by remote Java code.)</para>
          </section>

          <section>
            <title>Implementing the Interface in C++</title>

            <para>After running an IDL compiler to generate the stub CORBA
            code, the interface must be implemented. In particular, there will
            be pure virtual methods in <filename>SliderSubject.h</filename>
            that must be implemented. The implementing class will be the CORBA
            <glossterm linkend="gloss.servant">servant</glossterm> holding the
            actual data visualized in the Java GUI slider.</para>

            <example id="SliderSubjectImpl.h.example">
              <title>SliderSubjectImpl.h</title>

              <programlisting linenumbering="numbered">#ifndef _SLIDER_SUBJECT_IMPL_H_
#define _SLIDER_SUBJECT_IMPL_H_

#include &#60;tweek/tweekConfig.h&#62;

#include &#60;vector&#62;

#include &#60;tweek/CORBA/SubjectImpl.h&#62;                               <co
id="SliderSubjectImpl.h.includes.subjimpl"
linkends="SliderSubjectImpl.h.includes.co" />
#include &#60;SliderSubject.h&#62;                                         <co
id="SliderSubjectImpl.h.include.subj"
linkends="SliderSubjectImpl.h.include.subj.co" />

namespace networktest                                              <co
id="SliderSubjectImpl.h.namespace" linkends="SliderSubjectImpl.h.namespace.co" />
{

/**
 * This class is an extension to the base Tweek SubjectImpl class.  It uses
 * multiple inheritance with that class and with the generated CORBA class
 * corresponding to the IDL for SliderSubject.
 */
class SliderSubjectImpl : public POA_networktest::SliderSubject,   <co
id="SliderSubjectImpl.h.class.decl"
linkends="SliderSubjectImpl.h.class.decl.co" />
                          public tweek::SubjectImpl
{
public:
   SliderSubjectImpl()
      : tweek::SubjectImpl(), mValue(0)
   {
      /* Do nothing. */ ;
   }

   virtual ~SliderSubjectImpl()
   {
      /* Do nothing. */ ;
   }

   /**
    * Sets this subject&#39;s internal value.
    */
   virtual void setValue(long value);                              <co
id="SliderSubjectImpl.h.setValue" linkends="SliderSubjectImpl.h.virtuals.co" />

   /**
    * Returns this subject&#39;s internal value.
    */
   virtual long getValue();                                        <co
id="SliderSubjectImpl.h.getValue" linkends="SliderSubjectImpl.h.virtuals.co" />

   /**
    * This overriding method is needed so that the correct type is returned
    * when the _this() method is invoked.  Without this method, an object of
    * type tweek::Subject_ptr would be returned.
    *
    * XXX: It may be possible to remove this requirement in the future.
    */  
   networktest::SliderSubject_ptr _this()                          <co
id="SliderSubjectImpl.h.hack" linkends="SliderSubjectImpl.h.hack.co" />
   {
      return POA_networktest::SliderSubject::_this();
   }

private:
   long mValue;   /**&#60; Our value */                                <co
id="SliderSubjectImpl.h.mValue" linkends="SliderSubjectImpl.h.mValue.co" />
};

} // End of networktest namespace


#endif /* _SLIDER_SUBJECT_IMPL_H_ */</programlisting>

              <calloutlist>
                <callout arearefs="SliderSubjectImpl.h.includes.subjimpl"
                id="SliderSubjectImpl.h.includes.co">
                  <para>These files will always be included by implementations
                  of Tweek subject derived classes. The first contains the
                  declaration for the basic Tweek subject implementation. The
                  second contains the C++ code generated from the Tweek
                  <filename>Observer.idl</filename> file.</para>
                </callout>

                <callout arearefs="SliderSubjectImpl.h.include.subj"
                id="SliderSubjectImpl.h.include.subj.co">
                  <para>This header is generated by the IDL compiler from
                  <filename>SliderSubject.idl</filename>. In particular, it
                  defines the class from which <classname>networktest::SliderSubjectImpl</classname>
                  must inherit.</para>
                </callout>

                <callout arearefs="SliderSubjectImpl.h.namespace"
                id="SliderSubjectImpl.h.namespace.co">
                  <para>In <filename>SliderSubject.idl</filename>, shown in
                  <xref linkend="SliderSubject.idl.example" />, the interface
                  is in the <literal>networktest</literal> module. In the C++
                  implementation code, the module name corresponds to a
                  namespace.</para>
                </callout>

                <callout arearefs="SliderSubjectImpl.h.class.decl"
                id="SliderSubjectImpl.h.class.decl.co">
                  <para>The interface implementation class must inherit from
                  the IDL-generated class <classname>POA_networktest::SliderSubject</classname>
                  and from <classname>tweek::SubjectImpl</classname>.</para>
                </callout>

                <callout
                arearefs="SliderSubjectImpl.h.setValue SliderSubjectImpl.h.getValue"
                id="SliderSubjectImpl.h.virtuals.co">
                  <para><classname>POA_networktest::SliderSubject</classname>
                  defines two pure virtual methods that must be implemented.
                  These correspond to the methods in <filename>SliderSubject.idl</filename>.</para>
                </callout>

                <callout arearefs="SliderSubjectImpl.h.hack"
                id="SliderSubjectImpl.h.hack.co">
                  <para>As of this writing, all subject implementations must
                  contain an overriding version of the
                  <methodname>_this()</methodname> method. This is due to the
                  use of multiple inheritance. Note the return type and the
                  <literal>return</literal> statement. These will vary for
                  each subject implementation based on the name of the
                  IDL-defined interface.</para>
                </callout>

                <callout arearefs="SliderSubjectImpl.h.mValue"
                id="SliderSubjectImpl.h.mValue.co">
                  <para>This is the actual value being stored by the C++
                  servant.</para>
                </callout>
              </calloutlist>
            </example>

            <para>In <filename>SliderSubjectImpl.h</filename>, the most
            important parts to note are the use of multiple inheritance, the
            declarations of the <interfacename>SliderSubject</interfacename>
            interface methods, and the implementation of
            <methodname>_this()</methodname>. The implementations of
            <methodname>setValue()</methodname> and <methodname>getValue()</methodname>
            are shown next in <xref linkend="SliderSubjectImpl.cpp.example" />.</para>

            <example id="SliderSubjectImpl.cpp.example">
              <title>SliderSubjectImpl.cpp</title>

              <programlisting linenumbering="numbered">#include &#60;vpr/Util/Debug.h&#62;
#include &#60;SliderSubjectImpl.h&#62;                   <co
id="SliderSubjectImpl.cpp.inc" linkends="SliderSubjectImpl.cpp.inc.co" />

namespace networktest
{

void SliderSubjectImpl::setValue(long value)
{
   mValue = value;                               <co
id="SliderSubjectImpl.cpp.mValue.assign"
linkends="SliderSubjectImpl.cpp.mValue.assign.co" />

   // Notify any observers that our value has changed.  This is very
   // important.
   tweek::SubjectImpl::notify();                 <co
id="SliderSubjectImpl.cpp.notify" linkends="SliderSubjectImpl.cpp.notify.co" />
}

long SliderSubjectImpl::getValue()
{
   return mValue;                                <co
id="SliderSubjectImpl.cpp.mValue.return"
linkends="SliderSubjectImpl.cpp.mValue.return.co" />
}

} // End networktest namespace</programlisting>

              <calloutlist>
                <callout arearefs="SliderSubjectImpl.cpp.inc"
                id="SliderSubjectImpl.cpp.inc.co">
                  <para>Include the class declaration file, shown in <xref
                  linkend="SliderSubjectImpl.h.example" />.</para>
                </callout>

                <callout arearefs="SliderSubjectImpl.cpp.mValue.assign"
                id="SliderSubjectImpl.cpp.mValue.assign.co">
                  <para>When invoked, the remote caller will pass a
                  <type>long</type> value, and this saves the result into the
                  servant&#39;s storage.</para>
                </callout>

                <callout arearefs="SliderSubjectImpl.cpp.notify"
                id="SliderSubjectImpl.cpp.notify.co">
                  <para>Because the subject&#39;s state has been modified, all
                  attached observers must be notified. This is a very
                  important step that must be taken in this method. Note that
                  it invokes the <methodname>notify()</methodname> method of
                  the parent class.</para>
                </callout>

                <callout arearefs="SliderSubjectImpl.cpp.mValue.return"
                id="SliderSubjectImpl.cpp.mValue.return.co">
                  <para>Observers will invoke this method when requesting the
                  current <varname>mValue</varname>.</para>
                </callout>
              </calloutlist>
            </example>
          </section>
        </section>

        <section>
          <title>The Observer</title>

          <para>The observer does not define its own specialized IDL
          interface. Instead, it makes use of the existing Tweek basic
          observer (<classname>tweek.ObserverPOA</classname><indexterm><primary>classes</primary><secondary>tweek.ObserverPOA</secondary></indexterm>
          in Java). The method <methodname>update()</methodname> must be
          implemented. The remainder of the observer implementation is
          centered around communication with a <interfacename>SliderSubject</interfacename>
          object reference. All observer code is written in Java. The only C++
          code for observers is part of the Tweek library, and it is generated
          entirely by the <glossterm linkend="gloss.idl-compiler">IDL compiler</glossterm>.</para>

          <section id="implement.observer.java.section">
            <title>Implementing the Observer in Java</title>

            <para>For every subject interface defined in IDL, a corresponding
            observer class must be written in Java. Without an observer, there
            is no way for the Java and C++ sides to conduct useful two-way
            communication. At best, the Java GUI could request a subject
            reference and manipulate the C++ application through the
            reference, but the communication would be entirely one-way.</para>

            <para>In <xref linkend="SliderObserverImpl.java.example" />, we
            show the complete Java implementation of an observer corresponding
            to the <interfacename>tweek::SliderSubject</interfacename>
            interface defined earlier. (The JavaBean that uses this observer
            is explained in <xref linkend="slider.subject.bean.section" />.)
            The main focus of this observer is to update its contained
            <classname>JSlider</classname> whenever the state of the
            corresponding subject changes.</para>

            <example id="SliderObserverImpl.java.example">
              <title>SliderObserverImpl.java</title>

              <programlisting linenumbering="numbered">package networktest;

import javax.swing.DefaultBoundedRangeModel;
import javax.swing.JSlider;
import tweek.*;

/**
 * Implementation of the Observer side of the Tweek Subject/Observer pattern.
 * It must extend tweek.ObserverPOA so that instances of this class can be
 * registered as CORBA servants.  In addition, CORBA references to the
 * servants must be capable of being attached to remote subjects.
 */
public class SliderObserverImpl extends ObserverPOA                  <co
id="SliderObserverImpl.java.class.decl"
linkends="SliderObserverImpl.java.class.decl.co" />
{
   public SliderObserverImpl(JSlider slider, SliderSubject subject)  <co
id="SliderObserverImpl.java.constructor"
linkends="SliderObserverImpl.java.constructor.co" />
   {
      mSlider        = slider;
      mSliderSubject = subject;
   }

   /**
    * Implements the required method in tweek.ObserverPOA.  The remote subject
    * will invoke this method whenever it is notified of a change.
    */
   public void update()                                              <co
id="SliderObserverImpl.java.update"
linkends="SliderObserverImpl.java.update.co" />
   {
      // If we have a valid slider object, we need to update its value to
      // whatever our subject has.
      if ( mSlider != null )
      {
         DefaultBoundedRangeModel model =
            (DefaultBoundedRangeModel) mSlider.getModel();
         model.setValue(mSliderSubject.getValue());                  <co
id="SliderObserverImpl.java.getValue"
linkends="SliderObserverImpl.java.getValue.co" />
         mSlider.repaint();
      }
   }

   /**
    * Detaches this observer from our subject.  This is needed when shutting
    * down a CORBA connection.
    */
   public void detach()
   {
      mSliderSubject.detach(this._this());                           <co
id="SliderObserverImpl.java.detach"
linkends="SliderObserverImpl.java.detach.co" />
   }

   private SliderSubject mSliderSubject = null;
   private JSlider       mSlider        = null;
}</programlisting>

              <calloutlist>
                <callout arearefs="SliderObserverImpl.java.class.decl"
                id="SliderObserverImpl.java.class.decl.co">
                  <para>As an observer, this class must derive from
                  <classname>tweek.ObserverPOA</classname>. This class is
                  generated by the IDL compiler and is part of the Tweek
                  Network Library (see <xref linkend="network.library.section" />).</para>
                </callout>

                <callout arearefs="SliderObserverImpl.java.constructor"
                id="SliderObserverImpl.java.constructor.co">
                  <para>The constructor for this observer takes two arguments:
                  a <classname>JSlider</classname> object reference and a
                  <interfacename>networktest.SliderSubject</interfacename>
                  object reference. The observer needs the latter argument so
                  that it can query state information from the subject when
                  notified of state changes. This is part of the
                  subject/observer design pattern <xref linkend="Gam95" />.</para>
                </callout>

                <callout arearefs="SliderObserverImpl.java.update"
                id="SliderObserverImpl.java.update.co">
                  <para>As stated, all observers must implement
                  <methodname>update()</methodname>. This will be invoked by
                  the remote subject when its <methodname>notify()</methodname>
                  method is invoked.</para>
                </callout>

                <callout arearefs="SliderObserverImpl.java.getValue"
                id="SliderObserverImpl.java.getValue.co">
                  <para>To get the updated state of the remote subject, the
                  encapsulated subject reference&#39;s
                  <methodname>getValue()</methodname> method is invoked. The
                  value returned will be the most up-to-date information from
                  the subject.</para>
                </callout>

                <callout arearefs="SliderObserverImpl.java.detach"
                id="SliderObserverImpl.java.detach.co">
                  <para>It may be convenient for the observer to implement a
                  <methodname>detach()</methodname> method (though the name
                  may vary). This is used when the Java application is
                  shutting down to ensure that the remote subject does not
                  have dangling references to observers that no longer exist.
                  The only action required here is invoking the subject&#39;s
                  <methodname>detach()</methodname> method to inform the
                  subject that this observer is going away.</para>
                </callout>
              </calloutlist>
            </example>

            <para>This example demonstrates that observers do not have to be
            complex to be usable. While this example is purposely simple, it
            should illustrate that developers of observers do not necessarily
            have to make their implementations complicated. As will be shown
            in <xref linkend="slider.subject.bean.section" />, the JavaBean
            that uses this observer completes the picture and provides users
            with a GUI slider that can be manipulated by any number of
            simultaneous users.</para>
          </section>
        </section>

        <section id="SliderSubject.server.section">
          <title lang="SliderSubject.server.section">The Server Application</title>

          <para>Now that we have the subject and observer ready to go, we can
          make an application that uses them. The following example is a
          (relatively) simple C++ application that starts the CORBA Manager<indexterm><primary>CORBA
          Manager</primary><secondary>initialization</secondary><tertiary>example
          of</tertiary></indexterm>, creates the Subject Manager<indexterm><primary>Subject
          Manager</primary><secondary>creation</secondary><tertiary>example of</tertiary></indexterm>,
          registers a <interfacename>networktest::SliderSubject</interfacename>
          servant, and then waits for the user to press &#39;<literal>x</literal>&#39;
          to exit. The use of exceptions may appear unfamiliar to some C++
          programmers. CORBA makes use of exceptions as a cross-language
          mechanism to report errors, and thus, there must be proper exception
          handling code for the application to work correctly.</para>

          <example id="SliderSubjectApp.cpp.example">
            <title>SliderSubjectApp.cpp</title>

            <programlisting linenumbering="numbered">#include &#60;tweek/CORBA/CorbaManager.h&#62;                                        <co
id="SliderSubjectApp.cpp.includes.tweek"
linkends="SliderSubjectApp.cpp.includes.co" />
#include &#60;vpr/Thread/Thread.h&#62;
#include &#60;vpr/Util/Debug.h&#62;

#include &#60;SliderSubjectImpl.h&#62;                                               <co
id="SliderSubjectApp.cpp.includes.gen"
linkends="SliderSubjectApp.cpp.includes.co" />

/**
 * This application starts the CORBA server for the C++ side of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;                                                  <co
id="SliderSubjectApp.cpp.corbamgr.decl"
linkends="SliderSubjectApp.cpp.corbamgr.co" />

   // The first thing we have to do is initialize the Tweek CORBA Manager.
   // If this fails, we&#39;re out of luck.
   try
   {
      if ( mgr.init(&#34;corba_test&#34;, argc, argv).success() )                    <co
id="SliderSubjectApp.cpp.corbamgr.init"
linkends="SliderSubjectApp.cpp.corbamgr.co" />
      {
         vpr::ReturnStatus status;

         // Once the CORBA Manager is initialized, we need to create a
         // Subject Manager.  This will hold our SliderSubject object.
         try
         {
            status = mgr.createSubjectManager();                             <co
id="SliderSubjectApp.cpp.subjectmgr.create"
linkends="SliderSubjectApp.cpp.subjectmgr.create.co" />

            // If we were able to create the Subject Manager, now we register
            // our objects with it.
            if ( status.success() )
            {
               // First, create real instances of the C++ object that will
               // be the CORBA servant.  This must be allocated on the heap.
               networktest::SliderSubjectImpl* slider_subj =
                  new networktest::SliderSubjectImpl();                      <co
id="SliderSubjectApp.cpp.subject.create"
linkends="SliderSubjectApp.cpp.subject.create.co" />

               // Now we try to register the subject and give it a symbolic,
               // easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&#62;registerSubject(slider_subj,
                                                           &#34;SliderSubject&#34;); <co
id="SliderSubjectApp.cpp.subject.register"
linkends="SliderSubjectApp.cpp.subject.register.co" />
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &#60;&#60; &#34;Failed to register subject\n&#34; &#60;&#60; vprDEBUG_FLUSH;
               }
            }
         }
         catch (CORBA::Exception&#38; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &#60;&#60; &#34;Caught an unknown CORBA exception when trying to register!\n&#34;
               &#60;&#60; vprDEBUG_FLUSH;
         }

         if ( ! status.success() )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &#60;&#60; &#34;Failed to register Subject Manager instance\n&#34;
               &#60;&#60; vprDEBUG_FLUSH;
         }

         std::cout &#60;&#60; &#34;Press &#39;x&#39; to exit&#34; &#60;&#60; std::endl;
         char input;

         // Loop forever so that we can act sort of like a server.
         while ( 1 )                                                         <co
id="SliderSubjectApp.cpp.loop" linkends="SliderSubjectApp.cpp.loop.co" />
         {
            std::cin &#62;&#62; input;
            if ( input == &#39;x&#39; )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &#60;&#60; &#34;CORBA failed to initialize\n&#34; &#60;&#60; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &#60;&#60; &#34;Caught an unknown exception!\n&#34; &#60;&#60; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL) &#60;&#60; &#34;Exiting\n&#34; &#60;&#60; vprDEBUG_FLUSH;

   return 0;
}</programlisting>

            <calloutlist>
              <callout
              arearefs="SliderSubjectApp.cpp.includes.tweek SliderSubjectApp.cpp.includes.gen"
              id="SliderSubjectApp.cpp.includes.co">
                <para>These two headers are typically needed. The first
                includes the declaration of the Tweek CORBA Manager, and the
                second is the subject implementation declaration, shown in
                <xref linkend="SliderSubjectImpl.h.example" />.</para>
              </callout>

              <callout
              arearefs="SliderSubjectApp.cpp.corbamgr.decl SliderSubjectApp.cpp.corbamgr.init"
              id="SliderSubjectApp.cpp.corbamgr.co">
                <para>In order to use CORBA through Tweek, the CORBA Manager
                must be created and initialized. Any number of these may be
                created, but in general, only one is needed per application</para>
              </callout>

              <callout arearefs="SliderSubjectApp.cpp.subjectmgr.create"
              id="SliderSubjectApp.cpp.subjectmgr.create.co">
                <para>After the COBRA Manager has been initialized
                successfully, the Tweek Subject Manager must be created.</para>
              </callout>

              <callout arearefs="SliderSubjectApp.cpp.subject.create"
              id="SliderSubjectApp.cpp.subject.create.co">
                <para>Once we have a valid Subject Manager, we must register
                subjects with it in order for object references to be passed
                out by CORBA. This creates the <glossterm
                linkend="gloss.servant">servant</glossterm> to which
                <interfacename>networktest::SliderSubject</interfacename>
                references will be made.</para>
              </callout>

              <callout arearefs="SliderSubjectApp.cpp.subject.register"
              id="SliderSubjectApp.cpp.subject.register.co">
                <para>Once the servant is created, it is registered with the
                Subject Manager. The Subject Manager will activate the servant
                within the POA so that references to it can be created and
                returned to clients.</para>
              </callout>

              <callout arearefs="SliderSubjectApp.cpp.loop"
              id="SliderSubjectApp.cpp.loop.co">
                <para>After the subject is registered, all the work is done.
                This application now just waits for clients to request
                references. It will exit when the user enters &#39;<literal>x</literal>&#39;.</para>
              </callout>
            </calloutlist>
          </example>

          <para>The application shown in <xref
          linkend="SliderSubjectApp.cpp.example" /> is purposely simple. There
          are many ways to use the CORBA Manager and the Subject Manager. For
          example, an object registry could be built on top of the Subject
          Manager so that only specific types of servant objects may be
          registered. Servant registration could be automated in object
          constructors. The C++ API is intended to be simple to enhance its
          usability and flexibility, and the application shown in the example
          is just that: an example.</para>
        </section>

        <section id="slider.subject.bean.section">
          <title>The JavaBean</title>

          <para>We have finally reached the point at which we implement a
          JavaBean that can visualize the numeric data held by the C++ slider
          subject. Such a JavaBean must be defined as a Tweek Panel Bean.
          (Refer back to <xref linkend="intro.javabeans.chapter" /> if these
          statements seem unfamiliar or confusing.)</para>

          <para>The JavaBean shown in the following example is typical of one
          that uses the Tweek Network library to take advantage of CORBA
          facilities. The code for the Bean is longer than previous examples,
          and because of this, it will be split into multiple code blocks.
          Each will be discussed in turn. The full code is in one file:
          <filename>NetworkTest.java</filename>.</para>

          <para>Please note that the details of setting up the GUI elements
          used by the Bean are left out. The code in this case was generated
          by JBuilder and could easily vary from Bean to Bean. For the full
          code, please refer to the aforementioned locations.</para>

          <section>
            <title>Imports</title>

            <para>The slider JavaBean uses common Java Swing classes, a CORBA
            exception class, the Tweek Event library, the Tweek Network
            library, and the Java code generated by an IDL compiler. The
            following explains how each of these are imported into the main
            Bean class.</para>

            <programlisting>package networktest;                                       <co
id="NetworkTest.java.package" linkends="NetworkTest.java.package.co" />

import java.awt.*;                                         <co
id="NetworkTest.java.imports.gui.awt"
linkends="NetworkTest.java.imports.gui.co" />
import javax.swing.*;                                      <co
id="NetworkTest.java.imports.gui.swing"
linkends="NetworkTest.java.imports.gui.co" />
import javax.swing.event.*;                                <co
id="NetworkTest.java.imports.gui.swing.event"
linkends="NetworkTest.java.imports.gui.co" />
import org.omg.CORBA.BAD_PARAM;                            <co
id="NetworkTest.java.imports.corba"
linkends="NetworkTest.java.imports.corba.co" />
import org.vrjuggler.tweek.event.*;                        <co
id="NetworkTest.java.imports.tweek.event"
linkends="NetworkTest.java.imports.tweek.co" />
import org.vrjuggler.tweek.net.*;                          <co
id="NetworkTest.java.imports.tweek.net"
linkends="NetworkTest.java.imports.tweek.co" />
import org.vrjuggler.tweek.net.corba.*;                    <co
id="NetworkTest.java.imports.tweek.net.corba"
linkends="NetworkTest.java.imports.tweek.co" />
import tweek.*;                                            <co
id="NetworkTest.java.imports.tweek-gen"
linkends="NetworkTest.java.imports.tweek-gen.co" />
</programlisting>

            <calloutlist>
              <callout arearefs="NetworkTest.java.package"
              id="NetworkTest.java.package.co">
                <para>This Bean is in a package corresponding to the IDL
                module defined in <filename>SliderSubject.idl</filename>.
                Using a consistent name throughout makes the code easier to
                manage and understand.</para>
              </callout>

              <callout
              arearefs="NetworkTest.java.imports.gui.awt NetworkTest.java.imports.gui.swing NetworkTest.java.imports.gui.swing.event"
              id="NetworkTest.java.imports.gui.co">
                <para>These imports bring in common Swing and AWT GUI classes.
                Different Beans will use different classes and packages.</para>
              </callout>

              <callout arearefs="NetworkTest.java.imports.corba"
              id="NetworkTest.java.imports.corba.co">
                <para>In order to do proper narrowing of reference types, the
                exception <exceptionname>org.omg.CORBA.BAD_PARAM</exceptionname>
                must be caught.</para>
              </callout>

              <callout
              arearefs="NetworkTest.java.imports.tweek.event NetworkTest.java.imports.tweek.net NetworkTest.java.imports.tweek.net.corba"
              id="NetworkTest.java.imports.tweek.co">
                <para>These imports bring in the classes of the Tweek Event
                and Network libraries.</para>
              </callout>

              <callout arearefs="NetworkTest.java.imports.tweek-gen"
              id="NetworkTest.java.imports.tweek-gen.co">
                <para>Tweek Java code generated by an IDL compiler will always
                be in the package <classname>tweek</classname>. This
                corresponds to the IDL module and to the C++ namespace.</para>
              </callout>
            </calloutlist>
          </section>

          <section>
            <title>Class Declaration</title>

            <para>Now we can begin writing the Bean code. Besides the class
            <classname>SliderObserverImpl</classname>, this Bean has only one
            class: <classname>NetworkTest</classname>. It will provide the GUI
            representation of the numeric data. The declaration of the class
            follows.</para>

            <programlisting>/**
 * This is an example of a JavaBean that Tweek can load dynamically.  It holds
 * a JSlider that acts as an Observer in the Tweek CORBA Subject/Observer
 * pattern implementation.
 *
 * @version 1.0
 */
public class NetworkTest
   extends JPanel                                          <co
id="NetworkTest.java.superclass" linkends="NetworkTest.java.superclass.co" />
   implements CommunicationListener, TweekFrameListener    <co
id="NetworkTest.java.interfaces" linkends="NetworkTest.java.interfaces.co" />
{
...
}</programlisting>

            <calloutlist>
              <callout arearefs="NetworkTest.java.superclass"
              id="NetworkTest.java.superclass.co">
                <para>As a Tweek Panel Bean, there must be a class that
                derives from <classname>javax.swing.JComponent</classname> or
                some subclass thereof. In this case, the superclass is
                <classname>javax.swing.JPanel</classname>.</para>
              </callout>

              <callout arearefs="NetworkTest.java.interfaces"
              id="NetworkTest.java.interfaces.co">
                <para>Since this Bean needs to access the remote Subject
                Manager, it needs to know when a CORBA service is available.
                By implementing <interfacename>org.vrjuggler.tweek.net.CommunicationListener</interfacename>,
                the Bean will be informed by the Tweek Java GUI whenever the
                communication state with a CORBA service changes. This Bean
                also listens for <classname>TweekFrameEvents</classname> so
                that it can shut itself down cleanly. To be informed of such
                events, it must implement <interfacename>org.vrjuggler.tweek.event.TweekFrameListener</interfacename>.</para>
              </callout>
            </calloutlist>
          </section>

          <section>
            <title>Member Variables</title>

            <para>Before delving into the methods of the
            <classname>networktest.NetworkTest</classname> class, it will be
            helpful to review the member variables used throughout the class.
            Refer back to this section if there is any confusion regarding the
            use or the type of some member variable in the method
            implementations.</para>

            <programlisting>private BorderLayout mBeanLayout = new BorderLayout();     <co
id="NetworkTest.java.members.layout"
linkends="NetworkTest.java.members.layout.co" />

private JPanel mSliderPanel = new JPanel();                <co
id="NetworkTest.java.members.slider-group.panel"
linkends="NetworkTest.java.members.slider-group.co" />
private JSlider mDataSlider = new JSlider();               <co
id="NetworkTest.java.members.slider-group.slider"
linkends="NetworkTest.java.members.slider-group.co" />

private SliderObserverImpl mSliderObserver = null;         <co
id="NetworkTest.java.members.observer"
linkends="NetworkTest.java.members.observer.co" />
</programlisting>

            <calloutlist>
              <callout arearefs="NetworkTest.java.members.layout"
              id="NetworkTest.java.members.layout.co">
                <para>This is the containing layout for the entire Bean.</para>
              </callout>

              <callout
              arearefs="NetworkTest.java.members.slider-group.panel NetworkTest.java.members.slider-group.slider"
              id="NetworkTest.java.members.slider-group.co">
                <para>The <classname>JSlider</classname> used for visually
                representing the subject&#39;s numeric data is
                <varname>mDataSlider</varname>, and it will be contained
                within <varname>mSliderPanel</varname>.</para>
              </callout>

              <callout arearefs="NetworkTest.java.members.observer"
              id="NetworkTest.java.members.observer.co">
                <para>The <interfacename>networktest::SliderSubject</interfacename>
                observer will be stored within <varname>mSliderObserver</varname>.</para>
              </callout>
            </calloutlist>

            <para>Note that the observer is stored in a member variable
            initialized to <symbol>null</symbol>. It will be assigned a value
            when a CORBA service becomes available and the corresponding
            subject can be requested. The object itself is stored as a member
            variable so that it can be accessed by all the methods of the
            class.</para>
          </section>

          <section>
            <title>Handling CORBA Communications</title>

            <para>The most complex part of this Bean is the handling of CORBA
            communication events delivered by the Tweek GUI. All of the
            handling in this example will be done in the methods
            <methodname>connectionOpened()</methodname> and
            <methodname>connectionClosed()</methodname>. The steps that must
            be followed are straightforward, but there are errors that must be
            handled properly. It is the error handling that can make the code
            look daunting, not the use of the Tweek Network library.</para>

            <programlisting linenumbering="numbered">/**
 * Implements the Tweek CommunicationListener interface needed for being
 * informed of new connections with remote ORBs.
 */
public void connectionOpened(CommunicationEvent e)                        <co
id="NetworkTest.java.connect" linkends="NetworkTest.java.connect.co" />
{
   // The first thing to do is get the CORBA service object from the
   // event.  We need this so we know to whom we are are connecting.  Once
   // we have the CORBA service, we get its Subject Manager since that&#39;s
   // what contains the actual subjects we need.
   CorbaService corba_service = e.getCorbaService();                      <co
id="NetworkTest.java.corba.service" linkends="NetworkTest.java.corba.co" />
   SubjectManager mgr         = corba_service.getSubjectManager();        <co
id="NetworkTest.java.corba.subjectmgr" linkends="NetworkTest.java.corba.co" />

   Subject subject = mgr.getSubject(&#34;SliderSubject&#34;);                     <co
id="NetworkTest.java.getSubject" linkends="NetworkTest.java.getSubject.co" />
   SliderSubject slider_subject = null;

   // Try to narrow the Subject object to a SliderSubject object.  If this
   // fails, it throws a CORBA BAD_PARAM exception.  In that case, we open
   // a dialog box saying that the narrowing failed.
   try
   {
      slider_subject = SliderSubjectHelper.narrow(subject);               <co
id="NetworkTest.java.narrow-subject" linkends="NetworkTest.java.narrow.co" />
   }
   catch (BAD_PARAM narrow_ex)                                            <co
id="NetworkTest.java.narrow-exception" linkends="NetworkTest.java.narrow.co" />
   {
      JOptionPane.showMessageDialog(null,
                                    &#34;Failed to narrow subject to SliderSubject&#34;,
                                    &#34;SliderSubject Narrow Error&#34;,
                                    JOptionPane.ERROR_MESSAGE);
   }

   // Ensure that slider_subject is a valid object just to be safe.
   if ( slider_subject != null )
   {
      // First, we need a Java object that implements the Observer.  That
      // object must be registered with the Java CORBA service.
      m_slider_observer = new SliderObserverImpl(mDataSlider,
                                                 slider_subject);         <co
id="NetworkTest.java.observer.create"
linkends="NetworkTest.java.observer.create.co" />
      corba_service.registerObject(mSliderObserver, &#34;SliderObserver&#34;);    <co
id="NetworkTest.java.observer.register"
linkends="NetworkTest.java.observer.register.co" />

      // Now that the observer is registered, we can attach it to the
      // subject.  The subject needs to know who its observers are so
      // that it can notify them of updates.
      slider_subject.attach(mSliderObserver._this());                     <co
id="NetworkTest.java.observer.attach"
linkends="NetworkTest.java.observer.attach.co" />

      // Now we set the slider in our GUI to be whatever value the
      // remote subject is holding for us.
      mDataSlider.setValue(slider_subject.getValue());                    <co
id="NetworkTest.java.setValue" linkends="NetworkTest.java.setValue.co" />
      mDataSlider.addChangeListener(
         new SliderChangeListener(slider_subject)
      );                                                                  <co
id="NetworkTest.java.addChangeListener"
linkends="NetworkTest.java.addChangeListener.co" />
   }
}

/**
 * Implements the Tweek CommunicationListener interface needed for being
 * informed when existing ORB connections are closed.
 */
public void connectionClosed(ConnectEvent e)                              <co
id="NetworkTest.java.disconnect" linkends="NetworkTest.java.shutdown.co" />
{
   if ( mSliderObserver != null )
   {
      mSliderObserver.detach();                                           <co
id="NetworkTest.java.observer.detach" linkends="NetworkTest.java.shutdown.co" />
      mSliderObserver = null;
   }
}</programlisting>

            <calloutlist>
              <callout arearefs="NetworkTest.java.connect"
              id="NetworkTest.java.connect.co">
                <para>If the event delivered to the Bean is a newly opened
                connection, there is a new CORBA service available, so we will
                create a new observer to communicate through that service.</para>
              </callout>

              <callout
              arearefs="NetworkTest.java.corba.service NetworkTest.java.corba.subjectmgr"
              id="NetworkTest.java.corba.co">
                <para>The first step that must be taken is retrieving the
                <classname>org.vrjuggler.tweek.net.corba.CorbaService</classname>
                object from the event. This is needed as the basis for all
                further actions. With the CORBA service reference, we can
                request the Subject Manager reference. The result is a CORBA
                reference to the remote Subject Manager, a servant within the
                C++ application.</para>
              </callout>

              <callout arearefs="NetworkTest.java.getSubject"
              id="NetworkTest.java.getSubject.co">
                <para>Through the Subject Manager, we request subjects using
                symbolic names. In this case, we request the subject with the
                hard-coded name <quote>SliderSbuject</quote>.</para>
              </callout>

              <callout
              arearefs="NetworkTest.java.narrow-subject NetworkTest.java.narrow-exception"
              id="NetworkTest.java.narrow.co">
                <para>The call to <methodname>getSubject()</methodname>
                returns a reference of type <interfacename>tweek.Subject</interfacename>,
                but we need to narrow it to <interfacename>networktest.SliderSubject</interfacename>
                so we can use it. Among the code generated by the IDL compiler
                is a class named <classname>networktest.SliderSubjectHelper</classname>.
                Its <methodname>narrow()</methodname> method is used to narrow
                the CORBA reference type to a more specific type. If the
                narrowing fails, an exception of type
                <exceptionname>org.omg.CORBA.BAD_PARAM</exceptionname> is
                thrown, and it is best to handle it here.</para>
              </callout>

              <callout arearefs="NetworkTest.java.observer.create"
              id="NetworkTest.java.observer.create.co">
                <para>Once we have the subject reference, we create an
                observer servant that we will attach to the subject. This is
                where <classname>networktest.SliderObserverImpl</classname>
                comes into the picture.</para>
              </callout>

              <callout arearefs="NetworkTest.java.observer.register"
              id="NetworkTest.java.observer.register.co">
                <para>The observer servant must be registered with the local
                CORBA service so that references to it can be created. This
                single statement takes care of all the POA activation behind
                the scenes.</para>
              </callout>

              <callout arearefs="NetworkTest.java.observer.attach"
              id="NetworkTest.java.observer.attach.co">
                <para>Now that the servant is registered with the CORBA
                service, a reference to it can be passed to the remote subject
                in order to attach the observer to the subject.</para>
              </callout>

              <callout arearefs="NetworkTest.java.setValue"
              id="NetworkTest.java.setValue.co">
                <para>Once the initial references are passed around, we need
                to update the GUI slider to the current value held by the
                subject.</para>
              </callout>

              <callout arearefs="NetworkTest.java.addChangeListener"
              id="NetworkTest.java.addChangeListener.co">
                <para>As part of the collaborative slider, we need to register
                a change listener with the GUI slider so that it will be
                informed of changes made by the local user. These changes are
                reported to the remote subject so that other users get the
                update. The class <classname>SliderChangeListener</classname>
                is shown later.</para>
              </callout>

              <callout
              arearefs="NetworkTest.java.disconnect NetworkTest.java.observer.detach"
              id="NetworkTest.java.shutdown.co">
                <para>If the event delivered to the Bean was the closing of an
                existing connection, the CORBA service is being shut down.
                When the CORBA service is shut down, we need to detach the
                local observer from the remote subject to prevent further
                update notification attempts for this observer.</para>
              </callout>
            </calloutlist>

            <para>It is important to note that the use of hard-coded subject
            names is not recommended. In this example, the subject name is
            hard-coded for simplicity. The Tweek Subject Manager allows
            accessing code to request a list of all registered subjects. Using
            this information, it is possible to present the Java GUI user with
            a list of subjects from which they can make a selection.</para>
          </section>

          <section>
            <title>Handling Frame Events</title>

            <para>This Bean makes an effort to shut down open CORBA
            connections when the Tweek GUI is closed. It does this by
            implementing <interfacename>org.vrjuggler.tweek.event.TweekFrameListener</interfacename>
            which has a single method, <methodname>frameStateChanged()</methodname>.</para>

            <programlisting>public void frameStateChanged(TweekFrameEvent e)
{
   if ( e.getType() == TweekFrameEvent.FRAME_CLOSE )            <co
id="NetworkTest.java.frame.close" linkends="NetworkTest.java.frame.close.co" />
   {
      if ( mSliderObserver != null )
      {
         mSliderObserver.detach();                              <co
id="NetworkTest.java.frame.detach" linkends="NetworkTest.java.frame.detach.co" />
         mSliderObserver = null;
      }
   }
}</programlisting>

            <calloutlist>
              <callout arearefs="NetworkTest.java.frame.close"
              id="NetworkTest.java.frame.close.co">
                <para>If the event is the closing of the Tweek GUI frame, the
                CORBA reference clean-up steps will be taken.</para>
              </callout>

              <callout arearefs="NetworkTest.java.frame.detach"
              id="NetworkTest.java.frame.detach.co">
                <para>If the slider observer is defined, we assume that the
                observer is attached. The handy <methodname>detach()</methodname>
                method is invoked to detach this observer from the remote
                subject.</para>
              </callout>
            </calloutlist>
          </section>

          <section>
            <title>Handling Local Slider Change Events</title>

            <para>A helper class is used to handle local change events in the
            slider. The class is a private inner class within the Bean and is
            defined as follows:</para>

            <programlisting>private class SliderChangeListener implements ChangeListener
{
   public SliderChangeListener(SliderSubject subject)
   {
      mSliderSubject = subject;
   }

   public void stateChanged(javax.swing.event.ChangeEvent e)
   {
      JSlider source = (JSlider) e.getSource();

      if ( ! source.getValueIsAdjusting() )                     <co
id="NetworkTest.java.SliderChangeListener.stateChanged.adjust"
linkends="NetworkTest.java.SliderChangeListener.stateChanged.co" />
      {
         mSliderSubject.setValue(source.getValue());            <co
id="NetworkTest.java.SliderChangeListener.stateChanged.setValue"
linkends="NetworkTest.java.SliderChangeListener.stateChanged.co" />
      }
   }

   private SliderSubject mSliderSubject = null;
}</programlisting>

            <calloutlist>
              <callout
              arearefs="NetworkTest.java.SliderChangeListener.stateChanged.adjust NetworkTest.java.SliderChangeListener.stateChanged.setValue"
              id="NetworkTest.java.SliderChangeListener.stateChanged.co">
                <para>Within the <methodname>stateChanged()</methodname>
                method, we check to see if the user is done adjusting the
                slider. If so, the remote subject is updated so that its
                internal value matches that of the local slider. Other users
                are automatically updated when this happens.</para>
              </callout>
            </calloutlist>
          </section>

          <section>
            <title>XML File</title>

            <para>With the Bean implementation done, the XML file that
            describes the Bean must be written. All Beans loaded by the Tweek
            Java GUI are described by an XML file. In <xref
            linkend="NetworkTestBean.xml.example" />, we show the XML file for
            the Bean we have been developing.</para>

            <example id="NetworkTestBean.xml.example">
              <title>NetworkTestBean.xml</title>

              <programlisting>&#60;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&#62;                               <co
id="NetworkTestBean.xml.version" linkends="NetworkTestBean.xml.version.co" />
&#60;beanlist xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;      <co
id="NetworkTestBean.xml.beanlist" linkends="NetworkTestBean.xml.beanlist.co" />
          xsi:noNamespaceSchemaLocation=&#34;http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd&#34;&#62;
  &#60;guipanel name=&#34;Network Tester&#34;&#62;                                   <co
id="NetworkTestBean.xml.guipanel" linkends="NetworkTestBean.xml.guipanel.co" />
    &#60;file name=&#34;${TWEEK_BASE_DIR}/bin/beans/NetworkTestBean.jar&#34;     <co
id="NetworkTestBean.xml.file" linkends="NetworkTestBean.xml.file.co" />
          class=&#34;networktest.NetworkTest&#34; /&#62;
    &#60;tree path=&#34;/Beans&#34; /&#62;                                           <co
id="NetworkTestBean.xml.tree" linkends="NetworkTestBean.xml.tree.co" />
  &#60;/guipanel&#62;
&#60;/beanlist&#62;</programlisting>

              <calloutlist>
                <callout arearefs="NetworkTestBean.xml.version"
                id="NetworkTestBean.xml.version.co">
                  <para>Well-formed XML requires this line.</para>
                </callout>

                <callout arearefs="NetworkTestBean.xml.beanlist"
                id="NetworkTestBean.xml.beanlist.co">
                  <para>Tweek XML Bean files are <sgmltag>beanlist</sgmltag>
                  documents. There must be exactly one <sgmltag>beanlist</sgmltag>
                  per file, but the list itself can contain multiple Beans. In
                  this element, we also provide the information needed to
                  validate this document using the XML Schema
                  <filename>beanlist.xsd</filename>. In this case, we use the
                  schema that does not employ XML namespaces. Use of the
                  schema for validation is optional, but it is recommended.</para>
                </callout>

                <callout arearefs="NetworkTestBean.xml.guipanel"
                id="NetworkTestBean.xml.guipanel.co">
                  <para>The Bean we have been developing is a GUI Panel Bean,
                  and this indicates that fact.</para>
                </callout>

                <callout arearefs="NetworkTestBean.xml.file"
                id="NetworkTestBean.xml.file.co">
                  <para>To find the Bean, a path must be specified. In this
                  example, we will put the XML and JAR files in
                  <filename>$TWEEK_BASE_DIR/bin/beans</filename>. Note the use
                  of curly braces around the environment variable. This is
                  required. The class attribute names the class that will be
                  instantiated, and in this case, that is
                  <filename>networktest.NetworkTest</filename>. This name
                  corresponds more to the fully qualified name of the class
                  stored within the JAR file.</para>
                </callout>

                <callout arearefs="NetworkTestBean.xml.tree"
                id="NetworkTestBean.xml.tree.co">
                  <para>Panel Beans are loaded into a tree data structure and
                  visualized using a viewer. This specifies the path within
                  the tree using a UNIX-style path. The path is arbitrary and
                  will be constructed as needed when the Bean is loaded.</para>
                </callout>
              </calloutlist>
            </example>

            <para>After the Bean is compiled into a JAR file, the JAR file and
            XML file need to be copied into <filename>$TWEEK_BASE_DIR/bin/beans</filename>.
            This is the default path that Tweek searches for Beans at startup,
            and it is a convenient place to put this example Bean.</para>
          </section>
        </section>

        <section>
          <title>Running the Example</title>

          <para>With all the coding done and the code compiled, we can run the
          C++ application and connect multiple instances of the Tweek Java GUI
          to it. The steps to run the C++ application are as follows:</para>

          <orderedlist>
            <listitem>
              <para>Run a CORBA Naming Service. This is required so that the
              C++ and Java ORBs can resolve symbolic references.</para>
            </listitem>

            <listitem>
              <para>Since Tweek uses omniORB for a C++ ORB (see <xref
              linkend="orb-impl.appendix" /> for more information on this),
              the environment variable <envar>$OMNIORB_CONFIG</envar> must be
              set. This gives the full path to an omniORB configuration file
              that omniORB will load at runtime.</para>
            </listitem>

            <listitem>
              <para>Run the C++ application.</para>
            </listitem>

            <listitem>
              <para>Run the Tweek Java GUI. This will find and load all the
              Beans in <filename>$TWEEK_BASE_DIR/bin/beans</filename>.</para>
            </listitem>

            <listitem>
              <para>Within the Java GUI, connect to the CORBA Naming Service
              started in step 1. The way the Bean is written, it will request
              the subject held by the C++ application automatically, and the
              slider will be updated to the current value.</para>
            </listitem>
          </orderedlist>
        </section>
      </section>

      <section id="file.loader.section">
        <title>File Loader</title>

        <para>Not everything written in Tweek must use Java, C++, IDL, and
        CORBA. The Tweek Java GUI is a generalized Bean-loading environment,
        and as such, its main focus is to load JavaBeans and present them to
        the user. Those Beans may take advantage of CORBA, but they are not
        required to do so. In this section, we show another sample Bean that
        is much simpler than the previous example.</para>

        <para>The Bean shown in this example can open and close multiple text
        files. To do this, the Bean implements the interface
        <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>.
        The Java code will be shown in separate pieces to make it easier to
        understand. The full code is in <filename>$TWEEK_BASE_DIR/share/test/FileOpenTestBean/fileopentestbean/FileOpenTestBean.java</filename>.
        An example makefile can be found in <xref
        linkend="FileLoader.makefile.section" />. within <xref
        linkend="makefile.appendix" />..</para>

        <section>
          <title>The JavaBean</title>

          <para>As in the previous example, we focus on the imported classes
          first. They are as follows:</para>

          <programlisting>package fileopentestbean;                                       <co
id="FileOpenTestBean.java.package" linkends="FileOpenTestBean.java.package.co" />

import java.awt.*;                                              <co
id="FileOpenTestBean.java.import.awt"
linkends="FileOpenTestBean.java.std-imports.co" />
import java.io.File;                                            <co
id="FileOpenTestBean.java.import.io-File"
linkends="FileOpenTestBean.java.std-imports.co" />
import java.io.FileInputStream;                                 <co
id="FileOpenTestBean.java.import.io-FileInputStream"
linkends="FileOpenTestBean.java.std-imports.co" />
import javax.swing.*;                                           <co
id="FileOpenTestBean.java.import.swing"
linkends="FileOpenTestBean.java.std-imports.co" />
import org.vrjuggler.tweek.services.ExtensionFileFilter;        <co
id="FileOpenTestBean.java.import.ext-filter"
linkends="FileOpenTestBean.java.import.ext-filter.co" />
import org.vrjuggler.tweek.beans.FileLoader;                    <co
id="FileOpenTestBean.java.import.FileLoader"
linkends="FileOpenTestBean.java.import.FileLoader.co" />
</programlisting>

          <calloutlist>
            <callout arearefs="FileOpenTestBean.java.package"
            id="FileOpenTestBean.java.package.co">
              <para>This Bean will be in the package <literal>fileopentestbean</literal>.</para>
            </callout>

            <callout
            arearefs="FileOpenTestBean.java.import.awt FileOpenTestBean.java.import.io-File FileOpenTestBean.java.import.io-FileInputStream FileOpenTestBean.java.import.swing"
            id="FileOpenTestBean.java.std-imports.co">
              <para>These are the imports of standard Java classes. In this
              Bean, we need two Java file I/O classes so that we may load
              files.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.import.ext-filter"
            id="FileOpenTestBean.java.import.ext-filter.co">
              <para>This line imports the Tweek Service Bean known as the
              <classname>ExtensionFileFilter</classname>. This provides a
              simplified mechanism for making file filters typically used with
              <classname>JFileChooser</classname> instances.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.import.FileLoader"
            id="FileOpenTestBean.java.import.FileLoader.co">
              <para>This line imports the interface from the Tweek Bean
              library that we will implement.</para>
            </callout>
          </calloutlist>

          <para>Next, we show the class declaration and the member variables.</para>

          <programlisting>public class FileOpenTestBean extends JPanel                              <co
id="FileOpenTestBean.java.superclass"
linkends="FileOpenTestBean.java.superclass.co" />
                              implements java.io.Serializable, FileLoader <co
id="FileOpenTestBean.java.interfaces"
linkends="FileOpenTestBean.java.interfaces.co" />
{
   // Methods ...

   private int openFileCount = 0;                                         <co
id="FileOpenTestBean.java.openFileCount"
linkends="FileOpenTestBean.java.openFileCount.co" />

   private BorderLayout mMainLayout    = new BorderLayout();
   private JLabel       mBeanTitle     = new JLabel();
   private JTabbedPane  mTextContainer = new JTabbedPane();               <co
id="FileOpenTestBean.java.mTextContainer"
linkends="FileOpenTestBean.java.mTextContainer.co" />
}</programlisting>

          <calloutlist>
            <callout arearefs="FileOpenTestBean.java.superclass"
            id="FileOpenTestBean.java.superclass.co">
              <para>As the primary class for a Panel Bean, this class must
              from <classname>javax.swing.JComponent</classname> or some
              subclass thereof. In this case, the class will be
              <classname>javax.swing.JPanel</classname>.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.interfaces"
            id="FileOpenTestBean.java.interfaces.co">
              <para>JavaBeans are expected to implement
              <interfacename>java.io.Serializable</interfacename>, and this
              class does that. The more interesting interface for this example
              is <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>.
              By implementing this interface, the Tweek Java GUI will know
              that this Bean can manage files.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.openFileCount"
            id="FileOpenTestBean.java.openFileCount.co">
              <para>This is a property of the class that keeps track of the
              number of currently open files.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.mTextContainer"
            id="FileOpenTestBean.java.mTextContainer.co">
              <para>This Bean is capable of opening multiple files, and it
              will manage them with a <classname>JTabbedPane</classname>.</para>
            </callout>
          </calloutlist>

          <para>Now that we have the basics for the class, we can start
          implementing the <interfacename>FileLoader</interfacename>
          interface. Of the methods that must be implemented, the most complex
          is <methodname>openRequested()</methodname>. It will be shown last
          because of its length. We will begin instead with the simplest
          methods.</para>

          <programlisting linenumbering="numbered">public String getFileType()
{
   return &#34;Text&#34;;                                                    <co
id="FileOpenTestBean.java.getFileType"
linkends="FileOpenTestBean.java.getFileType.co" />
}

public boolean canOpenMultiple()
{
   return true;                                                      <co
id="FileOpenTestBean.java.canOpenMultiple"
linkends="FileOpenTestBean.java.canOpenMultiple.co" />
}

public boolean canSave()
{
   return false;                                                     <co
id="FileOpenTestBean.java.canSave" linkends="FileOpenTestBean.java.canSave.co" />
}

public boolean saveRequested()
{
   return false;                                                     <co
id="FileOpenTestBean.java.saveRequested"
linkends="FileOpenTestBean.java.saveRequested.co" />
}

public boolean closeRequested()
{
   mTextContainer.remove(mTextContainer.getSelectedComponent());     <co
id="FileOpenTestBean.java.closeRequested"
linkends="FileOpenTestBean.java.closeRequested.co" />
   openFileCount--;
   return true;
}

public int getOpenFileCount ()
{
   return openFileCount;                                             <co
id="FileOpenTestBean.java.getOpenFileCount"
linkends="FileOpenTestBean.java.getOpenFileCount.co" />
}</programlisting>

          <calloutlist>
            <callout arearefs="FileOpenTestBean.java.getFileType"
            id="FileOpenTestBean.java.getFileType.co">
              <para>This returns the type of file (or files) that can be
              loaded by the Bean. In this case, we are just loading plain text
              files.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.canOpenMultiple"
            id="FileOpenTestBean.java.canOpenMultiple.co">
              <para>This method is used to determine if the Bean can open
              multiple files at one time. This Bean can because of its tabbed
              pane.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.canSave"
            id="FileOpenTestBean.java.canSave.co">
              <para>This method is used to determine if the Bean can save
              files, and this Bean does not.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.saveRequested"
            id="FileOpenTestBean.java.saveRequested.co">
              <para>Because this Bean does not save files, it simply returns
              <constant>false</constant> if a save is requested.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.closeRequested"
            id="FileOpenTestBean.java.closeRequested.co">
              <para>When a close is requested, the currently selected tab is
              removed and the open file count is decremented.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.getOpenFileCount"
            id="FileOpenTestBean.java.getOpenFileCount.co">
              <para>This simply returns the number of currently open files.</para>
            </callout>
          </calloutlist>

          <para>The above are all the methods of the
          <interfacename>FileLoader</interfacename> interface except
          <methodname>openRequested()</methodname>. We are now ready to move
          on to it.</para>

          <programlisting linenumbering="numbered">public boolean openRequested()
{
   // Initialize this to false since a lot of things can go wrong in the
   // process of opening files.  Once the file is opened and read
   // successfully, this can be changed to true.
   boolean opened = false;

   JFileChooser chooser = new JFileChooser();                             <co
id="FileOpenTestBean.java.openRequested.chooser"
linkends="FileOpenTestBean.java.openRequested.chooser.co" />
   chooser.setMultiSelectionEnabled(false);
   chooser.setDialogTitle(&#34;Text File Loader&#34;);
   chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);

   // Only load .txt files.
   ExtensionFileFilter filter = new ExtensionFileFilter(&#34;Text Files&#34;);    <co
id="FileOpenTestBean.java.openRequested.filter"
linkends="FileOpenTestBean.java.openRequested.filter.co" />
   filter.addExtension(&#34;txt&#34;);
   chooser.addChoosableFileFilter(filter);

   int status = chooser.showOpenDialog(this);                             <co
id="FileOpenTestBean.java.openRequested.show-chooser"
linkends="FileOpenTestBean.java.openRequested.show-chooser.co" />

   if ( status == JFileChooser.APPROVE_OPTION )
   {
      File file = chooser.getSelectedFile();

      if ( file.canRead() )                                               <co
id="FileOpenTestBean.java.openRequested.canRead"
linkends="FileOpenTestBean.java.openRequested.read.co" />
      {
         try
         {
            // Read the contents of the file into a byte[] object.
            FileInputStream input_file = new FileInputStream(file);
            byte[] file_data = new byte[(int) file.length()];
            input_file.read(file_data);                                   <co
id="FileOpenTestBean.java.openRequested.do-read"
linkends="FileOpenTestBean.java.openRequested.read.co" />

            // Create a text area to hold the contents of the file.
            JTextArea text_area = new JTextArea();                        <co
id="FileOpenTestBean.java.openRequested.text-area"
linkends="FileOpenTestBean.java.openRequested.text-area.co" />
            text_area.setEditable(false);
            text_area.insert(new String(file_data), 0);

            // Create a scroll pane to hold the text area; add it to the
            // tabbed pane with all the other previously loaded scroll
            // panes; and make the new scroll pane the selected component.
            JScrollPane text_comp = new JScrollPane(text_area);           <co
id="FileOpenTestBean.java.openRequested.scroll-pane"
linkends="FileOpenTestBean.java.openRequested.scroll-pane.co" />
            mTextContainer.add(text_comp, file.getName());
            mTextContainer.setSelectedComponent(text_comp);

            // Our work is done.
            openFileCount++;                                              <co
id="FileOpenTestBean.java.openRequested.open-inc"
linkends="FileOpenTestBean.java.openRequested.open-inc.co" />
            opened = true;
         }
         catch (java.io.FileNotFoundException ex)
         {
            JOptionPane.showMessageDialog(null, &#34;Cannot find &#39;&#34; +
                                          file.getAbsolutePath() + &#34;&#39;&#34;,
                                          &#34;Read Error&#34;,
                                          JOptionPane.ERROR_MESSAGE);
         }
         catch (java.io.IOException ex)
         {
            JOptionPane.showMessageDialog(null, &#34;Error reading from &#39;&#34; +
                                          file.getAbsolutePath() + &#34;&#39;:&#34; +
                                          ex.getMessage(), &#34;Read Error&#34;,
                                          JOptionPane.ERROR_MESSAGE);
         }
      }
      else
      {
         JOptionPane.showMessageDialog(null, &#34;Cannot read from file &#39;&#34; +
                                       file.getAbsolutePath() + &#34;&#39;&#34;,
                                       &#34;Read Error&#34;,
                                       JOptionPane.ERROR_MESSAGE);
      }
   }

   return opened;
}</programlisting>

          <calloutlist>
            <callout arearefs="FileOpenTestBean.java.openRequested.chooser"
            id="FileOpenTestBean.java.openRequested.chooser.co">
              <para>First, we create a <classname>JFileChooser</classname>
              that will be used to select a text file. It is configured to
              allow selection of only a single file each time.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.openRequested.filter"
            id="FileOpenTestBean.java.openRequested.filter.co">
              <para>Next, we create a filter for <filename>.txt</filename>
              files that will be used by the file chooser.</para>
            </callout>

            <callout
            arearefs="FileOpenTestBean.java.openRequested.show-chooser"
            id="FileOpenTestBean.java.openRequested.show-chooser.co">
              <para>With those steps taken, we now open the chooser and wait
              for the user to select a file.</para>
            </callout>

            <callout
            arearefs="FileOpenTestBean.java.openRequested.canRead FileOpenTestBean.java.openRequested.do-read"
            id="FileOpenTestBean.java.openRequested.read.co">
              <para>If a readable file was chosen, we open it and read its
              contents into an array of <type>byte</type>s.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.openRequested.text-area"
            id="FileOpenTestBean.java.openRequested.text-area.co">
              <para>With the bytes read, we can now put the contents of the
              text file into a read-only <classname>JTexArea</classname>
              object.</para>
            </callout>

            <callout
            arearefs="FileOpenTestBean.java.openRequested.scroll-pane"
            id="FileOpenTestBean.java.openRequested.scroll-pane.co">
              <para>Next, we put the <classname>JTextArea</classname> in a
              <classname>JScrollPane</classname> so that long files can be
              viewed more easily. The scroll pane is added to the tabbed pane
              and made the currently selected panel.</para>
            </callout>

            <callout arearefs="FileOpenTestBean.java.openRequested.open-inc"
            id="FileOpenTestBean.java.openRequested.open-inc.co">
              <para>At this point, we are done, so we increment the number of
              open files and set the return value to <constant>true</constant>
              to indicate that a file was opened successfully.</para>
            </callout>
          </calloutlist>

          <para>This Bean uses no CORBA code and does not require C++ code to
          act as a peer. This may be the case for many Panel Beans written for
          Tweek. Of course, this Bean could be extended to open files that are
          then handed off to C++ code through CORBA.</para>
        </section>

        <section>
          <title>XML File</title>

          <para>The XML file for this Bean is very simple. It simply lists the
          Bean file information and puts the Bean at the root of the Bean
          tree. The full file is shown in <xref
          linkend="FileOpenTestBean.xml.example" />.</para>

          <example id="FileOpenTestBean.xml.example">
            <title>FileOpenTestBean.xml</title>

            <programlisting>&#60;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&#62;
&#60;beanlist xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
          xsi:noNamespaceSchemaLocation=&#34;http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd&#34;&#62;
  &#60;guipanel name=&#34;File Open Test Bean&#34;&#62;
    &#60;file name=&#34;${TWEEK_BASE_DIR}/bin/beans/FileOpenTestBean.jar&#34; 
          class=&#34;fileopentestbean.FileOpenTestBean&#34; /&#62;
    &#60;tree path=&#34;/&#34; /&#62;
  &#60;/guipanel&#62;
&#60;/beanlist&#62;</programlisting>
          </example>
        </section>
      </section>
    </chapter>

    <chapter id="cxx.client.chapter">
      <title>C++ as a Client</title>

      <indexterm>
        <primary>C++ client API</primary>
      </indexterm>

      <para>As of Tweek version 0.13.0, users can write C++ clients in
      addition to Java and Python clients. As of this writing, the interface
      is relatively low-level. The C++ counterpart of the Java class
      <classname>org.vrjuggler.tweek.net.corba.CorbaService</classname><indexterm><primary>org.vrjuggler.tweek.net.CorbaService</primary></indexterm>
      is used to communicate with a remote C++ server. The class is
      <classname>tweek::CorbaService</classname><indexterm><primary>tweek::CorbaService</primary></indexterm>,
      and its API is almost identical to the Java version. The basic idea is
      that users familiar with the Java API can easily make use of the C++
      version and vice versa.</para>

      <para>In this chapter, we explain how to write C++ clients. First, we
      cover the CORBA Service, and then we show how to use it with a C++
      client application. The basic ideas are identical to those used in Java
      clients. The syntax varies slightly due to the differences in the C++
      and Java mappings of IDL. Additionally, we do not need to be concerned
      with JavaBeans because we will be speaking strictly in terms of C++.
      There is nothing to prevent an ambitious user from developing a C++
      counterpart to the Tweek Java GUI, however.</para>

      <section>
        <title>The CORBA Service</title>

        <para></para>
      </section>

      <section>
        <title>Example Client Application</title>

        <para>To understand how to use the C++ client API, we will examine a
        simple application. Similar to the Java/C++ application we reviewed in
        <xref linkend="prog.all.chapter" />, this application makes use of an
        IDL-specified interface, and a C++ server. The key differences, then,
        are that there is no Java code in this case, and we will not need to
        use XML.</para>

        <para>All the code shown here, including a GNU makefile, can be found
        in the directory <filename>$TWEEK_BASE_DIR/share/tweek/test/CxxClient</filename>.
        In the following sections, we will refer to the specific files and
        highlight key sections within them. We assume that readers have
        already read and understood <xref linkend="prog.all.chapter" />. This
        is important because we will refer back to concepts illustrated in
        that chapter. Further, we will not present the server code in this
        chapter because it is nearly identical to the code for the server
        discussed previously. Interested readers can review the file
        <filename>server.cpp</filename>.</para>

        <section id="StringSubject.interface.section">
          <title><interfacename>StringSubject</interfacename> Interface</title>

          <para>As usual, we begin by defining an interface. For this example,
          we will use an interface that provides access to a simple string
          object. The server (Subject) will maintain the value of the string,
          and the clients (Observers) will be able to query and manipulate the
          string. The interface will be called <interfacename>CxxClientTest::StringSubject</interfacename>.
          The code for the interface is shown in <xref
          linkend="StringSubject.idl.example" />.</para>

          <example id="StringSubject.idl.example">
            <title>StringSubject.idl</title>

            <programlisting>#ifndef _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_
#define _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_

#include &#60;tweek/idl/Subject.idl&#62;

module CxxClientTest
{
   interface StringSubject : tweek::Subject   <co
id="StringSubject.interface.decl" linkends="StringSubject.interface.decl.co" />
   {
      void setValue(in string val);           <co id="StringSubject.setValue"
linkends="StringSubject.accessors.co" />
      string getValue();                      <co id="StringSubject.getValue"
linkends="StringSubject.accessors.co" />
   };
};

#endif /* _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_ */</programlisting>

            <calloutlist>
              <callout arearefs="StringSubject.interface.decl"
              id="StringSubject.interface.decl.co">
                <para>As with all user-defined Subjects, we derive our
                interface from <interfacename>tweek::Subject</interfacename>.</para>
              </callout>

              <callout
              arearefs="StringSubject.setValue StringSubject.getValue"
              id="StringSubject.accessors.co">
                <para>These methods define the accessors for the encapsulated
                string value. Clients will invoke these to query and to
                manipulate the state of the remote Subject.</para>
              </callout>
            </calloutlist>
          </example>
        </section>

        <section>
          <title><interfacename>StringSubject</interfacename> Interface
          Implementation</title>

          <para>Now that we have our interface defined abstractly, we must
          provide a C++ implementation of the Subject. This will be done in
          the files <filename>StringSubjectImpl.cpp</filename> and
          <filename>StringSubjectImpl.h</filename>. We begin with the header
          file, shown in <xref linkend="StringSubjectImpl.h.example" />. While
          the example code may appear long, there is only slight variation
          from previous Subject implementation header files. We highlight the
          important bits, of course.</para>

          <example id="StringSubjectImpl.h.example">
            <title>StringSubjectImpl.h</title>

            <programlisting linenumbering="numbered">#ifndef _STRING_SUBJECT_IMPL_H_
#define _STRING_SUBJECT_IMPL_H_

#include &#60;tweek/tweekConfig.h&#62;

#include &#60;string&#62;

#include &#60;vpr/vpr.h&#62;
#include &#60;vpr/Sync/Mutex.h&#62;
#include &#60;tweek/CORBA/SubjectImpl.h&#62;
#include &#60;StringSubject.h&#62;                                               <co
id="StringSubjectImpl.h.include" linkends="StringSubjectImpl.h.include.co" />

namespace CxxClientTest
{

/**
 * This class is an extension to the base Tweek SubjectImpl class.  It uses
 * multiple inheritance with that class and with the generated CORBA class
 * corresponding to the IDL for StringSubject.
 */
class StringSubjectImpl : public POA_CxxClientTest::StringSubject,       <co
id="StringSubjectImpl.h.decl" linkends="StringSubjectImpl.h.decl.co" />
                          public tweek::SubjectImpl
{
public:
   StringSubjectImpl() : tweek::SubjectImpl(), mValue(&#34;&#34;)
   {
      /* Do nothing. */ ;
   }

   virtual ~StringSubjectImpl()
   {
      /* Do nothing. */ ;
   }

   /**
    * Sets this subject&#39;s internal value.
    */
   virtual void setValue(const char* value);                             <co
id="StringSubjectImpl.h.setValue" linkends="StringSubjectImpl.h.virtuals.co" />

   /**
    * Returns this subject&#39;s internal value.
    */
   virtual char* getValue();                                             <co
id="StringSubjectImpl.h.getValue" linkends="StringSubjectImpl.h.virtuals.co" />

   /**
    * This overriding method is needed so that the correct type is returned
    * when the _this() method is invoked.  Without this method, an object of
    * type tweek::Subject_ptr would be returned.
    */
   CxxClientTest::StringSubject_ptr _this()                              <co
id="StringSubjectImpl.h.this" linkends="StringSubjectImpl.h.this.co" />
   {
      return POA_CxxClientTest::StringSubject::_this();
   }

private:
   std::string mValue;      /**&#60; Our value */                            <co
id="StringSubjectImpl.h.mValue" linkends="StringSubjectImpl.h.mValue.co" />
   vpr::Mutex  mValueLock;  /**&#60; A mutex to protect mValue accesses */   <co
id="StringSubjectImpl.h.mutex" linkends="StringSubjectImpl.h.mutex.co" />
};

} // End of CxxClientTest namespace

#endif /* _STRING_SUBJECT_IMPL_H_ */</programlisting>

            <calloutlist>
              <callout arearefs="StringSubjectImpl.h.include"
              id="StringSubjectImpl.h.include.co">
                <para>We must be sure to include the header that defines the
                base class from which we will derive our implementation.
                Remember that this code will be generated by the IDL compiler.</para>
              </callout>

              <callout arearefs="StringSubjectImpl.h.decl"
              id="StringSubjectImpl.h.decl.co">
                <para>As usual, we declare our implementation so that it
                derives from the class generated by the IDL compiler (<classname>POA_CxxClientTest::StringSubject</classname>)
                and from the basic Tweek Subject implementation class (<classname>tweek::SubjectImpl</classname>).</para>
              </callout>

              <callout
              arearefs="StringSubjectImpl.h.setValue StringSubjectImpl.h.getValue"
              id="StringSubjectImpl.h.virtuals.co">
                <para>These are the pure virtual methods defined by
                <classname>POA_CxxClientTest::StringSubject</classname> that
                we must implement. As in previous examples, this is where we
                will do the work of accessing the encapsulated string value.</para>
              </callout>

              <callout arearefs="StringSubjectImpl.h.this"
              id="StringSubjectImpl.h.this.co">
                <para>As with all C++ Subject implementations, we must
                override the method <methodname>_this()</methodname> in order
                to return the correct type. This is critical for proper use of
                the specific Subject type.</para>
              </callout>

              <callout arearefs="StringSubjectImpl.h.mValue"
              id="StringSubjectImpl.h.mValue.co">
                <para>Here we have the string value that will be encapsulated
                within the servant instance. For convenience, we use the
                <classname>std::string</classname> type, though it will
                require careful handling of the <type>char*</type> data that
                CORBA actually passes around.</para>
              </callout>

              <callout arearefs="StringSubjectImpl.h.mutex"
              id="StringSubjectImpl.h.mutex.co">
                <para>In this Subject implementation, we are being more
                paranoid about concurrent accesses to <varname>mValue</varname>,
                so we will protect it with a mutex.</para>
              </callout>
            </calloutlist>
          </example>

          <para>Next, we look at the very simple implementations of
          <methodname>CxxClientTest::StringSubjectImpl::setValue()</methodname>
          and <methodname>CxxClientTest::StringSubjectImpl::getValue()</methodname>.
          These are found in the file <filename>StringSubjectImpl.cpp</filename>,
          and the code is shown in <xref
          linkend="StringSubjectImpl.cpp.example" />. It is important to note
          the use of guards in the method implementations. These provide an
          exception-safe mechanism for controlling access to the data member
          <varname>mValue</varname>. When constructed, the guard locks the
          mutex passed as the argument to the constructor. When the guard goes
          out of scope, the mutex is automatically unlocked.</para>

          <example id="StringSubjectImpl.cpp.example">
            <title>StringSubjectImpl.cpp</title>

            <programlisting linenumbering="numbered">#include &#60;vpr/Sync/Guard.h&#62;
#include &#60;StringSubjectImpl.h&#62;                              <co
id="StringSubjectImpl.cpp.include" linkends="StringSubjectImpl.cpp.include.co" />

namespace CxxClientTest
{

void StringSubjectImpl::setValue(const char* value)
{
   {
      vpr::Guard&#60;vpr::Mutex&#62; val_guard(mValueLock);         <co
id="StringSubjectImpl.cpp.setValue.guard"
linkends="StringSubjectImpl.cpp.setValue.co" />
      mValue = std::string(value);                          <co
id="StringSubjectImpl.cpp.setValue.assign"
linkends="StringSubjectImpl.cpp.setValue.co" />
   }

   // Notify any observers that our value has changed.  This is very
   // important.
   tweek::SubjectImpl::notify();                            <co
id="StringSubjectImpl.cpp.setValue.notify"
linkends="StringSubjectImpl.cpp.notify.co" />
}

char* StringSubjectImpl::getValue()
{
   vpr::Guard&#60;vpr::Mutex&#62; val_guard(mValueLock);            <co
id="StringSubjectImpl.cpp.getValue.guard"
linkends="StringSubjectImpl.cpp.getValue.co" />
   return CORBA::string_dup(mValue.c_str());                <co
id="StringSubjectImpl.cpp.getValue.return"
linkends="StringSubjectImpl.cpp.getValue.co" />
}

} // End CxxClientTest namespace</programlisting>

            <calloutlist>
              <callout arearefs="StringSubjectImpl.cpp.include"
              id="StringSubjectImpl.cpp.include.co">
                <para>As usual, we must include our header file to get the
                necessary declarations.</para>
              </callout>

              <callout
              arearefs="StringSubjectImpl.cpp.setValue.guard StringSubjectImpl.cpp.setValue.assign"
              id="StringSubjectImpl.cpp.setValue.co">
                <para>Within this scoped block, we lock the
                <varname>mValueLock</varname> using a guard and assign a new
                value to <varname>mValue</varname>. Upon exiting this block,
                the guard goes out of scope, and <varname>mValueLock</varname>
                is unlocked.</para>
              </callout>

              <callout arearefs="StringSubjectImpl.cpp.setValue.notify"
              id="StringSubjectImpl.cpp.notify.co">
                <para>As with all cases where we modify the state of the
                Subject, we must notify any Observers who are attached to us.
                Just as the comment notes, this is very important.</para>
              </callout>

              <callout
              arearefs="StringSubjectImpl.cpp.getValue.guard StringSubjectImpl.cpp.getValue.return"
              id="StringSubjectImpl.cpp.getValue.co">
                <para>Here, we return the current value of <varname>mValue</varname>.
                We use a guard again to simplify unlocking the mutex (it
                happens automatically upon return). Note that we make a copy
                of the memory contained in <varname>mValue</varname> using
                <function>CORBA::string_dup()</function>. Making a copy is
                required by CORBA.</para>
              </callout>
            </calloutlist>
          </example>
        </section>

        <section>
          <title id="string.observer.section">Observer Implementation</title>

          <para>With the Subject implemented, we now turn our attention to a
          C++ Observer implementation. Its implementation we will be very
          simple. Its <methodname>update()</methodname> method will query the
          current string value and print it to the console. The goal here is
          to demonstrate how to write a C++ Observer, not how to write an
          <emphasis>interesting</emphasis> Observer.</para>

          <example id="StringObserverImpl.h.example">
            <title>StringObserverImpl.h</title>

            <programlisting linenumbering="numbered">#ifndef _STRING_OBSERVER_IMPL_H_
#define _STRING_OBSERVER_IMPL_H_

#include &#60;tweek/CORBA/Observer.h&#62;                        <co
id="StringObserverImpl.h.Observer.include"
linkends="StringObserverImpl.h.includes.co" />
#include &#60;StringSubject.h&#62;                               <co
id="StringObserverImpl.h.StringSubject.include"
linkends="StringObserverImpl.h.includes.co" />

class StringObserverImpl : public POA_tweek::Observer    <co
id="StringObserverImpl.h.decl" linkends="StringObserverImpl.h.decl.co" />
{
public:
   StringObserverImpl(CxxClientTest::StringSubject_var subject)
      : mSubject(subject)
   {
      /* Do nothing. */ ;
   }

   virtual ~StringObserverImpl()
   {
      /* Do nothing. */ ;
   }

   virtual void update();                                <co
id="StringObserverImpl.h.update" linkends="StringObserverImpl.h.update.co" />

   void detach()
   {
      mSubject-&#62;detach(_this());                         <co
id="StringObserverImpl.h.detach" linkends="StringObserverImpl.h.detach.co" />
   }

private:
   CxxClientTest::StringSubject_var mSubject;            <co
id="StringObserverImpl.h.mSubject" linkends="StringObserverImpl.h.mSubject.co" />
};

#endif /* _STRING_OBSERVER_IMPL_H_ */</programlisting>

            <calloutlist>
              <callout
              arearefs="StringObserverImpl.h.Observer.include StringObserverImpl.h.StringSubject.include"
              id="StringObserverImpl.h.includes.co">
                <para>First, we include the headers we need. The first
                declares the basic <classname>tweek::Observer</classname> C++
                interface. The second includes the <classname>tweek::StringSubject</classname>
                interface. We need this header so that we can hang onto a
                reference to our Subject.</para>
              </callout>

              <callout arearefs="StringObserverImpl.h.decl"
              id="StringObserverImpl.h.decl.co">
                <para>Our Observer implementation derives from the basic Tweek
                Observer class <classname>POA_tweek::Observer</classname>. The
                Java equivalent is <classname>tweek.ObserverPOA</classname>.
                Refer to <xref linkend="SliderObserverImpl.java.example" /> in
                <xref linkend="implement.observer.java.section" /> to see the
                correspondence.</para>
              </callout>

              <callout arearefs="StringObserverImpl.h.update"
              id="StringObserverImpl.h.update.co">
                <para>The <methodname>update()</methodname> method must be
                implemented for all subclasses of <classname>POA_tweek::Observer</classname>.
                Here, we just declare the method; the implementation will be
                shown in <xref linkend="StringObserverImpl.cpp.example" />.</para>
              </callout>

              <callout arearefs="StringObserverImpl.h.detach"
              id="StringObserverImpl.h.detach.co">
                <para>The <methodname>detach()</methodname> method is provided
                as an easy way to detach the Observer from its Subject.
                Ideally, this would be done in the destructor so that the
                detaching process happens automatically when the Observer
                servant is deleted. Doing so leads to incorrect deactivation
                of the servant, however. Instead, we provide this method as a
                way to perform the detachment before servant deactivation or
                deletion occurs.</para>
              </callout>

              <callout arearefs="StringObserverImpl.h.mSubject"
              id="StringObserverImpl.h.mSubject.co">
                <para>Finally, we have a member variable that we will use to
                retain a reference our Subject. This allows the Observer to be
                passed around to functions without passing its Subject
                explicitly. Further, we will see that having a reference to
                the Subject is required for the <methodname>update()</methodname>
                method implementation to work.</para>
              </callout>
            </calloutlist>
          </example>

          <para>Now, we show the implementation of <methodname>StringObserverImpl::update()</methodname>.
          This method is implemented in <filename>StringObserverImpl.cpp</filename>.
          While the method body is very short, we use the
          <filename>.cpp</filename> file to encourage the implementation of
          methods outside of the class declaration.</para>

          <example id="StringObserverImpl.cpp.example">
            <title>StringObserverImpl.cpp</title>

            <programlisting>#include &#60;iostream&#62;
#include &#60;StringObserverImpl.h&#62;                     <co
id="StringObserverImpl.cpp.include"
linkends="StringObserverImpl.cpp.include.co" />

void StringObserverImpl::update()
{
   char* cur_value = mSubject-&#62;getValue();          <co
id="StringObserverImpl.cpp.update.query"
linkends="StringObserverImpl.cpp.update.query.co" />
   std::cout &#60;&#60; &#34;Current string value is now &#39;&#34;     <co
id="StringObserverImpl.cpp.update.print"
linkends="StringObserverImpl.cpp.update.query.co" />
             &#60;&#60; cur_value &#60;&#60; &#34;&#39;&#34; &#60;&#60; std::endl;
   delete cur_value;                                <co
id="StringObserverImpl.cpp.update.delete"
linkends="StringObserverImpl.cpp.update.delete.co" />
}</programlisting>

            <calloutlist>
              <callout arearefs="StringObserverImpl.cpp.include"
              id="StringObserverImpl.cpp.include.co">
                <para>As usual, we have to include our header file to get the
                class declaration information.</para>
              </callout>

              <callout
              arearefs="StringObserverImpl.cpp.update.query StringObserverImpl.cpp.update.print"
              id="StringObserverImpl.cpp.update.query.co">
                <para>Since <methodname>update()</methodname> is only called
                when the state of the Subject changes, we need to query its
                current state. Once we get the current string value back, we
                print it to the console. The value is enclosed in single
                quotes so that any leading or trailing whitespace is displayed
                clearly.</para>
              </callout>

              <callout arearefs="StringObserverImpl.cpp.update.delete"
              id="StringObserverImpl.cpp.update.delete.co">
                <para>Lastly, we delete the memory returned by
                <methodname>CxxClientTest::StringSubject::getValue()</methodname>.
                The burden for freeing this memory is on the client, as per
                standard CORBA operating procedure.</para>
              </callout>
            </calloutlist>
          </example>
        </section>

        <section>
          <title>Client Application</title>

          <para>Finally, we look at the C++ client application. This brings
          everything together and makes use of the <classname>tweek::CorbaService</classname>
          class to contact the remote server. The application shown below is
          more complicated than the server because more work must done. We
          must initialize the local CORBA Service (the local ORB); we must
          pick out the correct Subject Manager reference; and we must get the
          correct <interfacename>CxxClientTest::StringSubject</interfacename>
          reference from the Subject Manager. Once all of those steps are
          completed, we can create an Observer servant (an instance of
          <classname>StringObserverImpl</classname>) and attach it to the
          remote Subject.</para>

          <para>The file containing the complete client application source is
          client.cpp. We will examine it in three parts: the required headers,
          the implementation of <function>main()</function>, and the Subject
          Manager lookup.</para>

          <example>
            <title>client.cpp: Required Header Files</title>

            <programlisting>#include &#60;iostream&#62;
#include &#60;string&#62;

#include &#60;vpr/vpr.h&#62;
#include &#60;vpr/Util/Debug.h&#62;
#include &#60;tweek/Client/CorbaService.h&#62;    <co
id="client.cpp.include.CorbaService"
linkends="client.cpp.include.CorbaService.co" />
#include &#60;tweek/CORBA/SubjectManager.h&#62;   <co
id="client.cpp.include.SubjectManager"
linkends="client.cpp.include.SubjectManager.co" />

#include &#60;StringObserverImpl.h&#62;           <co
id="client.cpp.include.StringObserverImpl"
linkends="client.cpp.include.StringObserverImpl.co" />
</programlisting>

            <calloutlist>
              <callout arearefs="client.cpp.include.CorbaService"
              id="client.cpp.include.CorbaService.co">
                <para>The key to the C++ client interface is the CORBA
                Service. Its declaration is found in <filename>tweek/Client/CorbaService.h</filename>.</para>
              </callout>

              <callout arearefs="client.cpp.include.SubjectManager"
              id="client.cpp.include.SubjectManager.co">
                <para>As in Java clients, the Subject Manager plays a vital
                role in getting references to remote Subjects. Note that the
                file we include here is generated by the IDL compiler and
                provides only the basic interface. We will not be using the
                actual Subject Manager C++ implementation here. That is only
                used on the server side.</para>
              </callout>

              <callout arearefs="client.cpp.include.StringObserverImpl"
              id="client.cpp.include.StringObserverImpl.co">
                <para>Lastly, we include the implementation of our Observer.
                We will be creating an instance of this class to act as the
                servant for an Observer reference. The servant we create will
                be attached to a remote Subject, just as in all Java clients.</para>
              </callout>
            </calloutlist>
          </example>

          <para>Next, we look at the implementation of the application&#39;s
          <function>main()</function> function. This is where the bulk of the
          work is done. Of course, in real-world use, modularizing the code
          would be much better than dumping most of it in
          <function>main()</function>. For the purposes of this example, we
          can get by with having most of the code in <function>main()</function>.</para>

          <para>Note the use of try/catch blocks in the client application
          code. As in the case of server applications (refer to <xref
          linkend="SliderSubject.server.section" />), we are careful about
          handling exceptions properly. Remember that CORBA uses exceptions
          extensively to indicate errors, and thus it is necessary for user
          code to catch them.</para>

          <example id="client.cpp.main.example1">
            <title>client.cpp: Implementation of main(), Part I</title>

            <programlisting linenumbering="numbered">int main(int argc, char* argv[])
{
   std::string ns_host, iiop_ver;
   vpr::Uint16 ns_port;

   std::cout &#60;&#60; &#34;Naming Service host: &#34;;                                  <co
id="client.cpp.main.nshost" linkends="client.cpp.main.naming.info.co" />
   std::cin &#62;&#62; ns_host;

   std::cout &#60;&#60; &#34;Naming Service port (usually 2809): &#34;;                   <co
id="client.cpp.main.nsport" linkends="client.cpp.main.naming.info.co" />
   std::cin &#62;&#62; ns_port;

   std::cout &#60;&#60; &#34;IIOP version (usually 1.0): &#34;;                           <co
id="client.cpp.main.iiopver" linkends="client.cpp.main.naming.info.co" />
   std::cin &#62;&#62; iiop_ver;

   // Create the local CORBA Service using the Naming Service URI information
   // we just collected.
   tweek::CorbaService corba_service(ns_host, ns_port, iiop_ver);         <co
id="client.cpp.main.corba-service.construct"
linkends="client.cpp.main.corba-service.construct.co" />

   try
   {
      // Attempt to initialize the CORBA Service.
      if ( corba_service.init(argc, argv).success() )                     <co
id="client.cpp.main.corba-service.init"
linkends="client.cpp.main.corba-service.init.co" />
      {
         // This will hold the reference to the Subject Manager we use.
         tweek::SubjectManager_var subj_mgr =
            chooseSubjectManager(corba_service);                          <co
id="client.cpp.main.SubjectManager.choose"
linkends="client.cpp.main.SubjectManager.choose.co" />

         // Verify that we actually got a Subject Manager reference back
         // from chooseSubjectManager.
         if ( ! CORBA::is_nil(subj_mgr) )                                 <co
id="client.cpp.main.SubjectManager.verify"
linkends="client.cpp.main.SubjectManager.choose.co" />
         {
            // Request the Subject with which we will communicate.  This
            // hard-coded Subject name is not necessarily a good thing.
            tweek::Subject_var subj =
               subj_mgr-&#62;getSubject(&#34;StringSubject&#34;);                     <co
id="client.cpp.main.subject.request"
linkends="client.cpp.main.subject.request.co" />

            // If the Subject Manager knows about the Subject named above,
            // then we are good to go.
            if ( ! CORBA::is_nil(subj) )                                  <co
id="client.cpp.subject.verify" linkends="client.cpp.main.subject.request.co" />
            {
               ...  // Shown in the next example block
            }
         }
         // We did not get a Subject Manager reference back for some reason.
         else
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &#60;&#60; &#34;No Subject Manager chosen--exiting.\n&#34; &#60;&#60; vprDEBUG_FLUSH;
         }
      }
      // The CORBA Service initialization failed.
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &#60;&#60; &#34;CORBA Service failed to initialize\n&#34; &#60;&#60; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &#60;&#60; &#34;Caught an unknown exception!\n&#34; &#60;&#60; vprDEBUG_FLUSH;
   }

   return 0;
}</programlisting>

            <calloutlist>
              <callout
              arearefs="client.cpp.main.nshost client.cpp.main.nsport client.cpp.main.iiopver"
              id="client.cpp.main.naming.info.co">
                <para>Here, we query input from the user to get Naming Service
                information. We need the host name where the Naming Service is
                running, the port on which it is listening, and the version of
                <glossterm linkend="gloss.iiop">IIOP</glossterm> to use. Using
                the values we get from the user, we can construct an instance
                of <classname>tweek::CorbaService</classname>. Internally, it
                will use the values to create a URI for looking up the Naming
                Service reference.</para>
              </callout>

              <callout arearefs="client.cpp.main.corba-service.construct"
              id="client.cpp.main.corba-service.construct.co">
                <para>Once we have all the necessary initialization pieces, we
                can construct an instance of <classname>tweek::CorbaService</classname>.
                Simply creating an instance of this class does not perform any
                CORBA-related activities. That is the next step.</para>
              </callout>

              <callout arearefs="client.cpp.main.corba-service.init"
              id="client.cpp.main.corba-service.init.co">
                <para>Now we initialize the local CORBA Service. We pass in
                <varname>argc</varname> and <varname>argv</varname> in case
                the user provided any CORBA-specific command-line parameters.
                (Any such parameters will be stripped from <varname>argv</varname>,
                and <varname>argc</varname> will be decremented accordingly.)
                If initialization succeeds, we proceed to requesting the
                Subject Manager reference.</para>
              </callout>

              <callout
              arearefs="client.cpp.main.SubjectManager.choose client.cpp.main.SubjectManager.verify"
              id="client.cpp.main.SubjectManager.choose.co">
                <para>Using the CORBA Service, we choose the Subject Manager
                through which all Subject requests will be handled. The work
                for making this choice is offloaded to the helper function
                <function>chooseSubjectManager()</function>, shown in <xref
                linkend="client.cpp.chooseSubjectManager.example" />. For now,
                we just assume that we got back some reference, possibly nil,
                to a remote <interfacename>tweek::SubjectManager</interfacename>
                object. Since we do not know for sure what the state of things
                is on the server side or what decision the user made, we
                verify that we did not get back a nil reference. If we got
                back a valid Subject Manager reference, we can use it just as
                we would in a Java client to request Subject references by
                name.</para>
              </callout>

              <callout
              arearefs="client.cpp.main.subject.request client.cpp.subject.verify"
              id="client.cpp.main.subject.request.co">
                <para>Next, we request the reference to the remote Subject.
                The symbolic name we use here is the same as that specified in
                the server application (not shown in this chapter). Note that
                using a hard-coded name in this way is not recommended, but we
                use it here for the sake of simplicity. Once we have a
                reference, we verify that it is not nil before trying to use
                it.</para>
              </callout>
            </calloutlist>
          </example>

          <para>We now narrow our attention to the handling of the Subject
          reference that was returned by the Subject Manager. The code shown
          in <xref linkend="client.cpp.main.example2" /> comes from the
          <quote>...</quote> block in <xref linkend="client.cpp.main.example1" />.
          At this point in the application execution, we know that we have a
          non-nil <interfacename>tweek::Subject</interfacename> reference, so
          we need to narrow it to our specific type, create an Observer
          servant, and attach it to the remote Subject.</para>

          <example id="client.cpp.main.example2">
            <title>client.cpp: Implementation of main(), Part II</title>

            <programlisting linenumbering="numbered">StringObserverImpl* string_observer(NULL);
PortableServer::ObjectId_var observer_id;

try
{
   // Attempt to narrow subj to the more specific reference type
   // CxxClientTest::StringSubject_var.  If this fails, an
   // exception will be thrown and caught below.
   CxxClientTest::StringSubject_var string_subj =
      CxxClientTest::StringSubject::_narrow(subj);               <co
id="client.cpp.main.subject.narrow"
linkends="client.cpp.main.subject.narrow.co" />

   // Request the current value before we create the Observer.
   // In this way, we can see the persistent state maintained
   // by the Subject.
   char* cur_value = string_subj-&#62;getValue();
   std::cout &#60;&#60; &#34;Current string value is &#39;&#34; &#60;&#60; cur_value &#60;&#60; &#34;&#39;&#34;
             &#60;&#60; std::endl;
   delete cur_value;

   // Create our Observer servant.
   string_observer = new StringObserverImpl(string_subj);        <co
id="client.cpp.main.servant.construct"
linkends="client.cpp.main.servant.construct.co" />

   // Register the newly created servant with our ORB&#39;s POA.
   observer_id =
      corba_service.registerObject(string_observer,
                                   &#34;StringObserver&#34;);            <co
id="client.cpp.main.servant.register"
linkends="client.cpp.main.servant.register.co" />

   // This could be done in the StringObserverImpl constructor,
   // but we do it here in this example just to make it clear
   // that it is important.
   string_subj-&#62;attach(string_observer-&#62;_this());                <co
id="client.cpp.main.observer.attach" />

   const std::string exit_string(&#34;Q&#34;);
   std::string cur_string;

   for ( ;; )                                                    <co
id="client.cpp.main.loop" linkends="client.cpp.main.loop.co" />
   {
      std::cout &#60;&#60; &#34;Enter a string (Q to quit): &#34;;
      std::cin &#62;&#62; cur_string;

      if ( exit_string != cur_string )
      {
         string_subj-&#62;setValue(cur_string.c_str());              <co
id="client.cpp.main.subject.setValue" />
      }
      else
      {
         break;
      }
   }
}
catch (...)
{
   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
      &#60;&#60; &#34;Caught an unknown exception during object interaction!\n&#34;
      &#60;&#60; vprDEBUG_FLUSH;
}

// We&#39;re done, so now we have to clean up after ourselves.
// The order of operations here is important.
if ( NULL != string_observer )
{
   string_observer-&#62;detach();                                    <co
id="client.cpp.main.observer.detach" linkends="client.cpp.main.cleanup.co" />
   corba_service.unregisterObject(observer_id);                  <co
id="client.cpp.main.servant.unregister" linkends="client.cpp.main.cleanup.co" />
   delete string_observer;                                       <co
id="client.cpp.main.servant.delete" linkends="client.cpp.main.cleanup.co" />
}</programlisting>

            <calloutlist>
              <callout arearefs="client.cpp.main.subject.narrow"
              id="client.cpp.main.subject.narrow.co">
                <para>Given a non-nil Subject reference, we now need to narrow
                it to our specific Subject type,
                <interfacename>CxxClientTest::StringSubject</interfacename>.
                If the narrowing fails, an exception will be thrown. In that
                case, we are done because we did not get back a reference we
                can use.</para>
              </callout>

              <callout arearefs="client.cpp.main.servant.construct"
              id="client.cpp.main.servant.construct.co">
                <para>If the narrowing succeeded, then we can create an
                Observer servant (an instance of our class
                <classname>StringObserverImpl</classname>). In our local ORB,
                this servant will handle accesses from remote objects—namely,
                the Subject to which it is attached.</para>
              </callout>

              <callout arearefs="client.cpp.main.servant.register"
              id="client.cpp.main.servant.register.co">
                <para>Next, we register our newly created Observer servant
                with the POA in the local CORBA Service. We give it an
                arbitrary name, and it gives us a unique identifier for the
                servant. We will need this identifier later when the
                application is shutting down and cleaning up after itself.</para>
              </callout>

              <callout arearefs="client.cpp.main.observer.attach"
              id="client.cpp.main.observer.attach.co">
                <para>At long last, we can attach our Observer to the remote
                Subject. The mechanism for doing this is nearly identical to
                the Java version. The only difference is the use of the
                <literal>-&#62;</literal> operator, which is not present in
                Java. Once the Subject knows about our Observer, it will be
                informed of all state changes.</para>
              </callout>

              <callout arearefs="client.cpp.main.loop"
              id="client.cpp.main.loop.co">
                <para>In this loop, we ask the user for input and then pass
                that input to the Subject&#39;s <methodname>setValue()</methodname>
                method. We do this until the user enters the string
                <literal>&#34;Q&#34;</literal>, which denotes that s/he wants
                to quit the application.</para>
              </callout>

              <callout arearefs="client.cpp.main.subject.setValue"
              id="client.cpp.main.subject.setValue.co">
                <para>This is where we modify the state of the remote Subject.
                We pass the C string version of the user-specified string as
                the argument to <methodname>CxxClientTest::StringSubject::setValue()</methodname>.</para>
              </callout>

              <callout
              arearefs="client.cpp.main.observer.detach client.cpp.main.servant.unregister client.cpp.main.servant.delete"
              id="client.cpp.main.cleanup.co">
                <para>Once the user has requested to quit the application, we
                need to clean up the servant we constructed earlier. First, we
                detach the Observer from the remote Subject. Next, we
                unregister our servant using the ID returned by the local
                CORBA Service. Finally, we delete the heap memory allocated
                for the servant. With that, we are done.</para>
              </callout>
            </calloutlist>
          </example>

          <para>The last part of the client application is the choice of the
          Subject Manager reference to use. In this example, we put that code
          in the helper function <function>chooseSubjectManager()</function>.
          In this function, we request the list of valid Subject Manager
          references from the local CORBA Service and present the information
          about each one to the user. Using this information, the user selects
          one, and that reference is then returned to the caller. In a
          real-world example, the Subject Manager chooser would be much more
          sophisticated than what we show in <xref
          linkend="client.cpp.chooseSubjectManager.example" />, but for the
          purposes of explaining the ideas, this will suffice.</para>

          <example id="client.cpp.chooseSubjectManager.example">
            <title>client.cpp: Implementation of chooseSubjectManager()</title>

            <programlisting linenumbering="numbered">tweek::SubjectManager_var chooseSubjectManager(tweek::CorbaService&#38; corbaService)
{
   tweek::SubjectManager_var subj_mgr;

   // Request all the active Subject Manager references.
   std::list&#60;tweek::SubjectManager_var&#62; mgrs =
      corbaService.getSubjectManagerList();                                   <co
id="client.cpp.chooseSubjectManager.list"
linkends="client.cpp.chooseSubjectManager.list.co" />

   std::list&#60;tweek::SubjectManager_var&#62;::iterator cur_mgr;

   // Iterate over all the tweek::SubjectManager references we have.
   for ( cur_mgr = mgrs.begin(); cur_mgr != mgrs.end(); ++cur_mgr )           <co
id="client.cpp.chooseSubjectManager.loop"
linkends="client.cpp.chooseSubjectManager.loop.co" />
   {
      try
      {
         // It is not entirely safe to assume that *cur_mgr is still valid at
         // this point, even though it was valid when the mgrs list was
         // constructed.  Hence, we test it again now.
         if ( ! (*cur_mgr)-&#62;_non_existent() )                                 <co
id="client.cpp.chooseSubjectManager.verify"
linkends="client.cpp.chooseSubjectManager.verify.co" />
         {
            std::string response;
            const std::string proceed(&#34;y&#34;);

            tweek::SubjectManager::SubjectManagerInfoList_var mgr_info =      <co
id="client.cpp.chooseSubjectManager.getInfo"
linkends="client.cpp.chooseSubjectManager.info.co" />
               (*cur_mgr)-&#62;getInfo();

            std::cout &#60;&#60; &#34;\nSubject Manager information:&#34; &#60;&#60; std::endl;

            // Loop over the information items and print each key/value pair
            // to the screen.
            for ( CORBA::ULong i = 0; i &#60; mgr_info-&#62;length(); ++i )           <co
id="client.cpp.chooseSubjectManager.info-loop"
linkends="client.cpp.chooseSubjectManager.info.co" />
            {
               std::cout &#60;&#60; &#34;\t&#34; &#60;&#60; mgr_info[i].key  &#60;&#60; &#34; = &#34;
                         &#60;&#60; mgr_info[i].value &#60;&#60; std::endl;
            }

            std::cout &#60;&#60; &#34;Use this Subject Manager (y/n)? &#34;;
            std::cin &#62;&#62; response;

            if ( proceed == response )
            {
               subj_mgr = *cur_mgr;                                           <co
id="client.cpp.chooseSubjectManager.done"
linkends="client.cpp.chooseSubjectManager.done.co" />
               break;
            }
         }
      }
      catch (...)
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &#60;&#60; &#34;Caught an unknown exception in chooseSubjectManager loop\n&#34;
            &#60;&#60; vprDEBUG_FLUSH;
      }
   }

   return subj_mgr;
}</programlisting>

            <calloutlist>
              <callout arearefs="client.cpp.chooseSubjectManager.list"
              id="client.cpp.chooseSubjectManager.list.co">
                <para>Using the given <classname>tweek::CorbaService</classname>
                reference, we ask for the current list of valid
                <interfacename>tweek::SubjectManager</interfacename>
                references. The references in this list are guaranteed to be
                valid at the time the list was constructed.</para>
              </callout>

              <callout arearefs="client.cpp.chooseSubjectManager.loop"
              id="client.cpp.chooseSubjectManager.loop.co">
                <para>We use an STL iterator to loop over the list of returned
                <interfacename>tweek::SubjectManager</interfacename>
                references. This loop presents each reference in sequence and
                asks the user if the current reference is the one s/he wants.
                The loop completes when the user selects a reference or when
                no more references are available.</para>
              </callout>

              <callout arearefs="client.cpp.chooseSubjectManager.verify"
              id="client.cpp.chooseSubjectManager.verify.co">
                <para>While the list of Subject Manager references was
                guaranteed to have contained valid references when it was
                constructed, things may have changed since then. That is the
                nature of asynchronous programming. To be safe, we test the
                current Subject Manager reference to see if it still refers to
                an extant object. If so, we continue. If not, we skip it. This
                invocation of <methodname>tweek::SubjectManager::_non_existent()</methodname>
                may throw an exception, and for that reason, we enclose the
                body of the for loop in a try/catch block.</para>
              </callout>

              <callout
              arearefs="client.cpp.chooseSubjectManager.getInfo client.cpp.chooseSubjectManager.info-loop"
              id="client.cpp.chooseSubjectManager.info.co">
                <para>It is possible for a single Naming Service to have
                multiple active Subject Manager references. Each of these has
                a unique identifier within the Naming Service, but the
                identifier is not human readable. To work around this, we make
                use of the method <methodname>tweek::SubjectManager::getInfo()</methodname>.
                This method returns a sequence of key/value pairs (both are
                strings) that can be used to identify which Subject Manager
                reference is the correct one. Here, we request this
                information sequence and print all the key/value pairs. With
                this output, the user can (hopefully) determine which Subject
                Manager reference to use.</para>

                <note>
                  <para>This example is purposefully simple to keep the code
                  small. Readers are strongly encouraged to come up with much
                  more sophisticated choosing mechanisms here. For example,
                  the flexibility of the Subject Manager information sequence
                  would allow choices to be made entirely in code without any
                  interactive user feedback.</para>
                </note>
              </callout>

              <callout arearefs="client.cpp.chooseSubjectManager.done"
              id="client.cpp.chooseSubjectManager.done.co">
                <para>Here, the user has selected the current Subject Manager
                as the correct one. We copy the reference to the
                <varname>subj_mgr</varname> variable. Then, we break out of
                the loop and return <varname>subj_mgr</varname> to the caller.</para>
              </callout>
            </calloutlist>
          </example>

          <para>With that, we are done with our review of the C++ client API
          in Tweek. The use of CORBA allows Java and C++ client code to be
          quite similar, and this can be helpful when migrating between the
          two. The addition of the C++ client API in Tweek 0.13 also
          demonstrates one of the basic design philosophies of Tweek: clients
          can be written in any language without concern for the language the
          server uses.</para>
        </section>
      </section>
    </chapter>

    <chapter>
      <title>Python</title>

      <indexterm>
        <primary>Python client API</primary>
      </indexterm>

      <para></para>
    </chapter>
  </part>

  <part>
    <title>Appendices</title>

    <appendix id="makefile.appendix">
      <title>Makefiles for Example Code</title>

      <para>This appendix provides makefiles that can be used as starting
      points for compiling the example code shown earlier. These can also be
      used as the basis for future projects using Tweek.</para>

      <section id="SliderSubject.makefile.section">
        <title>SliderSubject</title>

        <para>The following is a makefile that shows how to compile the code
        related to the <interfacename>SliderSubject</interfacename> example
        presented in <xref linkend="collab.slider.section" />. It runs the IDL
        compiler, the C++ compiler, and the Java compiler. It assumes the use
        of <command>omniidl</command>, the JacORB compiler, and GCC in a Linux
        environment.</para>

        <programlisting>default: all

# Basic options.
srcdir		= .
CFLAGS		= $(EXTRA_CFLAGS) $(INCLUDES) $(DEFS)
CXXFLAGS		= -Wall -Werror-implicit-function-declaration \
                    -I$(VPR_BASE_DIR/include -I$(TWEEK_BASE_DIR)/include/tweek/CORBA \
                    $(EXTRA_CFLAGS) $(INCLUDES) $(DEFS)
CXX_IDL_OPTS	= -bcxx -Wbh=.h,s=.cpp -C$(srcdir)
CXX_IDL_INCLUDES	= -I$(TWEEK_BASE_DIR)/include
JAVAC_FLAGS	= -classpath $(CLASSPATH) -sourcepath $(srcdir) -d .
JAVA_IDL_OPTS	=  -d $(srcdir)
JAVA_IDL_INCLUDES	= -I$(TWEEK_BASE_DIR)/include

JAVA_ORB_JAR	= $(HOME)/OpenORB-1.2.0/lib/openorb-1.2.0.jar

TWEEK_EVENT_LIB	= $(TWEEK_BASE_DIR)/bin/TweekEvents.jar
TWEEK_NET_LIB	= $(TWEEK_BASE_DIR)/bin/TweekNet.jar
CLASSPATH	= $(TWEEK_EVENT_LIB):$(TWEEK_NET_LIB):$(JAVA_ORB_JAR)
DEFS		= -D__linux__ -D__OSVERSION__=2 -D__x86__
EXTRA_CFLAGS	= $(DEBUG_CFLAGS)
DEBUG_CFLAGS	= -g -D_DEBUG
OPTIM_CFLAGS	= -O2 -fno-strict-aliasing -D_OPT -DNDEBUG
INCLUDES		= -I$(TWEEK_BASE_DIR)/include -I$(HOME)/omni/include -I$(srcdir)

EXTRA_LFLAGS	= $(DEBUG_LFLAGS)
DEBUG_LFLAGS	= 
OPTIM_LFLAGS	= 
LINK_FLAGS	= $(EXTRA_LFLAGS)

# Libraries needed for linking.
BASIC_LIBS	= -Wl,-Bstatic $(LINKALL_ON) -L$(TWEEK_BASE_DIR)/lib -ltweek \
                    $(LINKALL_OFF) -Wl,-Bdynamic
EXTRA_LIBS	= -Wl,-Bdynamic  -L$(HOME)/omni/lib/i586_linux_2.0_glibc \
                    -lomniORB3 -lomnithread -lomniDynamic3 -lomniGK_stub   \
                    -L$(VPR_BASE_DIR)/lib -lvpr  -pthread   

# Commands to execute.
C_COMPILE	= gcc $(CFLAGS)
CXX_IDL		= $(HOME)/omni/bin/i586_linux_2.0_glibc/omniidl
CXX_COMPILE	= c++ $(CXXFLAGS)
JAVA_COMPILE	= /usr/java/jdk1.3.1_02/bin/javac $(JAVAC_FLAGS)
JAVA_IDL		= JACORB_PATH=&#34;$(TWEEK_BASE_DIR)/bin&#34; &#34;$(TWEEK_BASE_DIR)/bin/idl&#34;
JAR		= /usr/java/jdk1.3.1_02/bin/jar
LINK		= c++ $(LINK_FLAGS)
LINKALL_ON	= -W,--whole-archive
LINKALL_OFF	= -W,--no-whole-archive

VPATH = $(srcdir):$(srcdir)/networktest:$(srcdir)/tweek:$(TWEEK_BASE_DIR)/include/tweek/idl

IDL_CXX_FILES	= SliderSubject.cpp SliderSubject.h
IDL_JAVA_FILES	= SliderSubject.java		\
                    Observer.java

OBJS		= SliderSubject.o SliderSubjectImpl.o	\
                    SliderSubjectApp.o
CLASSES		= networktest/NetworkTest.class		\
                    networktest/SliderObserverImpl.class	\
                    networktest/SliderSubjectHolder.class	\
                    tweek/ObserverHolder.class

NETWORK_TEST_CLASSES = networktest/*.class tweek/*.class

# -----------------------------------------------------------------------------
# Application build targets.
# -----------------------------------------------------------------------------
all:
	$(MAKE) cxx_idl
	$(MAKE) java_idl
	$(MAKE) cxx
	$(MAKE) server
	$(MAKE) java
	$(MAKE) NetworkTestBean.jar
	-$(MAKE) install

cxx_idl: $(IDL_CXX_FILES)

java_idl: $(IDL_JAVA_FILES)

cxx: $(OBJS)

java: $(CLASSES)

server: $(OBJS)
	$(LINK) -o $@ $(OBJS) $(BASIC_LIBS) $(EXTRA_LIBS)

NetworkTestBean.jar: $(CLASSES)
	$(JAR) cvfm $@ $(srcdir)/networktest.MF $(NETWORK_TEST_CLASSES)

install:
	cp NetworkTestBean.jar $(TWEEK_BASE_DIR)/bin/beans
	cp $(srcdir)/NetworkTestBean.xml $(TWEEK_BASE_DIR)/bin/beans

# Suffix rules for building object files.
.SUFFIXES: .cpp .o .java .class .idl .h

.cpp.o:
	$(CXX_COMPILE) -o $@ -c $&#60;

.java.class:
	$(JAVA_COMPILE) $&#60;

.idl.cpp:
	$(CXX_IDL) $(CXX_IDL_OPTS) $(CXX_IDL_INCLUDES) $&#60;

.idl.h:
	$(CXX_IDL) $(CXX_IDL_OPTS) $(CXX_IDL_INCLUDES) $&#60;

SliderSubject.java: SliderSubject.idl
	$(JAVA_IDL) $(JAVA_IDL_OPTS) -noskel $(JAVA_IDL_INCLUDES) $&#60;

.idl.java:
	$(JAVA_IDL) $(JAVA_IDL_OPTS) $(JAVA_IDL_INCLUDES) $&#60;

# -----------------------------------------------------------------------------
# Clean-up targets.
# -----------------------------------------------------------------------------
clean:
	rm -f Makedepend *.o networktest.ilk  so_locations *.?db	\
          core* $(addprefix $(srcdir)/, $(IDL_CXX_FILES))		\
          $(addprefix $(srcdir)/networktest/, $(IDL_JAVA_FILES))
	rm -rf ii_files $(srcdir)/tweek

clobber:
	@$(MAKE) clean
	rm -f server </programlisting>
      </section>

      <section id="FileLoader.makefile.section">
        <title>File Loader</title>

        <para>The following is a makefile that shows how to compile the code
        related to the file loader Bean example presented in <xref
        linkend="file.loader.section" />. All it must do is compile the Java
        code for the Bean.</para>

        <programlisting># Generated automatically from Makefile.in by configure.
default: all

# Basic options.
srcdir		= .
JAVAC_FLAGS	= -classpath $(CLASSPATH) -sourcepath $(srcdir) -d .
JCPS		= :

JDOM_JAR		= $(JDOM_ROOT)/jdom.jar:$(JDOM_ROOT)/xerces.jar

TWEEK_SERV_LIB	= $(TWEEK_BASE_DIR)/bin/TweekServices.jar
TWEEK_NET_LIB	= $(TWEEK_BASE_DIR)/bin/TweekEvents.jar
CLASSPATH	= $(TWEEK_SERV_LIB):$(TWEEK_NET_LIB):$(JDOM_JAR)

# Commands to execute.
JAVA_COMPILE	= javac $(JAVAC_FLAGS)
JAR		= jar

VPATH		= .

CLASSES		= fileopentestbean/FileOpenTestBean.class
ALL_CLASSES	= fileopentestbean/*.class

# -----------------------------------------------------------------------------
# Application build targets.
# -----------------------------------------------------------------------------
all:
	$(MAKE) java
	$(MAKE) FileOpenTestBean.jar
	-$(MAKE) install

java: $(CLASSES)

FileOpenTestBean.jar: $(CLASSES)
	$(JAR) cvfm $@ $(srcdir)/opener_test.MF $(ALL_CLASSES)

install:
	cp FileOpenTestBean.jar $(TWEEK_BASE_DIR)/bin/beans
	cp $(srcdir)/FileOpenTestBean.xml $(TWEEK_BASE_DIR)/bin/beans

# Suffix rules for building object files.
.SUFFIXES: .java .class

.java.class:
	$(JAVA_COMPILE) $&#60;

# -----------------------------------------------------------------------------
# Clean-up targets.
# -----------------------------------------------------------------------------
clean:
	rm -rf fileopentestbean

clobber:
	@$(MAKE) clean
	rm -f FileOpenTestBean.jar</programlisting>
      </section>
    </appendix>

    <appendix id="orb-impl.appendix">
      <title>CORBA Implementations</title>

      <para>In order to use CORBA, a CORBA implementation must be available.
      As of this writing, Tweek uses omniORB 3.0.4 and newer <xref
      linkend="Omn02" /> for a C++ ORB. Since Tweek uses the POA, any C++ ORB
      may be used with only a few changes to the code.</para>

      <para>For the Java side, OpenORB 1.2.0 <xref linkend="Ope02" /> and
      newer <xref linkend="Ope03" /> have been used. Java IDL <xref
      linkend="Jid02" />, the CORBA implementation that comes with the Java
      Development Kit (JDK), does not fully implement the POA as of JDK 1.3.1.
      With the release of JDK 1.4.0, Java IDL has a complete, working POA
      implementation and can be used without taking any special steps.</para>

      <para>To use an alternate ORB with Java, two arguments must be passed to
      the Java virtual machine. They are based on the ORB implementation. For
      example, if using OpenORB, the following two arguments must be
      specified:</para>

      <orderedlist>
        <listitem>
          <para><option>-Dorg.omg.CORBA.ORBClass=org.openorb.CORBA.ORB</option></para>
        </listitem>

        <listitem>
          <para><option>-Dorg.omg.CORBA.ORBSingletonClass=org.openorb.CORBA.ORB</option>Singleton</para>
        </listitem>
      </orderedlist>

      <para>Other ORBs will vary in the location of the
      <classname>ORBClass</classname> and the <classname>ORBSingletonClass</classname>.
      Refer to the documentation of the specific ORB to find out more about
      using it instead of Java IDL.</para>

      <para>For Python, most testing thus far has been done with omniORBpy 2.0
      and newer. Using ominORBpy requires that omniORB be installed since
      omniORBpy is primarily just a Python wrapper wround the C++ CORBA
      implementation. We are watching the development of Fnorb <xref
      linkend="Fno03" /> as an alternative to omniORBpy. Fnorb offers a
      pure-Python implementation of CORBA. In other words, it requires no
      natively compiled code to operate. Prior to December 2003, Fnorb lacked
      a POA implementation, so it was not a viable option, but work is still
      under way to provide a complete CORBA 2.3 implementation.</para>
    </appendix>

    <appendix>
      <title>Legal</title>

      <para>A full binary distribution of Tweek comes with binary code from
      several other software projects not affiliated with the Juggler Project
      or Iowa State University. Tweek makes use of redistributable code from
      the following packages:</para>

      <itemizedlist>
        <listitem>
          <para>JDOM (<ulink url="http://www.jdom.org/">http://www.jdom.org/</ulink>)</para>
        </listitem>

        <listitem>
          <para>JacORB (<ulink url="http://www.jacorb.org/">http://www.jacorb.org/</ulink>)</para>
        </listitem>

        <listitem>
          <para>Kuststoff look and feel (<ulink url="http://www.incors.org/">http://www.incors.org/</ulink>)</para>
        </listitem>

        <listitem>
          <para>Metouia look and feel (<ulink
          url="http://mlf.sourceforge.net/">http://mlf.sourceforge.net/</ulink>)</para>
        </listitem>

        <listitem>
          <para>OpenORB (<ulink url="http://openorb.exolab.org/">http://openorb.exolab.org/</ulink>
          or <ulink url="http://openorb.sourceforge.net/">http://openorb.sourceforge.net/</ulink>)</para>
        </listitem>
      </itemizedlist>

      <para>The licenses for each of these software packages can be found in
      <filename>$TWEEK_BASE_DIR/share/tweek/data/licenses</filename>.</para>
    </appendix>
  </part>

  <bibliography>
    <biblioentry id="Fno03">
      <biblioset relation="website">
        <address><otheraddr><ulink url="http://www.fnorb.org/">Fnorb website</ulink></otheraddr></address>
      </biblioset>
    </biblioentry>

    <biblioentry id="Gam95">
      <biblioset relation="book">
        <authorgroup>
          <author>
            <firstname>Erich</firstname>

            <surname>Gamma</surname>
          </author>

          <author>
            <firstname>Richard</firstname>

            <surname>Helm</surname>
          </author>

          <author>
            <firstname>Ralph</firstname>

            <surname>Johnson</surname>
          </author>

          <author>
            <firstname>John</firstname>

            <surname>Vlissides</surname>
          </author>
        </authorgroup>

        <title>Design Patterns</title>

        <copyright>
          <year>1995</year>

          <holder>Addison Wesley Longman, Inc.</holder>
        </copyright>

        <isbn>0-201-63361-2</isbn>

        <publisher>
          <publishername>Addison-Wesley</publishername>
        </publisher>
      </biblioset>
    </biblioentry>

    <biblioentry id="Hen99">
      <biblioset relation="book">
        <authorgroup>
          <author>
            <firstname>Michi</firstname>

            <surname>Henning</surname>
          </author>

          <author>
            <firstname>Steve</firstname>

            <surname>Vinoski</surname>
          </author>
        </authorgroup>

        <title>Advanced CORBA Programming with C++</title>

        <copyright>
          <year>1999</year>

          <holder>Addison Wesley Longman, Inc.</holder>
        </copyright>

        <isbn>0-201-37927-9</isbn>

        <publisher>
          <publishername>Addison Wesley Longman, Inc.</publishername>
        </publisher>
      </biblioset>
    </biblioentry>

    <biblioentry id="Jbe02">
      <biblioset relation="website">
        <address><otheraddr><ulink
url="http://java.sun.com/products/javabeans/">JavaBeans website</ulink></otheraddr></address>
      </biblioset>
    </biblioentry>

    <biblioentry id="Jid02">
      <biblioset relation="website">
        <address><otheraddr><ulink url="http://java.sun.com/products/jdk/idl/">Java IDL website</ulink></otheraddr></address>
      </biblioset>
    </biblioentry>

    <biblioentry id="Omn02">
      <biblioset relation="website">
        <address><otheraddr><ulink
url="http://www.uk.research.att.com/omniORB/">omniORB website</ulink></otheraddr></address>
      </biblioset>
    </biblioentry>

    <biblioentry id="Ope02">
      <biblioset relation="website">
        <address><otheraddr><ulink url="http://www.openorb.com/">OpenORB website</ulink></otheraddr></address>
      </biblioset>
    </biblioentry>

    <biblioentry id="Ope03">
      <biblioset relation="website">
        <address><otheraddr><ulink url="http://openorb.sourceforge.net/">OpenORB community website</ulink></otheraddr></address>
      </biblioset>
    </biblioentry>

    <biblioentry id="Pyq03">
      <biblioset relation="website">
        <address><otheraddr><ulink
url="http://www.riverbankcomputing.co.uk/pyqt/index.php">PyQt website</ulink></otheraddr></address>
      </biblioset>
    </biblioentry>
  </bibliography>

  <glossary>
    <title>Glossary</title>

    <glossdiv>
      <title>A</title>

      <glossentry id="gloss.api">
        <glossterm>application programmer interface</glossterm>

        <acronym>API</acronym>

        <glossdef>
          <para>An application programmer interface is the documented,
          programatic interface used by programmers to access a software
          library.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>C</title>

      <glossentry id="gloss.corba">
        <glossterm>Common Object Request Broker Architecture</glossterm>

        <acronym>CORBA</acronym>

        <glossdef>
          <para>The Common Object Request Broker Architecture (CORBA) is a
          standard specified by the Object Management Group for distributed
          object-oriented programming. It is both platform- and
          language-independent. Implementations of CORBA are available from
          many vendors for a wide variety of programming languages.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>D</title>

      <glossentry id="gloss.distrib-programming">
        <glossterm>distributed programming</glossterm>

        <glossdef>
          <para>Distributed programming is a paradigm in which software
          components are installed on physically separated computers and
          accessed remotely though a network. Examples of distributed
          programming include Sun&#39;s Remote Procedure Calls (RPC),
          Java&#39;s Remote Method Invocation (RMI), Microsoft&#39;s Component
          Object Model (COM), and the Common Object Request Broker
          Architecture (CORBA). RPC is based on the procedural programming
          paradigm used by languages such as C and Pascal. With RPC,
          procedures residing in memory on remote machines are accessed. The
          other examples listed are based on the object-oriented programming
          paradigm used by languages such as C++, Java, Smalltalk, and Python.
          In this case, software objects and their methods are accessed
          remotely.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>E</title>

      <glossentry id="gloss.xml.main">
        <glossterm>Extensible Markup Language</glossterm>

        <acronym>XML</acronym>

        <glossdef>
          <para>The eXtensible Markup Language (XML) is a specification from
          the World Wide Web Consortium. XML itself is a language for
          specifying well-defined, structured document markup.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>G</title>

      <glossentry id="gloss.gui">
        <glossterm>graphical user interface</glossterm>

        <acronym>GUI</acronym>

        <glossdef>
          <para>Graphical user interfaces are used in modern operating systems
          that support the concept of <quote>windows</quote>. The windows
          provide a visual representation of an application and usually have a
          border and a title to distinguish one window from another. Within
          the window, there are graphical elements known as <quote>widgets</quote>
          that make up the full interface. Widgets include pull-down menus,
          clickable buttons, and scroll bars.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>I</title>

      <glossentry id="gloss.idl-compiler">
        <glossterm>IDL compiler</glossterm>

        <glossdef>
          <para>A software tool that reads an IDL file and generates code in a
          specific language (e.g., Java, C++, Smalltalk, etc.). This code may
          be anything, but typically, it is stub or skeleton code that is
          extended by user-defined code that completes the interface
          implementation.</para>
        </glossdef>
      </glossentry>

      <glossentry id="gloss.interface">
        <glossterm>interface</glossterm>

        <glossdef>
          <para>Several types of <quote>interfaces</quote> exist within the
          scope of Tweek:</para>

          <itemizedlist>
            <listitem>
              <para>In Java. there is a keyword <literal>interface</literal>
              that can be used to define a set of methods that must be part of
              an implementing class. Classes that claim to implement a given
              interface must define the methods described by the interface or
              declare themselves abstract.</para>
            </listitem>

            <listitem>
              <para>In <glossterm linkend="gloss.idl">IDL</glossterm>, an
              interface is essentially identical to a Java interface, but an
              IDL compiler can generate code from the IDL. The interface
              methods must still be implemented (by a C++ class, for example),
              and thus, the main function of an IDL interface is to define a
              language-independent signature through which CORBA communication
              may occur.</para>
            </listitem>

            <listitem>
              <para>In C++, there is no <literal>interface</literal> keyword
              as in Java and IDL. The term <quote>interface</quote> is
              typically applied to abstract classes (those with pure virtual
              methods). More generally, it is use to refer to the collection
              of methods defined by a class.</para>
            </listitem>
          </itemizedlist>
        </glossdef>
      </glossentry>

      <glossentry id="gloss.idl">
        <glossterm>Interface Definition Language</glossterm>

        <acronym>IDL</acronym>

        <glossdef>
          <para>The Interface Definition Language is a simple language used to
          define the interface (or signature) an object will have. An
          interface is composed solely of methods (functions) that may be
          invoked on an object (data element). No data members are present in
          the interface definition. IDL is not tied to a specific language but
          instead must be compiled into another language where the interface
          will be implemented.</para>
        </glossdef>
      </glossentry>

      <glossentry id="gloss.iiop">
        <glossterm>Internet Inter-ORB Protocol</glossterm>

        <acronym>IIOP</acronym>

        <glossdef>
          <para>The Internet Inter-ORB Protocol (IIOP) is part of the CORBA
          specification. It is used to standardize communication between ORBs
          so that ORBs from different vendors can inter-operate seamlessly.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>J</title>

      <glossentry id="gloss.javabean">
        <glossterm>JavaBean</glossterm>

        <glossdef>
          <para>JavaBeans are the component architecture of the Java
          programming language. There are no restrictions on the interfaces
          implemented by JavaBeans, though it is strongly recommended that
          they implement <interfacename>java.io.Serializable</interfacename>.</para>
        </glossdef>
      </glossentry>

      <glossentry id="gloss.jni">
        <glossterm>Java Native Interface</glossterm>

        <acronym>JNI</acronym>

        <glossdef>
          <para>The Java Native Interface is the bridge between a Java virtual
          machine (JVM) and natively compiled code. Native code can load a JVM
          and get access to Java objects through it, or Java classes may have
          native methods that are loaded by the JVM.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>O</title>

      <glossentry id="gloss.orb">
        <glossterm>Object Request Broker</glossterm>

        <acronym>ORB</acronym>

        <glossdef>
          <para>An Object Request Broker (ORB) is used by CORBA for management
          of interface implementation objects (servants) and the references
          made to those objects. ORBs communicate with each other using a
          client/server model, though two ORBs may both act as servers and
          clients during the transactions.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>P</title>

      <glossentry id="gloss.poa">
        <glossterm>Portable Object Adapter</glossterm>

        <acronym>POA</acronym>

        <glossdef>
          <para>The Portable Object Adapter (POA) the standard object adapter
          and is part of the CORBA 2.3 specification. It is used together with
          IIOP to allow ORB implementations from different vendors to
          communicate. A single ORB may have multiple POAs each tailored to a
          certain task using parameterized characteristics.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>R</title>

      <glossentry id="gloss.rmi">
        <glossterm>Remote Method Invocation</glossterm>

        <acronym>RMI</acronym>

        <glossdef>
          <para>Remote Method Invocation (RMI) is a mechanism for gaining
          access to remote Java code. It is implemented as part of the Java
          virtual machine and was originally intended to be comparable to
          CORBA. RMI allows easy access to code between two virtual machines,
          but it does not have the cross-language features of CORBA.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>S</title>

      <glossentry id="gloss.servant">
        <glossterm>servant</glossterm>

        <glossdef>
          <para>In CORBA, a servant is an instance of an interface
          implementation that is registered with an ORB. A servant receives
          method invocations through the CORBA object adapter.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>X</title>

      <glossentry id="gloss.xml">
        <glossterm>XML</glossterm>

        <glossdef>
          <para>See <glossterm linkend="gloss.xml.main">Extensible Markup
          Language</glossterm>.</para>
        </glossdef>
      </glossentry>
    </glossdiv>
  </glossary>

  <index></index>
</book>
