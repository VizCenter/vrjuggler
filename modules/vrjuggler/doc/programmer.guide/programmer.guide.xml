<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="../../../../../../../../../../../home/users/patrick/src/Juggler/docs/stylesheet/docbook_ab.css" type="text/css"?>
<?morphon-document-settings
  morphon.document.settings.whitespaces.amount="3"
  morphon.document.settings.print.fixed.attributes="true"
  morphon.document.settings.stylesheetpi.autoupdate="true"
  morphon.document.settings.print.defaultvalues.attributes="false"
  morphon.document.settings.relative.systemids="0"
  morphon.document.settings.endofline.type="2"
  morphon.document.settings.whitespaces.type="indent"
?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>VR Juggler</title>
      <subtitle>The Programmer's Guide</subtitle>
      <releaseinfo>Version 1.1 DR2</releaseinfo>
      <pubdate>$Date$</pubdate>
   </bookinfo>
   <part id="intro.part">
      <title>Introduction</title>
      <chapter id="ch1">
         <title>Getting Started</title>
         <para>In this book, we present a <quote>how-to</quote> for writing VR Juggler applications. We will explain concepts used in VR Juggler and present carefully annotated example code whenever appropriate. There are two groups of people who should read this book:</para>
         <orderedlist>
            <listitem>
               <para>Those who are required to read it in order to do a project for work. To those in this category, fear not&mdash;VR Juggler is very simple to use after getting through the initial learning stages. It is a very powerful tool that will allow the creation of interesting and powerful applications very quickly.</para>
            </listitem>
            <listitem>
               <para>Those who are just interested in creating compelling, interesting VR applications. VR Juggler facilitates the construction of extremely powerful applications that will run on nearly any combination of hardware architecture and software platform.</para>
            </listitem>
         </orderedlist>
         <section>
            <title>Necessary Experience</title>
            <para>To help readers get the most from this book, recommendations follow to provide an idea of what previous experience is necessary. Various programming skills are needed, of course, but programming for VR requires more than just knowledge of a given programming language. VR Juggler takes advantage of many programming design patterns and advanced concepts to make it more powerful, more flexible, and more extensible. A good background in mathematics is helpful for performing the myriad of transformations that must be applied to three-dimensional geometry.</para>
            <section>
               <title>Required Background</title>
               <para>To get the most from this chapter, there are a few prerequisites:</para>
               <itemizedlist>
                  <listitem>
                     <para>C++ programming experience</para>
                  </listitem>
                  <listitem>
                     <para>Some graphics programming background (e.g., OpenGL, OpenGL Performer, etc.)</para>
                  </listitem>
                  <listitem>
                     <para>Reasonable mathematical background (linear algebra knowledge is very useful)</para>
                  </listitem>
               </itemizedlist>
               <para>For some of the advanced sections of this book, it is recommended that readers review the VR Juggler architecture book. This is optional, though it may be helpful in gaining a quicker understanding of some topics and concepts.</para>
            </section>
            <section>
               <title>Other VR Software Tools</title>
               <para>Readers who already have experience with other VR software development environments can easily skim through this book and find the relevant new information. The book is designed for easy skimming. Simply look at the headings to get a good determination of what should be read and what may be skipped.</para>
            </section>
            <section>
               <title>Organization</title>
               <para>This book is organized into five main chapters:</para>
               <orderedlist>
                  <listitem>
                     <para>Introduction</para>
                  </listitem>
                  <listitem>
                     <para>Application basics: The introduction to the key VR Juggler application development concept, application objects.</para>
                  </listitem>
                  <listitem>
                     <para>Common helper classes: A description of useful classes provided to simplify writing applications.</para>
                  </listitem>
                  <listitem>
                     <para>Writing applications: The presentation of application development including how to get input from devices and how to write applications for each of the supported graphics application programmer interfaces (APIs).</para>
                  </listitem>
                  <listitem>
                     <para>Advanced topics: An extension of the previous chapters showing how to incorporate run-time reconfiguration into applications and how to write multi-threaded applications.</para>
                  </listitem>
               </orderedlist>
            </section>
         </section>
      </chapter>
      <chapter id="ch2">
         <title>Application Basics</title>
         <indexterm zone="ch2">
            <primary>applications</primary>
            <secondary>basics</secondary>
         </indexterm>
         <para>In VR Juggler, all applications are written as objects that are handled by the kernel. The objects are known as <firstterm>application objects</firstterm><indexterm>
               <primary>application object</primary>
            </indexterm>, and we will use that term frequently throughout this text. Application objects are introduced and explained in this chapter.</para>
         <section id="app-obj-overview">
            <title>Application Object Overview</title>
            <indexterm zone="app-obj-overview">
               <primary>applications</primary>
               <secondary>application object overview</secondary>
            </indexterm>
            <indexterm zone="app-obj-overview">
               <primary>application object</primary>
               <secondary>overview</secondary>
            </indexterm>
            <para>VR Juggler uses the application object<indexterm>
                  <primary>application object</primary>
               </indexterm> to create the VR environment with which the users interact. The application object implements interfaces<footnote>
                  <para>An interface is a collection of operations used to specify a service of a class or a component.</para>
               </footnote> needed by the VR Juggler <firstterm>virtual platform</firstterm><indexterm>
                  <primary>virtual platform</primary>
               </indexterm>.</para>
            <section id="main-func-intro-sect">
               <title>No <function>main()</function>&mdash;<quote>Don't call me, I'll call you</quote></title>
               <indexterm zone="main-func-intro-sect">
                  <primary>main function</primary>
               </indexterm>
               <para>Since VR Juggler applications are objects, developers do not write the traditional <function>main()</function> function. Instead, developers create an application object that implements a set of pre-defined interfaces. The VR Juggler kernel controls the application's processing time by calling the object's interface implementation methods.</para>
               <para>In traditional programs, the <function>main()</function> function defines the point where the <firstterm>thread of control</firstterm> enters the application. After the <function>main()</function> function is called, the application starts performing any necessary processing. When the operating system (OS) starts the program, it gives the <function>main()</function> function some unit of processing time. After the time unit (quantum) for the process expires, the OS performs what is called a <quote>context switch</quote> to change control to another process. VR Juggler achieves similar functionality but in a slightly different manner.</para>
               <para>The application objects correspond to processes in a normal OS. The kernel is the scheduler, and it allocates time to an application by invoking the methods of the application object. Because the kernel has additional information about the resources needed by the applications, it maintains a very strict schedule to define when the application is granted processing time. This is the basis to maintain coherence across the system.</para>
            </section>
            <section>
               <title>Application Objects Derive from Base Classes for Specific Graphics APIs</title>
               <para>The first step in defining an application object<indexterm>
                     <primary>application object</primary>
                  </indexterm> is to implement the basic interfaces defined by the kernel and the Draw Managers<indexterm>
                     <primary>Draw Manager</primary>
                  </indexterm>. There is a base class for the interface that the kernel expects (<classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::App</secondary>
                  </indexterm>) and a base class for each Draw Manager interface (<classname>vrj::PfApp</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::PfApp</secondary>
                     <seealso>vrj::PfApp</seealso>
                  </indexterm>, <classname>vrj::GlApp</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::GlApp</secondary>
                     <seealso>vrj::GlApp</seealso>
                  </indexterm>, etc.). See <xref linkend="vjApp-hier-fig"/> for a visual representation of the application interface hierarchy. The kernel interface defined in <classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::App</secondary>
                  </indexterm> specifies methods for initialization, shutdown, and execution of the application. The Draw Manager interfaces specified in the <classname>vrj::*App</classname> classes define the API-specific functions necessary to render the virtual environment. For example, a Draw Manager interface could have functions for drawing the scene and for initializing context-specific information.</para>
               <figure float="1" id="vjApp-hier-fig">
                  <title><classname>vrj::App</classname> hierarchy</title>
                  <mediaobject>
                     <imageobject>
                        <imagedata fileref="figures/userOglApp_hierarchy.png" format="PNG" align="center" scalefit="1"/>
                     </imageobject>
                  </mediaobject>
               </figure>
            </section>
            <section>
               <title>Writing an Application Means Filling in the Blanks</title>
               <para>To implement an application in VR Juggler, developers simply need to <quote>fill in the blanks</quote> of the appropriate interfaces. To simplify this process, there are default implementations of most methods in the interfaces. Hence, the user must only provide implementations for the aspects they want to customize. If an implementation is not provided in the user application object, the default is used, but it is important to know that in most cases, the default implementation does nothing.</para>
            </section>
         </section>
         <section>
            <title>Benefits of Application Objects</title>
            <indexterm>
               <primary>application object</primary>
               <secondary>benefits of</secondary>
            </indexterm>
            <para>As stated earlier, the most common approach for VR application development is one where the application defines the <function>main()</function> function. That <function>main()</function> function in turn calls library functions when needed. The library in this model only executes code when directed to do so by the application. As a result, the application developer is responsible for coordinating the execution of the different VR system components. This can lead to complex applications.</para>
            <section>
               <title>Allow for Run-Time Changes</title>
               <para>As a virtual platform, VR Juggler does not use the model described above because VR Juggler needs to maintain control of the system components. This control is necessary to make changes to the virtual platform at run time. As the controller of the execution, the kernel always knows the current state of the applications, and therefore, it can manage the run-time reconfigurations of the virtual environment safely. With run-time reconfiguration, it is possible to switch applications, start new devices, reconfigure running devices, and send reconfiguration information to the application object.</para>
            </section>
            <section>
               <title>Low Coupling</title>
               <para>Application objects lead to a robust architecture as a result of low coupling and well-defined inter-object dependencies. The application interface defines the only communication path between the application and the virtual platform, and this allows restriction of inter-object dependencies. This decreased coupling allows changes in the system to be localized, and thus, changes to one object will not affect another unless the interface itself is changed. The result is code that is more robust and more extensible.</para>
               <para>Because the application is simply an object, it is possibly to load and unload applications dynamically. When the virtual platform initializes, it waits for an application to be passed to it. When the application is given to the VR Juggler kernel at run time, the kernel performs a few initialization steps and then executes the application.</para>
            </section>
            <section>
               <title>Allows Implementation Changes</title>
               <para>Since applications use a distinct interface to communicate with the virtual platform, changes to the implementation of the virtual platform do not affect the application. Changes could include bug fixes, performance tuning, or new device support.</para>
            </section>
         </section>
         <section id="app-startup">
            <title>VR Juggler Startup</title>
            <indexterm zone="app-startup">
               <primary>applications</primary>
               <secondary>starting</secondary>
            </indexterm>
            <section id="app-startup-no-main">
               <title>No <function>main()</function>&mdash;Sort Of</title>
               <indexterm zone="app-startup-no-main">
                  <primary>applications</primary>
                  <secondary>main function</secondary>
                  <tertiary>use</tertiary>
               </indexterm>
               <para>Previously, we explained how VR Juggler applications do not have a <function>main()</function> function. Further explanation is required. While it is true that user applications do not have a <function>main()</function> function because they are objects, there must still be a <function>main()</function> somewhere that starts the system. This is because the operating system uses <function>main()</function> as the starting point for all applications. In VR Juggler 1.0 applications, there is a <function>main()</function>, but it only starts the VR Juggler kernel and gives the kernel the application to run.</para>
            </section>
            <section id="app-startup-main-structure">
               <title>Structure of a <function>main()</function> Function</title>
               <indexterm zone="app-startup-main-structure">
                  <primary>applications</primary>
                  <secondary>main function</secondary>
                  <tertiary>structure</tertiary>
               </indexterm>
               <para>The following is a typical example of a <function>main()</function> function that will start the VR Juggler kernel and hand it an instance of a user application object. The specifics of what is happening in this code are described below.</para>
               <programlistingco>
                  <areaspec>
                     <area coords="5 75" id="simpleApp.main.body.create-kernel"/>
                     <area coords="6 75" id="simpleApp.main.body.app-instantiate"/>
                     <area coords="8 75" id="simpleApp.main.body.loadConfigFile"/>
                     <area coords="9 75" id="simpleApp.main.body.start"/>
                     <area coords="10 75" id="simpleApp.main.body.setApp"/>
                  </areaspec>
                  <programlisting linenumbering="numbered">#include &lt;simpleApp.h&gt;

int main (int argc, char* argv[])
{
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   simpleApp* app   = new simpleApp();      // Create the app object

   kernel-&gt;loadConfigFile(...);             // Configure the kernel
   kernel-&gt;start();                         // Start the kernel thread
   kernel-&gt;setApplication(app);             // Give application to kernel

   while ( ! exit )
   {
     // sleep
   }
}</programlisting>
                  <calloutlist>
                     <callout arearefs="simpleApp.main.body.create-kernel">
                        <para>This line finds (and may create) the VR Juggler kernel. The kernel reference is stored in the handle so that we can use it later.</para>
                     </callout>
                     <callout arearefs="simpleApp.main.body.app-instantiate">
                        <para>We instantiate a copy of the user application object (<classname>simpleApp</classname>) here. Notice that we include the header file that defines the <classname>simpleApp</classname> class.</para>
                     </callout>
                     <callout arearefs="simpleApp.main.body.loadConfigFile">
                        <para>This statement represents the code that will be in the <function>main()</function> function for passing configuration files to the kernel's <methodname>loadConfigFile()</methodname> method. These configuration files may come from the command line or from some other source. If reading the files from the command line, it can be as simple as looping through all the arguments and passing each one to the kernel.</para>
                     </callout>
                     <callout arearefs="simpleApp.main.body.start">
                        <para>As a result of this statement, the VR Juggler kernel begins running. It creates a new thread of execution for the kernel, and the kernel begins its internal processing. From this point on, any changes made reconfigure the kernel. These changes can come in the form of more configuration files or in the form of an application object to execute. At this point, it is important to notice that the kernel knows nothing about the application. Moreover, there is no need for it to know about configuration files yet. This demonstrates how the VR Juggler kernel executes independently from the user application. The kernel will simply work on its own controlling and configuring the system even without an application to run.</para>
                     </callout>
                     <callout arearefs="simpleApp.main.body.setApp">
                        <para>This statement finally tells the kernel what application it should run. The method call reconfigures the kernel so that it will now start invoking the application object's member functions. It is at this time that the application is now running in the VR system.</para>
                     </callout>
                  </calloutlist>
               </programlistingco>
            </section>
         </section>
         <section>
            <title>Kernel Loop</title>
            <para>Before proceeding into application object details, we must understand how VR Juggler calls the application, and we must know what a <firstterm>frame</firstterm><indexterm>
                  <primary>frame</primary>
               </indexterm> is. In the code above, the statement on line 9 tells the kernel thread to start running. When the kernel begins its execution, it follows the sequence shown in <xref linkend="Kernel-seq-diag"/>. The specific methods called are described in more detail in the following section. This diagram will be useful in understanding the order in which the application object methods are invoked.</para>
            <figure float="1" id="Kernel-seq-diag">
               <title>Kernel loop sequence</title>
               <mediaobject>
                  <imageobject>
                     <imagedata fileref="figures/Kernel_Loop_Call_Sequence.png" format="PNG" align="center" scalefit="1"/>
                  </imageobject>
               </mediaobject>
            </figure>
            <section id="frame-definition-sect">
               <title>Definition of a Frame</title>
               <indexterm zone="frame-definition-sect">
                  <primary>frame</primary>
                  <secondary>definition of</secondary>
               </indexterm>
               <para>The VR Juggler kernel calls each of the methods in the application object based on a strictly scheduled <firstterm>frame of execution</firstterm><indexterm>
                     <primary>frame of execution</primary>
                  </indexterm>. The frame of execution is shown in <xref linkend="Kernel-seq-diag"/>; it makes up all the lines within the <quote>while(running)</quote> clause.</para>
               <para>During the frame of execution, the kernel calls the application methods and performs internal updates (the <methodname>updateAllData()</methodname> method call). Because the kernel has complete control over the frame, it can make changes at pre-defined <quote>safe</quote> times when the application is not doing any processing. At these times, the kernel can change the virtual platform configuration as long as the interface remains the same.</para>
               <para>The frame of execution also serves as a framework for the application. That is, the application can expect that when <methodname>preFrame()</methodname> is called, the devices have just been updated. Applications can rely upon the system being in well-defined stages of the frame when the kernel invokes the application object's methods.</para>
            </section>
         </section>
         <section id="base-app-obj-if-sect">
            <title>Base Application Object Interface</title>
            <indexterm zone="base-app-obj-if-sect">
               <primary>application object</primary>
               <secondary>base interface of</secondary>
            </indexterm>
            <para>Within this section, we provide a brief overview of the member functions from the base VR Juggler application interface. This interface is defined by <classname>vrj::App</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::App</secondary>
               </indexterm>, and the member functions are shown in <xref linkend="App-if-diag"/>. Refer to <xref linkend="Kernel-seq-diag"/> for a visual presentation of the order in which the methods are invoked.</para>
            <para>The base interface of the application object defines the following functions:</para>
            <itemizedlist>
               <listitem>
                  <para><methodname>init()</methodname></para>
               </listitem>
               <listitem>
                  <para><methodname>apiInit()</methodname></para>
               </listitem>
               <listitem>
                  <para><methodname>preFrame()</methodname></para>
               </listitem>
               <listitem>
                  <para><methodname>intraFrame()</methodname></para>
               </listitem>
               <listitem>
                  <para><methodname>postFrame()</methodname></para>
               </listitem>
            </itemizedlist>
            <para>As previously described, the VR Juggler kernel calls these functions from its control loop to allocate processing time to them. These functions handle initialization and computation. Other member functions that can be used for reconfiguration, focus control, resetting, and exiting will be covered later in this book.</para>
            <figure float="1" id="App-if-diag">
               <title>Application object interface</title>
               <mediaobject>
                  <imageobject>
                     <imagedata fileref="figures/userOglApp_hierarchy.png" format="PNG" align="center" scalefit="1"/>
                  </imageobject>
               </mediaobject>
            </figure>
            <section id="app-object-init">
               <title>Initialization</title>
               <indexterm zone="app-object-init">
                  <primary>application object</primary>
                  <secondary>initialization</secondary>
               </indexterm>
               <para>The following is a description of the application objects related to the initialization of a VR Juggler application. The order of presentation is the same as the order of execution when the application is executed by the kernel.</para>
               <section>
                  <title><methodname>vrj::App::init()</methodname></title>
                  <para>The <methodname>init()</methodname> method is called by the kernel to initialize any application data. When the kernel prepares to start a new application, it first calls <methodname>init()</methodname> to signal the application that it is about to be executed.</para>
                  <section>
                     <title>Timing</title>
                     <para>This member function is called immediately after the kernel is told to start running the application and before any graphics API handling has been started by VR Juggler.</para>
                  </section>
                  <section>
                     <title>Uses</title>
                     <para>Typical applications will utilize this method to load data files, create lookup tables, or perform some steps that should be done only once per execution. In other words, this method is the place to perform any pre-processing steps needed by the application to set up its data structures.</para>
                  </section>
               </section>
               <section>
                  <title><methodname>vrj::App::apiInit()</methodname></title>
                  <para>This member function is for any graphics API-specific initialization required by the application. Data members that cannot be initialized until after the graphics API is started should be initialized here.<note>
                        <para>In OpenGL, there is no concept of initializing the API, so this method is not normally used in such applications.</para>
                     </note></para>
                  <section>
                     <title>Timing</title>
                     <para>This member function is called after the graphics API has been started but before the kernel frame is started.</para>
                  </section>
                  <section>
                     <title>Uses</title>
                     <para>In most cases, scene graph loading and other API-specific initialization should be done in this method.</para>
                  </section>
               </section>
            </section>
            <section id="app-object-frame-funcs">
               <title>Frame Functions</title>
               <indexterm zone="app-object-frame-funcs">
                  <primary>application object</primary>
                  <secondary>frame functions</secondary>
               </indexterm>
               <para>Once the application object has been initialized by the VR Juggler kernel, the kernel frame loop begins. Each frame, there are specific application object methods that are invoked, and understanding the timing and potential uses of these methods can improve the functionality of the immersive application. In some cases, it is possible to use these member functions to optimize the application to improve the frame rate and the level of interactivity.</para>
               <section>
                  <title><methodname>vrj::App::preFrame()</methodname></title>
                  <para>The <methodname>preFrame()</methodname> method is called when the system is about to trigger drawing. This is the time that the application object should do any last-minute updates of data based on input device status. It is best to avoid doing any time-consuming computation in this method. The time used in this method contributes to the overall device latency in the system. The devices will not be re-sampled before rendering begins.</para>
                  <section>
                     <title>Timing</title>
                     <para>This method is called immediately before triggering rendering of the current frame.</para>
                  </section>
                  <section>
                     <title>Uses</title>
                     <para>In general, this method should be reserved for <quote>last-millisecond</quote> data updates in response to device input (latency-critical code).</para>
                  </section>
               </section>
               <section>
                  <title><methodname>vrj::App::intraFrame()</methodname></title>
                  <para>The code in this method executes in parallel with the rendering method. That is, it executes while the current frame is being drawn. This is the place to put any processing that can be done in advance for the next frame. By doing parallel processing in this method, the application can increase its frame rate because drawing and computation can be parallelized. Special care must be taken to ensure that any data being used for rendering does not change while rendering is happening. One method for doing this is buffering. Use of synchronization primitives is not recommended because that technique could <emphasis>lower</emphasis> the frame rate.</para>
                  <section>
                     <title>Timing</title>
                     <para>This method is invoked after rendering has been triggered but before the rendering has finished.</para>
                  </section>
                  <section>
                     <title>Uses</title>
                     <para>The primary use of this method is performing time-consuming computations, the results of which can be used in the next frame.</para>
                  </section>
               </section>
               <section>
                  <title><methodname>vrj::App::postFrame()</methodname></title>
                  <para>Finally, the <methodname>postFrame()</methodname> method is available for final processing at the end of the kernel frame loop. This is a good place to do any data updates that are not dependent upon input data and cannot be overlapped with the rendering process (see the discussion on <methodname>vrj::App::intraFrame()</methodname> above).</para>
                  <section>
                     <title>Timing</title>
                     <para>This method is invoked after rendering has completed but before VR Juggler updates devices and other internal data.</para>
                  </section>
                  <section>
                     <title>Uses</title>
                     <para>Some possible uses of this method include <quote>cleaning up</quote> after the frame has been rendered or synchronizing with external networking or computational processes.</para>
                  </section>
               </section>
            </section>
         </section>
         <section id="draw-mgr-classes-sect">
            <title>Draw Manager-Specific Application Classes</title>
            <indexterm>
               <primary>Draw Manager</primary>
               <secondary>application classes</secondary>
            </indexterm>
            <para>Beyond the basic methods common to all applications, there are methods that are specific to a given Draw Manager. The application classes are extended for each of the specific Draw Managers. The graphics API-specific application classes derive from <classname>vrj::App</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::App</secondary>
               </indexterm> and extend this interface further. They add extra <quote>hooks</quote> that support the abilities of the specific API.</para>
            <section id="draw-mgr-classes-opengl-sect">
               <title>OpenGL Application Class</title>
               <indexterm zone="draw-mgr-classes-opengl-sect">
                  <primary>Draw Manager</primary>
                  <secondary>application classes</secondary>
                  <tertiary>OpenGL</tertiary>
               </indexterm>
               <para>The OpenGL application base class adds several methods to the application interface that allow rendering of OpenGL graphics. The extensions to the base <classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::App</secondary>
                  </indexterm> class are shown in <xref linkend="vjGlApp-class-diag"/>. In the following, we describe the method <methodname>vrj::GlApp::draw()</methodname>, the most important element of the interface. More details about the <classname>vrj::GlApp</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::GlApp</secondary>
                  </indexterm> class are provided in <xref linkend="ogl-app-sect"/>, found in <xref linkend="ch4"/>.</para>
               <figure float="1" id="vjGlApp-class-diag">
                  <title><classname>vrj::GlApp</classname> interface extensions to <classname>vrj::App</classname></title>
                  <mediaobject>
                     <imageobject>
                        <imagedata fileref="figures/userOglApp_hierarchy.png" format="PNG" align="center" scalefit="1"/>
                     </imageobject>
                  </mediaobject>
               </figure>
               <section>
                  <title><methodname>vrj::GlApp::draw()</methodname></title>
                  <para>The <quote>draw function</quote> is called by the OpenGL Draw Manager when it needs to render the current scene in an OpenGL graphics window. It is called for each active OpenGL context.</para>
               </section>
            </section>
            <section id="draw-mgr-classes-performer-sect">
               <title>OpenGL Performer Application Class</title>
               <indexterm zone="draw-mgr-classes-performer-sect">
                  <primary>Draw Manager</primary>
                  <secondary>application classes</secondary>
                  <tertiary>OpenGL Performer</tertiary>
               </indexterm>
               <para>The OpenGL Performer application base class adds interface functions that deal with the OpenGL Performer scene graph. Some of the interface extensions are shown in <xref linkend="vjPfApp-class-diag"/>. The following is a description of only two methods in the <classname>vrj::PfApp</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::PfApp</secondary>
                  </indexterm> interface. More detailed discussion on this class is provided in <xref linkend="pf-app-sect"/>, found in <xref linkend="ch4"/>.</para>
               <figure float="1" id="vjPfApp-class-diag">
                  <title><classname>vrj::PfApp</classname> interface extensions to <classname>vrj::App</classname></title>
                  <mediaobject>
                     <imageobject>
                        <imagedata fileref="figures/userPfApp_hierarchy.png" format="PNG" align="center" scalefit="1"/>
                     </imageobject>
                  </mediaobject>
               </figure>
               <section>
                  <title><methodname>vrj::PfApp::initScene()</methodname></title>
                  <para>The <methodname>initScene()</methodname> member function is called when the application should create the scene graph it will use.</para>
               </section>
               <section>
                  <title><methodname>vrj::PfApp::getScene()</methodname></title>
                  <para>The <methodname>getScene()</methodname> member function is called by the Performer Draw Manager when it needs to know what scene graph it should render for the application.</para>
               </section>
            </section>
         </section>
      </chapter>
      <chapter id="ch3">
         <title>Helper Classes</title>
         <para>Within this chapter, we present information on some helper classes that are provided with VR Juggler. These classes are intended to make it easier for application programmers to write their code. Ultimately, we want application programmers to focus more on compelling immersive content and less on the many details that are involved with 3D graphics programming. The classes presented in this chapter focus on mathematical computations and on input from hardware devices. VJ Juggler uses the Graphics Math Template Library or GMTL (http://ggt.sf.net/) for mathematical computation. An overview of the most commonly used GMTL data types and operations is presented here. In addition to the GMTL operations special attention is paid to the VR Juggler Input Manager device interfaces and proxies.</para>
         <section id="vjVec3-and-vjVec4-sect">
            <title>The <classname>gmtl::Vec</classname> Helper Class</title>
            <indexterm/>
            <indexterm>
               <primary></primary>
            </indexterm>
            <para>This section is intended to provide an introduction to how the helper class <classname>gmtl::Vec</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::Vec3</secondary>
                  <seealso>vrj::Vec3</seealso>
               </indexterm><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::Vec4</secondary>
                  <seealso>vrj::Vec4</seealso>
               </indexterm> works and how it can be used in VR Juggler applications. It begins with a high-level description of the classes which forms the necessary basis for understanding them in detail. Then, examples of how to use all the available operations in the interfaces for these classes are provided. It concludes with a description of the internal details of the classes.</para>
            <section>
               <title>High-Level Description</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>description of</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>description of</secondary>
               </indexterm>
               <para>The class <classname>gmtl::Vec</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::Vec3</secondary>
                  </indexterm> <indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::Vec4</secondary>
                  </indexterm> is designed to work the same way as a mathematical vector, typically of 3 or 4 dimensions. There are predefined vector types that would normally be used in a VR application that are provided for convenience. That is, a <classname>gmtl::Vec3f</classname> object can be thought of as a vector of the form &lt;x, y, z&gt;. Similarly, a <classname>gmtl::Vec4f</classname> can be thought of as a vector of the form &lt;x, y, z, w&gt;. An existing understanding of mathematical vectors is sufficient to know how these classes can be used. The question then becomes, how are they used? We will get to that later, and readers who have experience with vectors can skip ahead. If vectors are an unfamiliar topic, it may be convenient to think of these classes as three- and four-element C++ arrays of floats respectively. Most benefits of the vector concept are lost with that simpler idea, however. Therefore, if the reader needs to think of them as arrays, then arrays should probably be used until vectors feel more comfortable. Once the use of vectors seems familiar and straightforward, readers are encouraged to come back and read further.</para>
               <para>Vectors are typically used to contain spatial data or something similar. For convenience, however, they can be visualized as a more general-purpose container for numerical data upon which well-defined operations can be performed. There is no need to constrain thinking of them as only holding the coordinates for some point in space or some other limited-scope use. The GMTL vectors use by Juggler retain this generality and can be used wherever vectors come in handy.</para>
               <para><classname>gmtl::Vec3f</classname> and <classname>gmtl::Vec4f</classname>, as specific implementations of mathematical vectors, hide vector operations on single-precision floating-point numbers (<type>float</type>) behind a simple-to-use interface. For a single vector, the following standard vector operations are available:</para>
               <itemizedlist>
                  <listitem>
                     <para>Inversion (changing the sign of all elements)</para>
                  </listitem>
                  <listitem>
                     <para>Normalization</para>
                  </listitem>
                  <listitem>
                     <para>Calculation of length</para>
                  </listitem>
                  <listitem>
                     <para>Multiplication by a scalar</para>
                  </listitem>
                  <listitem>
                     <para>Division by a scalar</para>
                  </listitem>
                  <listitem>
                     <para>Conversion to a Performer vector</para>
                  </listitem>
               </itemizedlist>
               <para>For two vectors, the following operations can be performed:</para>
               <itemizedlist>
                  <listitem>
                     <para>Assignment</para>
                  </listitem>
                  <listitem>
                     <para>Equality/inequality comparison</para>
                  </listitem>
                  <listitem>
                     <para>Dot product</para>
                  </listitem>
                  <listitem>
                     <para>Cross product</para>
                  </listitem>
                  <listitem>
                     <para>Addition</para>
                  </listitem>
                  <listitem>
                     <para>Subtraction</para>
                  </listitem>
               </itemizedlist>
               <para>Knowing this and keeping in mind that <classname>gmtl::Vec3f</classname> and <classname>gmtl::Vec4f</classname> can be thought of at this high level, should make using them a snap.</para>
            </section>
            <section id="vjVec-use-sect">
               <title>Using <classname>gmtl::Vec3f</classname> and <classname>gmtl::Vec4f</classname></title>
               <indexterm zone="vjVec-use-sect">
                  <primary>classes</primary>
                  <secondary>vrj::Vec3</secondary>
               </indexterm>
               <indexterm zone="vjVec-use-sect">
                  <primary>classes</primary>
                  <secondary>vrj::Vec4</secondary>
               </indexterm>
               <para>With an understanding of these classes as standard mathematical vectors, it is time to learn how to deal with them at the C++ level. In some cases, the mathematical operators are overloaded to simplify user code; in other cases, a named method must be invoked on an object. Before any of that, however, make sure that the source file includes the <filename>gmtl/Vec.h</filename> header file. From here on, the available operations are presented in the order they were listed in the previous section. We begin with creating the objects and setting their values.</para>
            </section>
            <section id="vjVec-creation-sect">
               <title>Creating Vectors and Setting Their Values</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>creating</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>creating</secondary>
               </indexterm>
               <para>Before doing anything with vectors, some must be created. The examples here use <classname>gmtl::Vec3f</classname>, but the example is equally applicable to <classname>gmtl::Vec4f</classname>. To create a <classname>gmtl::Vec3f</classname>, use the default constructor which initializes the vector to &lt;0.0, 0.0, 0.0&gt;:</para>
               <programlisting>gmtl::Vec3f vec1;</programlisting>
               <para>After creating the vector <varname>vec1</varname>, its elements can be assigned values all at once as follows:</para>
               <programlisting>vec1.set(1.0, 1.5, -1.0);</programlisting>
               <para>or individually:</para>
               <programlisting>vec1[0] = 1.0;
vec1[1] = 1.5;
vec1[2] = -1.0;</programlisting>
               <para>Note that in the last example, the individual elements of the vector can be accessed exactly as with a normal array. To do the above steps all at once when the vector is created, give the element values when declaring the vector:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);</programlisting>
               <para>All of the above code has exactly the same results but accomplishes them in different ways. This flexibility is just one of the ways that GMTL vectors are more powerful than C++ arrays (of the same size, of course).</para>
            </section>
            <section id="vjVec-inversion-sect">
               <title>Inversion (Finding the Negative of a Vector)</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>inverting</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>inverting</secondary>
               </indexterm>
               <para>Once a vector is created, the simplest operation that can be performed on it is finding its inverse. The following code demonstrates just that:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = -vec1;</programlisting>
               <para>The vector vec2 now has the value &lt;-1.0, -1.5, 1.0&gt;. That is all there is to it. (Readers interested in details should note that the above does a copy operation to return the negative values.)</para>
            </section>
            <section>
               <title>Normalization</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>normalizing</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>normalizing</secondary>
               </indexterm>
               <para>Normalizing a vector is another simple operation (at the interface level anyway). The following code normalizes a vector:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

gmtl::normalize( vec1 );</programlisting>
               <para>The vector vec1 is now normalized. Clean and simple.</para>
               <para>Besides normalizing a given vector, a vector can be tested to determine if it has already been normalized. This is done as follows (assuming the vector <varname>vec</varname> has already been declared before this point):</para>
               <programlisting>if ( gmtl::isNormalized( vec1 ) )
{
   // Go here if vec is normalized
}</programlisting>
               <para></para>
            </section>
            <section>
               <title>Length Calculation</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>length of</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>length of</secondary>
               </indexterm>
               <para>Part of normalizing a vector requires finding its length first. To get a vector's length, do the following:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);
float length;

length = gmtl::length( vec1 );</programlisting>
               <para>In this case, length is assigned the value 2.061553 (or more accurately, the square root of 4.25). Finding the length of a vector appears simple from the programmer's perspective, but it has some hidden costs. Namely, it requires a square root calculation. For optimization purposes, we provide a method called <methodname>lengthSquared()</methodname> that returns the length of the vector without calculating the square root.</para>
            </section>
            <section>
               <title>Multiplication by a Scalar</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>multiplying by a scalar</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>multiplying by a scalar</secondary>
               </indexterm>
               <para>The GMTL vector classes provide an easy way to multiply a vector by a scalar. There are several ways to do it depending on what is required. Examples of each method follow.</para>
               <para>To multiply a vector by a scalar and store the result in another vector, do the following:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = 3 * vec1;</programlisting>
               <para>(The order of the factors in the multiplication can be swapped depending on preference or need.) Here, vec2 gets the value &lt;3.0, 4.5, -3.0&gt;.</para>
               <para>To multiply a vector by a scalar and store the result in the same vector, do the following:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

vec1 *= 3;</programlisting>
               <para>After this, vec1 has the value &lt;3.0, 4.5, -3.0&gt;.</para>
            </section>
            <section>
               <title>Division by a Scalar</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>dividing by a scalar</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>dividing by a scalar</secondary>
               </indexterm>
               <para>Very similar to multiplying by a scalar, division by scalars is also possible. While the examples are almost identical, they are provided here for clarity.</para>
               <para>To divide a vector by a scalar and store the result in another vector, do the following:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = vec1 / 3;</programlisting>
               <para>Here, vec2 gets the value &lt;0.333333, 0.5, -0.333333&gt;. Note that the scalar must come after the vector because the operation would not make sense otherwise.</para>
               <para>To divide a vector by a scalar and store the result in the same vector, do the following:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

vec1 /= 3;</programlisting>
               <para>After this, vec1 has the value &lt;0.333333, 0.5, -0.333333&gt;.</para>
            </section>
            <section id="pfVec-to-vjVec-sect">
               <title>Converting to an OpenGL Performer Vector</title>
               <indexterm zone="pfVec-to-vjVec-sect">
                  <primary>vrj::Vec3</primary>
                  <secondary>converting to pfVec3</secondary>
               </indexterm>
               <indexterm zone="pfVec-to-vjVec-sect">
                  <primary>pfVec3</primary>
                  <secondary>converting from vrj::Vec3</secondary>
                  <seealso>vrj::Vec3</seealso>
               </indexterm>
               <para>SGI's OpenGL Performer likes to work with its own <classname>pfVec3</classname> class, and to facilitate the use of it with <classname>gmtl::Vec3f</classname>, two conversion functions are provided for converting a <classname>gmtl::Vec3f</classname> to a <classname>pfVec3</classname> and vice versa. The first works as follows:</para>
               <programlisting>gmtl::Vec3f vj_vec;
pfVec3 pf_vec;

// Do stuff to vj_vec...

pf_vec = vrj::GetPfVec(vj_vec);</programlisting>
               <para> where vj_vec is passed by reference for efficiency. (pf_vec gets a copy of a <classname>pfVec3</classname>.) To convert a <classname>pfVec3</classname> to a <classname>gmtl::Vec3f</classname>, do the following:</para>
               <programlisting>pfVec3 pf_vec;
gmtl::Vec3f vj_vec;

// Do stuff to pf_vec...

vj_vec = vrj::GetVjVec(pf_vec);</programlisting>
               <para>Here again, pf_vec is passed by reference for efficiency, and vj_vec gets a copy of a <classname>gmtl::Vec3f</classname>. Both of these functions are found in the header <filename>vrj/Draw/Pf/PfUtil.h</filename>.</para>
            </section>
            <section>
               <title>Assignment</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>assigning</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>assigning</secondary>
               </indexterm>
               <para>We have already demonstrated vector assignment, though it was not pointed out explicitly. It works just as vector assignment in mathematics. The C++ code that does assignment is as follows:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = vec1;</programlisting>
               <para>After the assignment, vec2 has the value &lt;-1.0, -1.5, 1.0&gt;. Ta da! Note that this is a copy operation which is the case for all the types of assignments of GMTL vectors.</para>
            </section>
            <section>
               <title>Equality/Inequality Comparison</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>equality comparison</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>equality comparison</secondary>
               </indexterm>
               <para>To compare the equality of two vectors, there are three available methods (one is just the complement of the other, though):</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( gmtl::isEqual(vec1, vec2) )
{
   // Go here if vec1 and vec2 are equal.
}</programlisting>
               <para>or</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1 == vec2 )
{
   // Go here if vec1 and vec2 are equal.
}</programlisting>
               <para>or</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1 != vec2 )
{
   // Go here if vec1 and vec2 are not equal.
}</programlisting>
               <para>Choose whichever method is most convenient.</para>
            </section>
            <section>
               <title>Dot Product</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>dot product</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>dot product</secondary>
               </indexterm>
               <para>Given two vectors, finding the dot product is often needed. GMTL vectors provide a way to do this quickly so that programmers can save themselves the time of typing in the formula over and over. It works as follows:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);
float dot_product;

dot_product = gmtl::dot(vec1, vec2);</programlisting>
               <para>Now, dot_product has the value 4.0.</para>
            </section>
            <section>
               <title>Cross Product</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>cross product</secondary>
               </indexterm>
               <para>Besides the dot product of two vectors, the cross product is another commonly needed result. It is calculated thusly:</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = gmtl::cross(vec1, vec2);</programlisting>
               <para>The result is that vec3 gets a copy of vec1 cross vec2.</para>
            </section>
            <section>
               <title>Addition</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>adding</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>adding</secondary>
               </indexterm>
               <para>Adding two vectors can be done one of two ways. The first method returns a resulting vector, and the second method performs the addition and stores the result in the first vector.</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1 + vec2;</programlisting>
               <para>Now, vec3 has the value &lt;2.5, 2.5, -2.0&gt;.</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

vec1 += vec2;</programlisting>
               <para>This time, vec1 has the value &lt;2.5, 2.5, -2.0&gt;.</para>
            </section>
            <section>
               <title>Subtraction</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>subtracting</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>subtracting</secondary>
               </indexterm>
               <para>Subtracting two vectors gives the same options as addition, and while the code is nearly identical, it is provided for the sake of clarity.</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1 - vec2;</programlisting>
               <para>Now, vec3 has the value &lt;-0.5, 0.5, 0.0&gt;.</para>
               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

vec1 -= vec2;</programlisting>
               <para>In this case, vec1 has the value &lt;-0.5, 0.5, 0.0&gt;.</para>
            </section>
            <section>
               <title>Full Transformation by a Matrix</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>transforming by a matrix</secondary>
                  <tertiary>full</tertiary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>transforming by a matrix</secondary>
                  <tertiary>full</tertiary>
               </indexterm>
               <para>It is often helpful to apply a transformation to a vector. Transformations are represented by a matrix, so it is necessary to multiply a matrix and a vector. The method <methodname>xformFull()</methodname> does this job. For the following example, assume that there is a <classname>gmtl::Matrix44f</classname> transformation matrix <varname>xform_mat</varname>:</para>
               <programlisting>gmtl::Vec3f vec(1.0, 1.0, 1.0), result_vec;

gmtl::xform(result_vec, xform_mat, vec1);</programlisting>
               <para>Depending on the transformations contained within xform_mat, result_vec will be transformed fully. The operation as a mathematical equation would be:</para>
               <informalequation>
                  <mediaobject>
                     <imageobject>
                        <imagedata fileref="eq_v_eq_m_v.png" format="PNG"/>
                     </imageobject>
                     <textobject>
                        <phrase>V' = M * V</phrase>
                     </textobject>
                     <textobject role="tex">
                        <phrase>V^{\prime }=M*V</phrase>
                     </textobject>
                  </mediaobject>
               </informalequation>
               <para>where V and V' are vectors and M is a 4&times;4 transformation matrix.</para>
            </section>
            <section>
               <title>The Gory Details</title>
               <indexterm>
                  <primary>vrj::Vec3</primary>
                  <secondary>details</secondary>
               </indexterm>
               <indexterm>
                  <primary>vrj::Vec4</primary>
                  <secondary>details</secondary>
               </indexterm>
               <para>The details behind <classname>gmtl::Vec3f</classname> and <classname>gmtl::Vec4f</classname> really are not all that gory. Internally, they are represented as three- and four-element arrays of <type>float</type>s respectively. Access to these arrays is provided through the member function <varname>getData()</varname>. For example, this access can be used in the following way:</para>
               <programlisting>gmtl::Vec3f pos(4.0, 1.0982, 10.1241);

glVertex3fv(pos.getData());</programlisting>
               <para>Granted, this particular example is rather silly and much slower than just listing the values as the individual arguments to <function>glVertex3f()</function>, but it should get the point across.</para>
               <para>In general, the <varname>getData()</varname> member function should be treated very carefully. Access to it is provided mainly so that operations similar to this example can be performed quickly. An example of abusing access to <varname>getData()</varname> follows:</para>
               <programlisting>gmtl::Vec4f my_vec;

my_vec.getData()[0] = 4.0;
my_vec.getData()[1] = 1.0982;
my_vec.getData()[2] = 10.1241;
my_vec.getData()[3] = 1.0;</programlisting>
               <para>Do not do this. It can be confusing to readers of the code who do not necessarily need to know the details of the internal representation. Instead, use one of the methods described above for creating vectors and assigning the elements values.</para>
            </section>
         </section>
         <section>
            <title>The <classname>gmtl::Matrix44f</classname> Helper Class</title>
            <indexterm>
               <primary>vrj::Matrix</primary>
            </indexterm>
            <para>This section is intended to provide an introduction into how the helper class <classname>gmtl::Matrix44f</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::Matrix</secondary>
                  <seealso>vrj::Matrix</seealso>
               </indexterm> works and how it can be used in VR Juggler applications. It begins with a high-level description of the class, which forms the necessary basis for understanding it in detail. Then, examples of how to use all the available operations in the interfaces for the class are provided. It concludes with a description of the internal C++ details of <classname>gmtl::Matrix44f</classname>.</para>
            <section>
               <title>High-Level Description</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>description of</secondary>
               </indexterm>
               <para>Abstractly, <classname>gmtl::Matrix44f</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::Matrix</secondary>
                     <seealso>vrj::Matrix</seealso>
                  </indexterm> represents a 4&times;4 matrix of single-precision floating-point values. The class includes implementations of the standard matrix operations such as transpose, scale, and multiply. More specifically, it is a mechanism to facilitate common matrix operations used in computer graphics, especially those associated with a <emphasis>transform</emphasis> matrix. On the surface, it is nearly identical to a 4&times;4 C++ array of <type>float</type>s, but there is one crucial difference: a <classname>gmtl::Matrix44f</classname> keeps its internal matrix in column-major order rather than in row-major order<indexterm>
                     <primary>vrj::Matrix</primary>
                     <secondary>compared to C++ matrices</secondary>
                  </indexterm>. More detail on this is given below, but this is done because OpenGL maintains its internal matrices using the same memory layout. At the conceptual level, this does not matter&mdash;it is related only to the matrix representation in the computer's memory. Access to the elements is still in row-major order. In any case, understanding how C++ multidimensional arrays work means understanding 90% of what there is to know about <classname>gmtl::Matrix44f</classname>. The class provides a degree convenience not found with a normal C++ array, especially when programming with OpenGL. The complications surrounding the <classname>gmtl::Matrix44f</classname> class are identical to those with OpenGL matrix handling, and with an understanding of that, then all that is left to learn is the interface of <classname>gmtl::Matrix44f</classname>.</para>
               <para>As a representation of mathematical matrices, <classname>gmtl::Matrix44f</classname> implements several common operations performed on matrices to relieve the users of some tedious, repetitive effort. The general mathematical operations are:</para>
               <itemizedlist>
                  <listitem>
                     <para>Assignment</para>
                  </listitem>
                  <listitem>
                     <para>Equality/inequality comparison</para>
                  </listitem>
                  <listitem>
                     <para>Transposing</para>
                  </listitem>
                  <listitem>
                     <para>Finding the inverse</para>
                  </listitem>
                  <listitem>
                     <para>Addition</para>
                  </listitem>
                  <listitem>
                     <para>Subtraction</para>
                  </listitem>
                  <listitem>
                     <para>Multiplication</para>
                  </listitem>
                  <listitem>
                     <para>Scaling by a scalar value</para>
                  </listitem>
               </itemizedlist>
               <para>The operations well-suited for use with computer graphics are:</para>
               <itemizedlist>
                  <listitem>
                     <para>Creating an identity matrix quickly</para>
                  </listitem>
                  <listitem>
                     <para>Zeroing a matrix in a single step</para>
                  </listitem>
                  <listitem>
                     <para>Creating an XYZ, a ZYX, or a ZXY Euler rotation matrix</para>
                  </listitem>
                  <listitem>
                     <para>Constraining rotation about a specific axis or axes</para>
                  </listitem>
                  <listitem>
                     <para>Making a matrix using direction cosines</para>
                  </listitem>
                  <listitem>
                     <para>Making a matrix from a quaternion</para>
                  </listitem>
                  <listitem>
                     <para>Making a rotation transformation matrix about a single axis</para>
                  </listitem>
                  <listitem>
                     <para>Making a translation transformation matrix</para>
                  </listitem>
                  <listitem>
                     <para>Making a scale transformation matrix</para>
                  </listitem>
                  <listitem>
                     <para>Extracting specific transformation information</para>
                  </listitem>
                  <listitem>
                     <para>Converting to an OpenGL Performer matrix</para>
                  </listitem>
               </itemizedlist>
               <para>What is presented here involves some complicated concepts that are far beyond the scope of this documentation. Without an understanding of matrix math (linear algebra) and an understanding of how transformation matrices work in OpenGL, this document will not be very useful. It is highly recommended that readers be familiar with these topics before proceeding. Otherwise, with this high-level description in mind, we now continue on to explain the <classname>gmtl::Matrix44f</classname> class at the C++ level.</para>
            </section>
            <section>
               <title>Using <classname>gmtl::Matrix44f</classname></title>
               <indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::Matrix</secondary>
               </indexterm>
               <para>Keeping the idea of a normal mathematical matrix in mind, we are now ready to look at the C++ use of the <classname>gmtl::Matrix44f</classname> class. Most of the interface is defined using methods, but there are a few cases where mathematical operators have been overloaded to make code easier to read. Before going any further, whenever using a <classname>gmtl::Matrix44f</classname>, make sure to include <filename>gmtl/Matrix.h</filename> first. The operations presented above are now described in detail in the order in which they were listed above. We begin with creating the objects and setting their values.</para>
            </section>
            <section>
               <title>Creating Matrices and Setting Their Values</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>creating</secondary>
               </indexterm>
               <para>Before doing anything with matrices, some must be created first. To create a <classname>gmtl::Matrix44f</classname>, the default constructor can be used. It initializes the matrix to be an identity matrix:</para>
               <programlisting>gmtl::Matrix44f mat1;</programlisting>
               <para>After creating this matrix <varname>mat1</varname>, its 16 elements can be assigned values all at once as follows:</para>
               <programlisting>mat1.set(0.0, 1.0, 2.3, 4.1,
         8.3, 9.0, 2.2, 1.0,
         5.6, 9.9, 9.7, 8.2,
         3.8, 0.9, 2.1, 0.1);</programlisting>
               <para>or with a <type>float</type> array:</para>
               <programlisting>float mat_vals[16] =
{
   0.0, 8.3, 5.6, 3.8,
   1.0, 9.0, 9.9, 0.9,
   2.3, 2.2, 9.7, 2.1,
   4.1, 1.0, 1.0, 0.1
};

mat1.set(mat_vals);</programlisting>
               <para>Note that when explicitly listing the values with <methodname>set()</methodname>, they are specified in <emphasis>row-major</emphasis> order. When put into a 16-element array of <type>float</type>s, however, they must be ordered so that they can be copied into the <classname>gmtl::Matrix44f</classname> in <emphasis>column-major</emphasis> order. This is the one exception in the interface where access is column-major (which probably means that the interface has a bug).</para>
               <para>To set all the values of a new matrix in one step, they can be given as arguments when declaring the matrix:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);</programlisting>
               <para>All of the above code has exactly the same results but accomplishes those results in different ways.</para>
               <para>To read the elements in a <classname>gmtl::Matrix44f</classname> object, programmers can use either the overloaded [] operator or the overloaded () operator. The overloaded [] operator returns the specified row of the <classname>gmtl::Matrix44f</classname>, and an element in that row can then be read using [] again. The code looks exactly the same as with a normal C++ two-dimensional array:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);
float val;

val = mat1[3][0];</programlisting>
               <para>Here, <varname>val</varname> is assigned the value 3.8. Using the overloaded () operator results in code that looks similar to the way the matrix element would be referenced in mathematics:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);
float val;

val = mat1(3, 0);</programlisting>
               <para>Again, <varname>val</varname> is assigned the value 3.8. Both of these operations are row-major.</para>
            </section>
            <section>
               <title>Assignment</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>assigning</secondary>
               </indexterm>
               <para>Assigning one <classname>gmtl::Matrix44f</classname> to another happens using the normal = operator as follows:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2;

mat2 = mat1;</programlisting>
               <para>This makes a <emphasis>copy</emphasis> of <varname>mat1</varname> in <varname>mat2</varname> which can be a slow operation.</para>
            </section>
            <section>
               <title>Equality/Inequality Comparison</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>equality comparison</secondary>
               </indexterm>
               <para>To compare the equality of two matrices, there are three available methods (one is just the complement of the other, though):</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( gmtl::isEqual(mat1, mat2) )
{
   // Go here if mat1 and mat2 are equal.
}</programlisting>
               <para>or</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( mat1 == mat2 )
{
   // Go here if mat1 and mat2 are equal.
}</programlisting>
               <para>or</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( mat1 != mat2 )
{
   // Go here if mat1 and mat2 are not equal.
}</programlisting>
               <para>Choose whichever method is most convenient.</para>
            </section>
            <section>
               <title>Transposing</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>transposing</secondary>
               </indexterm>
               <para>The transpose operation works conceptually as <inlineequation>
                     <inlinemediaobject>
                        <imageobject>
                           <imagedata fileref="eq_m1_eq_tr_m2.png" format="PNG"/>
                        </imageobject>
                        <textobject>
                           <phrase>matrix1 = transpose(matrix2)</phrase>
                        </textobject>
                        <textobject role="tex">
                           <phrase>matrix_{1}=transpose\left( matrix_{2}\right)</phrase>
                        </textobject>
                     </inlinemediaobject>
                  </inlineequation>. The code is then:</para>
               <programlisting>gmtl::Matrix44f mat1;
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::transpose(mat1, mat2);</programlisting>
               <para>The result is stored in mat1. mat2 is passed by reference for efficiency.</para>
            </section>
            <section>
               <title>Finding the Inverse</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>inverting</secondary>
               </indexterm>
               <para>The inverse operation works conceptually as <inlineequation>
                     <inlinemediaobject>
                        <imageobject>
                           <imagedata fileref="eq_m1_eq_inv_m2.png" format="PNG"/>
                        </imageobject>
                        <textobject>
                           <phrase>matrix1 = inverse(matrix2)</phrase>
                        </textobject>
                        <textobject role="tex">
                           <phrase>matrix_{1}=inverse\left( matrix_{2}\right)</phrase>
                        </textobject>
                     </inlinemediaobject>
                  </inlineequation>. The code is then:</para>
               <programlisting>gmtl::Matrix44f mat1;
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::invert(mat1, mat2);</programlisting>
               <para>The result is stored in mat1. mat2 is passed by reference for efficiency.</para>
            </section>
            <section>
               <title>Addition</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>adding</secondary>
               </indexterm>
               <para>For the addition operation, the interface is defined so that the sum of two matrices is stored in a third. There are two ways to do addition with <classname>gmtl::Matrix44f</classname>: using the add() method or using the overloaded + operator. Use of the former is recommended, but the latter can be used if one prefers that style of programming. Examples of both methods follow. The first block of code only declares the <classname>gmtl::Matrix44f</classname> objects.</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>
               <para>Using the <methodname>add()</methodname> method:</para>
               <programlisting>gmtl::add(mat3, mat1, mat2);</programlisting>
               <para>Using the overloaded + operator:</para>
               <programlisting>mat3 = mat1 + mat2;</programlisting>
               <para>The result is stored (via a copy) in mat3.</para>
            </section>
            <section>
               <title>Subtraction</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>subtracting</secondary>
               </indexterm>
               <para>For the subtraction operation, the interface is defined so that the difference of two matrices is stored in a third. There are two ways to do subtraction with <classname>gmtl::Matrix44f</classname>: using the <methodname>sub()</methodname> method or using the overloaded - operator. It is recommended that developers use the former, but the latter can be used for stylistic purposes. Examples of both methods follow. The first block of code only declares the <classname>gmtl::Matrix44f</classname> objects.</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>
               <para>Using the <methodname>sub()</methodname> method:</para>
               <programlisting>gmtl::sub(mat3, mat1, mat2);</programlisting>
               <para>Using the overloaded - operator:</para>
               <programlisting>mat3 = mat1 - mat2;</programlisting>
               <para>The result is stored (via a copy) in mat3.</para>
            </section>
            <section>
               <title>Multiplication</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>multiplying</secondary>
               </indexterm>
               <para>As in the case of addition and subtraction, the multiplication interface is defined so that the product of two matrices is stored in a third. This is likely to be the operation used most often since transformation matrices are constructed through multiplication of different transforms. For normal matrix multiplication, there are two ways to do multiplication with <classname>gmtl::Matrix44f</classname>: using the <methodname>mult()</methodname> method or using the overloaded * operator. We recommend the use of the <methodname>mult()</methodname>method, but the overloaded * operator can be used by those who prefer that style of programming. Examples of both methods follow. The first block of code only declares the <classname>gmtl::Matrix44f</classname> objects.</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                    5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>
               <para>Using the <methodname>mult()</methodname> method:</para>
               <programlisting>gmtl::mult(mat3, mat1, mat2);</programlisting>
               <para>Using the overloaded * operator:</para>
               <programlisting>mat3 = mat1 * mat2;</programlisting>
               <para>The result is stored (via a copy) in mat3.</para>
               <para>There are two more multiplication operations provided that help in handling the order of the matrices when they are multiplied. These two extra operations do post-multiplication and pre-multiplication of two matrices. An example of post-multiplication is:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::postMult(mat1, mat2);</programlisting>
               <para>Conceptually, the operation is <inlineequation>
                     <inlinemediaobject>
                        <imageobject>
                           <imagedata fileref="eq_m1_eq_m1_m2.png" format="PNG"/>
                        </imageobject>
                        <textobject>
                           <phrase>mat1 = mat1 * mat2</phrase>
                        </textobject>
                        <textobject role="tex">
                           <phrase>mat_{1}=mat_{1}*mat_{2}</phrase>
                        </textobject>
                     </inlinemediaobject>
                  </inlineequation> so that the second matrix (<varname>mat2</varname>) comes as the second factor. The same result can be achieved using the overloaded *= operator:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

mat1 *= mat2;</programlisting>
               <para>An example of pre-multiplication is:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::preMult(mat1, mat2);</programlisting>
               <para>Here, the conceptual operation is <inlineequation>
                     <inlinemediaobject>
                        <imageobject>
                           <imagedata fileref="eq_m1_eq_m2_m1.png" format="PNG"/>
                        </imageobject>
                        <textobject>
                           <phrase>mat1 = mat2 * mat1</phrase>
                        </textobject>
                        <textobject role="tex">
                           <phrase>mat_{1}=mat_{2}*mat_{1}</phrase>
                        </textobject>
                     </inlinemediaobject>
                  </inlineequation> so that the second matrix (<varname>mat2</varname>) comes as the first factor. In both cases, the result of the multiplication is stored in <varname>mat1</varname>.</para>
            </section>
            <section>
               <title>Scaling by a Scalar Value</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>scaling</secondary>
               </indexterm>
               <para>Scaling the values of a matrix by a scalar value can be done using two different methods: the <methodname>setScale()</methodname> method or the overloaded * and / operators that take a single scalar value and returns a <classname>gmtl::Matrix44f</classname>. As with the preceding operations, we recommend the use of the former, but the latter is available for those who want it. Examples of both methods follow. First, using the <methodname>setScale()</methodname> method works as:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);


gmtl::setScale(mat1, 3.0);</programlisting>
            </section>
            <section>
               <title>Making an Identity Matrix Quickly</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>making</secondary>
                  <tertiary>identity</tertiary>
               </indexterm>
               <para>In computer graphics, an identity matrix is often needed when performing transformations. Because of this, <classname>gmtl::Matrix44f</classname> provides a method for converting a matrix into an identity matrix in a single step (at the user code level anyway):</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::identity(mat1);</programlisting>
               <para>Of course, simply declaring mat1 with no arguments would achieve the same result, but that is not such an interesting example.</para>
            </section>
            <section>
               <title>Zeroing a Matrix in a Single Step</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>zeroing</secondary>
               </indexterm>
               <para>Before using a matrix, it is often helpful to zero it out to ensure that there is no pollution from previous use. With a <classname>gmtl::Matrix44f</classname>, this can be done in one step:</para>
               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::zero(mat1);</programlisting>
               <para>The result is that all elements of mat1 are now 0.0.</para>
            </section>
            <section>
               <title>Making an XYZ, a ZYX, or a ZXY Euler Rotation Matrix</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>making</secondary>
                  <tertiary>Euler rotation</tertiary>
               </indexterm>
               <para>All the rotation information for a transform can be contained in a single matrix using the methods for making an XYZ, a ZYX, or a ZXY Euler matrix. Code for all three follows:</para>
               <programlisting>vrj::Matrix mat1;
float x_rot = 0.4, y_rot = 0.541, z_rot = 0.14221;

gmtl::setRot( mat1, gmtl::EulerAngleXYZf(x_rot, y_rot, z_rot));
gmtl::setRot( mat1, gmtl::EulerAngleZYXf(z_rot, y_rot, x_rot));
gmtl::setRot( mat1, gmtl::EulerAngleZXYf(z_rot, x_rot, y_rot));
</programlisting>
               <para>In every case, the matrix is zeroed before the rotation transformation is stored. The result of the above code is that <varname>mat1</varname> is a ZXY Euler rotation matrix. The previous two operations are destroyed.</para>
            </section>
            <section>
               <title>Making a Translation Transformation Matrix</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>making</secondary>
                  <tertiary>translation transformation</tertiary>
               </indexterm>
               <para>To make a translation matrix, there are two methods with each having two different types of arguments specifying the translation. The first makes a matrix with only the given translation (all other transformation information is destroyed):</para>
               <programlisting>gmtl::Matrix44f mat;
gmtl::Vec3f trans(4.0, -4.231, 1.0);

mat = gmtl::makeTrans&lt;gmtl::Matrix44f&gt;(trans);</programlisting>
               <para>To <emphasis>change</emphasis> the translation of a transformation matrix without completely obliterating all other transformations, use the following instead:</para>
               <programlisting>gmtl::Vec3f trans(4.0, -4.231, 1.0);

gmtl::setTrans(mat, trans);</programlisting>
            </section>
            <section>
               <title>Making a Scale Transformation Matrix</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>making</secondary>
                  <tertiary>scale transformation</tertiary>
               </indexterm>
               <para>To make a transformation matrix that only scales, a simple method is provided. It works as follows:</para>
               <programlisting>gmtl::Matrix44f mat;
gmtl::Vec3f scale( 1.5, 1.5, 1.5 );

mat = gmtl::makeScale&lt;Matrix44f&gt;(scale);</programlisting>
               <para>The result is that mat is a transformation matrix that will perform a scale operation. In this specific case, the scaling happens uniformly for x, y, and z.</para>
            </section>
            <section>
               <title>Extracting Specific Transformation Information</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>extracting transformation information</secondary>
               </indexterm>
               <para>Finally, methods are provided for extracting transformations from a given matrix. The individual rotations and the translation can be read. For the following examples, assume that <varname>mat</varname> is a <classname>gmtl::Matrix44f</classname> object representing arbitrary translation, rotation, and scaling transformations. To get the Z-axis rotation information (an Euler angle), use the following:</para>
               <programlisting>float z_rot = (gmtl::makeRot&lt;gmtl::EulerAngleXYZf&gt;(mat))[2];</programlisting>
               <para>The value return is in radians. We can also get the X-axis rotation.</para>
               <programlisting></programlisting>
               <programlisting>float x_rot = (gmtl::makeRot&lt;gmtl::EulerAngleXYZf&gt;(mat))[0];</programlisting>
               <para>Getting translations is even simpler because translations are collected into a single vector easily. </para>
               <programlisting>gmtl::Vec3f trans;
gmtl::setTrans(trans, mat);</programlisting>
               <para>After this, the translation in <varname>mat</varname> is stored in trans. The same can be done with a Vec4f instead of the Vec3f.</para>
            </section>
            <section>
               <title>Converting to an OpenGL Performer Matrix</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>converting to pfMatrix</secondary>
               </indexterm>
               <indexterm>
                  <primary>pfMatrix</primary>
                  <secondary>converting from vrj::Matrix</secondary>
                  <seealso>vrj::Matrix</seealso>
               </indexterm>
               <para>SGI's OpenGL Performer likes to work with its own <classname>pfMatrix</classname> class, and to facilitate the use of it with <classname>gmtl::Matrix44f</classname>, two conversion functions are provided for making conversions. The first works as follows:</para>
               <programlisting>gmtl::Matrix44f vj_mat;
pfMatrix pf_mat;

// Perform operations on vj_mat...

pf_mat = vrj::GetPfMatrix(vj_mat);</programlisting>
               <para>where vj_mat is passed by reference for efficiency. (pf_mat gets a copy of a <classname>pfMatrix</classname> which is a slow operation.) To convert a <classname>pfMatrix</classname> to a <classname>gmtl::Matrix44f</classname>, do the following:</para>
               <programlisting>pfMatrix pf_mat;
gmtl::Matrix44f vj_mat;

// Perform operations on pf_mat...

vj_mat = vrj::GetVjMatrix(pf_mat);</programlisting>
               <para>Here again, pf_matis passed by reference for efficiency, and vj_mat gets a copy of a <classname>gmtl::Matrix44f</classname>. Both of these functions are found in the header <filename>vrj/Draw/Pf/PfUtil.h</filename>.</para>
            </section>
            <section>
               <title>The Gory Details</title>
               <indexterm>
                  <primary>vrj::Matrix</primary>
                  <secondary>details</secondary>
               </indexterm>
               <para>Now it is time for the really nasty part. Reading this could cause difficulty in understanding the overwhelming amount of information just presented. Do not read any further unless you absolutely have to or you just like to confuse yourself.</para>
               <para>C, C++, and mathematics use matrices in row-major order. Access indices are shown in <xref linkend="Row-maj-table"/></para>
               <table id="Row-maj-table">
                  <title>Row-major access indices</title>
                  <tgroup cols="5" colsep="1" rowsep="1" align="left">
                     <tbody>
                        <row>
                           <entry align="center">(0,0)</entry>
                           <entry align="center">(0,1)</entry>
                           <entry align="center">(0,2)</entry>
                           <entry align="center">(0,3)</entry>
                           <entry>&lt;--- Array</entry>
                        </row>
                        <row>
                           <entry align="center">(1,0)</entry>
                           <entry align="center">(1,1)</entry>
                           <entry align="center">(1,2)</entry>
                           <entry align="center">(1,3)</entry>
                           <entry>&lt;--- Array</entry>
                        </row>
                        <row>
                           <entry align="center">(2,0)</entry>
                           <entry align="center">(2,1)</entry>
                           <entry align="center">(2,2)</entry>
                           <entry align="center">(2,3)</entry>
                           <entry>&lt;--- Array</entry>
                        </row>
                        <row>
                           <entry align="center">(3,0)</entry>
                           <entry align="center">(3,1)</entry>
                           <entry align="center">(3,2)</entry>
                           <entry align="center">(3,3)</entry>
                           <entry>&lt;--- Array</entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <para>OpenGL ordering specifies that the matrix has to be column-major in memory. Thus, to provide programmers with a way to pass a transformation matrix to OpenGL in one step (via <function>glMultMatrixf()</function>), the <classname>gmtl::Matrix44f</classname> class maintains its internal matrix in column-major order. Note that in the following table, the given indices are what the cells have to be called in C/C++ notation because we are putting them back-to-back. This is illustrated in <xref linkend="Col-maj-table"/>.</para>
               <table id="Col-maj-table">
                  <title>Column-major access indices</title>
                  <tgroup cols="4" colsep="1" rowsep="1" align="left">
                     <tbody>
                        <row>
                           <entry align="center">(0,0)</entry>
                           <entry align="center">(1,0)</entry>
                           <entry align="center">(2,0)</entry>
                           <entry align="center">(3,0)</entry>
                        </row>
                        <row>
                           <entry align="center">(0,1)</entry>
                           <entry align="center">(1,1)</entry>
                           <entry align="center">(2,1)</entry>
                           <entry align="center">(3,1)</entry>
                        </row>
                        <row>
                           <entry align="center">(0,2)</entry>
                           <entry align="center">(1,2)</entry>
                           <entry align="center">(2,2)</entry>
                           <entry align="center">(3,2)</entry>
                        </row>
                        <row>
                           <entry align="center">(0,3)</entry>
                           <entry align="center">(1,3)</entry>
                           <entry align="center">(2,3)</entry>
                           <entry align="center">(3,3)</entry>
                        </row>
                        <row>
                           <entry align="center">^</entry>
                           <entry align="center">^</entry>
                           <entry align="center">^</entry>
                           <entry align="center">^</entry>
                        </row>
                        <row>
                           <entry align="center">Array</entry>
                           <entry align="center">Array</entry>
                           <entry align="center">Array</entry>
                           <entry align="center">Array</entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <para>As mentioned, all of this is done so that a given <classname>gmtl::Matrix44f</classname> that acts as a full transformation matrix can be passed to OpenGL directly (more or less)<indexterm>
                     <primary>vrj::Matrix</primary>
                     <secondary>using with OpenGL</secondary>
                  </indexterm>. For example, with a given <classname>gmtl::Matrix44f</classname> object <varname>mat</varname> upon which painstaking transformations have been performed, the following can be done:</para>
               <programlisting>glMultMatrixf(mat.getData());</programlisting>
               <para>That could not be simpler. All the transformation efforts have culminated into one statement.</para>
               <para>For further information, the best possible source of information, especially for this class, is the header file. Read it; understand it; love it.</para>
            </section>
         </section>
         <section id="vjDeviceInterface-section">
            <title>The <classname>gadget::DeviceInterface</classname> Helper Class</title>
            <indexterm>
               <primary>gadget::DeviceInterface</primary>
            </indexterm>
            <para>The concept of device interfaces in VR Juggler is one which often causes confusion for new users. Two object-oriented design patterns are combined by <classname>gadget::DeviceInterface</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>gadget::DeviceInterface</secondary>
                  <seealso>gadget::DeviceInterface</seealso>
               </indexterm>: smart pointers and proxies. Within this section, we aim to explain VR Juggler device interfaces clearly and simply. We begin with a high-level description and then move right into using the class.</para>
            <section>
               <title>High-Level Description</title>
               <indexterm>
                  <primary>gadget::DeviceInterface</primary>
                  <secondary>description of</secondary>
               </indexterm>
               <para>Physical devices are never accessed directly by VR Juggler applications<indexterm>
                     <primary>applications</primary>
                     <secondary>device access</secondary>
                  </indexterm>. Instead, the applications are granted access to the device through a <firstterm>proxy</firstterm><indexterm>
                     <primary>proxy</primary>
                     <secondary>application-level access</secondary>
                  </indexterm>. A proxy is nothing more than an intermediary who forwards information between two parties<indexterm>
                     <primary>proxy</primary>
                     <secondary>definition of</secondary>
                  </indexterm>. In this case, the two parties are a VR Juggler application and an input device. The application makes requests on the input device through the proxy.</para>
               <para>The class <classname>gadget::DeviceInterface</classname> is designed to be a wrapper class around the proxies. Applications could use the proxy classes directly, but <classname>gadget::DeviceInterface</classname> and its subclasses simplify use of the proxy object they contain. Thus, typical VR Juggler application objects will have one or more device interface member variables.</para>
               <para>In the application object, a device interface member variable is used as a <firstterm>smart pointer</firstterm><indexterm>
                     <primary>smart pointer</primary>
                  </indexterm> to the proxy. In C++, a smart pointer is not usually an actual object pointer. Instead, the class acting as a smart pointer overloads the dereference operator -&gt; so that a special action can be taken when the <quote>pointer</quote> is dereferenced. The dereference operator is just another operator like the addition and subtraction operators, and overloading the deference operator allows some <quote>magic</quote> to occur behind the scenes. On the surface, the code looks exactly the same as a normal pointer dereference, and in most cases, people reading and writing the code can think of the smart pointer as a standard pointer. It may also be convenient to think of a smart pointer as a handle.</para>
               <para>With that background, we can move on to explain how <classname>gadget::DeviceInterface</classname> uses these concepts. First, know that <classname>gadget::DeviceInterface</classname> is a base class for all other device interface classes such as digital interfaces (wand buttons), position interfaces (wands, a tracked user's head), etc. In user code, there will be instances of objects such as <classname>gadget::DigitalInterface</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>gadget::DigitalInterface</secondary>
                  </indexterm>, <classname>gadget::PositionInterface</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>gadget::PositionInterface</secondary>
                  </indexterm>, <classname>gadget::KeyboardInterface</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>gadget::KeyboardInterface</secondary>
                  </indexterm>, and the like. Once they are properly initialized, device interface objects (whatever their types may be) will act as smart pointers to the actual VR Juggler proxy objects they wrap.</para>
               <para>All the subclasses of <classname>gadget::DeviceInterface</classname> encapsulate a pointer to a VR Juggler proxy object. (Remember that these proxy objects act as an intermediary between the application and an input device.) The subclasses also overload the dereference operator -&gt; which allows them to act as smart pointers. The dereference operator on a device interface object gives access to the object's hidden proxy pointer. With that access, the methods of the encapsulated proxy object can be invoked, usually to read data. The end result is that user applications get access to the proxy objects they need but through a simpler interface than using the proxies directly<indexterm>
                     <primary>device proxies</primary>
                     <secondary>access through device interfaces</secondary>
                     <seealso>gadget::DeviceInterface</seealso>
                  </indexterm>.</para>
               <para>At this point, it is perfectly reasonable to wonder why VR Juggler uses a concept that requires all sorts of documentation and explanation. The extra effort is worth it because it allows VR Juggler to hide the actual type of the device being used. There is no need to know that some specific VR system uses a wireless mouse connected to a PC reading bytes from a PS/2 port that represent button presses. All that matters is knowing which buttons are pressed at a given instant. The class <classname>gadget::DigialInterface</classname> gives exactly that information, and it quietly hides the messiness of dealing with that crazy mouse, its ugly driver, and its overly complex protocol.</para>
            </section>
            <section>
               <title>Using <classname>gadget::DeviceInterface</classname></title>
               <indexterm>
                  <primary>classes</primary>
                  <secondary>gadget::DeviceInterface</secondary>
               </indexterm>
               <para>VR Juggler applications do not usually use <classname>gadget::DeviceInterface</classname> directly. Instead, the subclasses mentioned above will be used. Within this section, we will refer to subclasses of <classname>gadget::DeviceInterface</classname> as <quote>device interfaces</quote>. The high-level description has already made use of this convention.</para>
               <para>Before using a device interface, some objects must be declared. Programmers must choose the type that is appropriate for the type of devices relevant to a given application. All device interface objects must be initialized in the application object's <methodname>init()</methodname> method<indexterm>
                     <primary>device interfaces</primary>
                     <secondary>initialization of</secondary>
                  </indexterm>. Each device interface object inherits a method called <methodname>init()</methodname> from <classname>gadget::DeviceInterface</classname>. This method takes a single string argument naming the proxy to which the interface will connect. Example names are <quote>VJHead</quote>, <quote>VJWand</quote>, <quote>VJButton0</quote>, and <quote>VJAccelerate</quote><indexterm>
                     <primary>device aliases</primary>
                     <secondary>examples of</secondary>
                  </indexterm>. These are all symbolic names specified in VR Juggler configuration files. This makes them easier to remember, and it also contributes to hiding the details about the physical device. With this system, no one needs to care how transformation information from the user's head is generated. VR Juggler cares, but there is no need for it to tell anyone else. All developers care about is the head transformation matrix. An example of initializing a <classname>gadget::PositionInterface</classname> that connects with the user head proxy is:</para>
               <programlisting>gadget::PositionInterface head;

head.init("VJHead");</programlisting>
               <para>Remember that this is to be done in an application object's <methodname>init()</methodname> method. The actual object used would be a member variable of the application class. Note that here, the normal syntax for calling the method of a C++ object is used rather than using the dereference operator. Until it is initialized, the device interface object cannot act as a smart pointer.</para>
               <para>Once device interface objects are all initialized and ready to use, it is time to start using them as smart pointers<indexterm>
                     <primary>device interfaces</primary>
                     <secondary>as smart pointers</secondary>
                     <seealso>smart pointer</seealso>
                  </indexterm>. This is best part! VR Juggler is already working hard in the background to update device proxies, and the application is free to access them. (It is usually best to reference them in the <methodname>preFrame()</methodname> method, but this may not necessarily be true for all proxies.) Continuing with our example of a <classname>gadget::PositionInterface</classname> to the user head proxy, the following code shows how to read the transformation matrix for the user's head: </para>
               <programlisting>gmtl::Matrix44f* head_mat;

head_mat = head-&gt;getData();</programlisting>
               <para>But wait, that was easy! Believe it or not, the code really is that simple. Simply use the overloaded dereference operator to get access to the position proxy object hidden in <classname>gadget::PositionInterface</classname> to read data from the proxy. Of course, we have not explained the <methodname>getData()</methodname> method at all yet. That comes from the position proxy class, and that is documented elsewhere.</para>
            </section>
            <section>
               <title>The Gory Details</title>
               <indexterm>
                  <primary>gadget::DeviceInterface</primary>
                  <secondary>details</secondary>
               </indexterm>
               <para>What is truly amazing about VR Juggler device interfaces is, despite their seeming complexity, there is really nothing to them. Trying to trace through the source code is a little tricky, but conceptually, it is all about pointers. Keep in mind that all this documentation was written using nothing more than the header files as a reference.</para>
               <para>As mentioned, the class <classname>gadget::DeviceInterface</classname> is a base class for all the specific types of device interfaces such as positional interfaces, digital interfaces, and analog interfaces. This class maintains the name of the proxy and the proxy index, and it provides the all-important <methodname>init()</methodname> method, but it is up to the inheriting classes to handle the proxy pointer and to overload the dereference operator.</para>
               <para>Subclasses of <classname>gadget::DeviceInterface</classname> are used to provide the wrapper to a specific type of proxy<indexterm>
                     <primary>gadget::DeviceInterface</primary>
                     <secondary>subclasses of</secondary>
                  </indexterm>. They each contain a pointer to a proxy object of the same conceptual type (positional, digital, and so on). The way in which the dereference operator is overloaded can vary from class to class, but the end result is always the same: a pointer to the proxy is returned so that the calling code has access to that proxy.</para>
               <para>The beauty of it all is that the proxy object being pointed to by the device interface can be changed without affecting the execution of the user application. In other words, the proxies can be changed at run time to point to different <emphasis>physical</emphasis> devices. All the while, the user code is still using the smart pointer interface and getting data of some sort. This flexibility is one of the most important features of VR Juggler, and it is important to understand.</para>
            </section>
         </section>
         <section id="vjProxy-section">
            <title>The <classname>gadget::Proxy</classname> Helper Class</title>
            <indexterm>
               <primary>gadget::Proxy</primary>
            </indexterm>
            <para>This whole proxy scheme can be confusing. We admit that it makes the learning curve for VR Juggler a little steeper, but once you get it, you will know it all. An alternate title for this section is <quote>Horton Hears a Proxy.</quote> In this case, Horton is VR Juggler (it is rather elephant-like at times), and the complexity of dealing with these ethereal, ubiquitous proxies causes VR Juggler to take a lot of guff. This section presents the <classname>gadget::Proxy</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>gadget::Proxy</secondary>
                  <seealso>gadget::Proxy</seealso>
               </indexterm> class, the base class for the input proxies, making it the one that is used the most. It should be noted, however, that the concept is spreading to other parts of VR Juggler because it is so useful. While this is only the introduction, we will give you the moral of the story now: proxies are important concepts, and you should not step on them.</para>
            <section>
               <title>High-Level Description</title>
               <indexterm>
                  <primary>gadget::Proxy</primary>
                  <secondary>description of</secondary>
               </indexterm>
               <para>The class <classname>gadget::Proxy</classname> is the base class for all the proxies in the VR Juggler Input Manager. A better name would be <classname>gadget::InputProxy</classname>, and it may help to think of it with that name. As a programmer of VR Juggler applications, knowledge of such proxies does not have to be terribly in-depth. The fact is, most VR Juggler programmers will probably never need to know more about a specific device proxy's interface than the return type of its <methodname>getData()</methodname> method. Most of the apparent complexity in the specific device proxy classes is only important to VR Juggler's internal maintenance of the active proxies.</para>
               <para>That said, this section is relatively short. As a programmer, the important thing to know is that a proxy is a pointer to a physical device<indexterm>
                     <primary>gadget::Proxy</primary>
                     <secondary>as pointer to physical device</secondary>
                  </indexterm>. Application programmers use the higher level device interface as the mechanism to read data in some form from the device. The device interface encapsulates some type of proxy that in turn points to an input device. That device can be a wand, a keyboard, a light sensor, or a home-brewed device that reads some input and returns it to VR Juggler in a meaningful way. That is a lot of indirection, but it makes the handling of physical devices by VR Juggler incredibly powerful.</para>
            </section>
            <section>
               <title>Using <classname>gadget::Proxy</classname></title>
               <indexterm>
                  <primary>classes</primary>
                  <secondary>gadget::Proxy</secondary>
               </indexterm>
               <para>To be blunt, application programmers do not use <classname>gadget::Proxy</classname>. Instead, access to a subclass of <classname>gadget::Proxy</classname> is given through a device interface acting as a smart pointer. The <methodname>getData()</methodname> method of that subclass is used<indexterm>
                     <primary>gadget::Proxy</primary>
                     <secondary>getData() method</secondary>
                  </indexterm>. That method is the window into the soul of an input device. The device interface allows calling <methodname>getData()</methodname> for the specific proxy object it encapsulates, and the current state of the device pointed to by the proxy is returned.</para>
               <para>Therefore, what must be known is the return type of the specific proxy to which access is granted through the device interface. The naming conventions for the proxies and their interfaces makes it relatively simple to determine which proxy object is being encapsulated by which device interface. For example, a <classname>gadget::DigitalInterface</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>gadget::DigitalInterface</secondary>
                  </indexterm> holds a <classname>gadget::DigitalProxy</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>gadget::DigitalProxy</secondary>
                  </indexterm> pointer. In that case, refer to the documentation for the <classname>gadget::DigitalProxy</classname> class and find the return type of <methodname>getData()</methodname> (<type>int</type> in this case). The proxy header files have the information, too. These are located in <filename>$GADGET_BASE_DIR/include/gadget/Type</filename>. Just search for the <methodname>getData()</methodname> methods therein.</para>
            </section>
            <section>
               <title>The Gory Details</title>
               <indexterm>
                  <primary>gadget::Proxy</primary>
                  <secondary>details</secondary>
               </indexterm>
               <para>The gory details of <classname>gadget::Proxy</classname> and its subclasses are not really relevant to this particular section. The subclasses look complicated, and they can be. It is important to note, however, that the complication is part of the interface used <emphasis>internally</emphasis> by VR Juggler rather than the interface used by the application programmer. Because of that and because each device proxy class is different, those details will not be addressed here. It is sufficient to deal with <methodname>getData()</methodname> alone in applications. Leave the ugliness up to VR Juggler; it can handle it.</para>
            </section>
         </section>
      </chapter>
   </part>
   <part id="app.programming.part">
      <title>Application Programming</title>
      <chapter id="ch4">
         <title>Writing Applications</title>
         <indexterm>
            <primary>applications</primary>
            <secondary>writing</secondary>
         </indexterm>
         <para>This chapter alone comprises the bulk of information about application development. Each section outlines one area of interest for application developers. For example, there are sections that show how to get input from the system and others that show how to write applications for each of the currently supported graphics APIs. Please note that when writing an application, there will be overlap between these sections. For example, an application that needs input, sound, and OpenGL graphics will be based on concepts from each of the relevant sections.</para>
         <section>
            <title>Application Review</title>
            <para>Before getting into too much detail, we present this section as a review from earlier chapters. There is no new information here; it is simply a quick overview of the basics of VR Juggler applications.</para>
            <section>
               <title>Basic Application Information</title>
               <para>As described in previous chapters (see <xref linkend="ch1"/>, for example), all VR Juggler applications derive from a base application object class (<classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::App</secondary>
                  </indexterm>). This class defines the basic interface that VR Juggler expects from all application objects. This means that when constructing an application, the user-defined application object must inherit from <classname>vrj::App</classname> or from a Draw Manager-specific application class that has <classname>vrj::App</classname> as a superclass. For example:</para>
               <programlisting>class userApp : public vrj::App
{
public:
   init();
   preFrame();
   postFrame();
}</programlisting>
               <para>This defines a new application class (<classname>userApp</classname>), instances of which can be used anywhere that VR Juggler expects an application object.</para>
            </section>
            <section>
               <title>Draw Manager-Specific Application Classes</title>
               <para>A user application does not have to (and in most cases does not) derive from <classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::App</secondary>
                  </indexterm>. In most cases, an application class is derived from a Draw Manager-specific application class. For example: </para>
               <programlisting>class userGlApp : public vrj::GlApp
{
public:
   init();
   preFrame();
   postFrame();
   
   draw();
}</programlisting>
               <para>This is an example of an OpenGL application. The application class (<classname>userGlApp</classname>) has derived directly from the OpenGL Draw Manager-specific <classname>vrj::GlApp</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::GlApp</secondary>
                  </indexterm> application base class. This class provides extra definitions in the interface that are custom for OpenGL applications.</para>
            </section>
         </section>
         <section id="get-input-sect">
            <title>Getting Input</title>
            <indexterm zone="get-input-sect">
               <primary>application programming</primary>
               <secondary>getting input</secondary>
            </indexterm>
            <para>There are many types of input devices that VR Juggler applications can use including positional, digital, and analog<indexterm>
                  <primary>input device types</primary>
               </indexterm>. All applications share the same processes and concepts for acquiring input from devices. The main thing to remember about getting input in applications is that all VR Juggler applications receive input through device handles managed by <classname>gadget::DeviceInterface</classname>s<indexterm>
                  <primary>classes</primary>
                  <secondary>gadget::DeviceInterface</secondary>
               </indexterm>. There are <classname>gadget::DeviceInterface</classname>s for each type of input data that VR Juggler can handle. There is one for positional input, one for analog, and so on. They all have very similar interfaces and behave exactly the same. (Refer to <xref linkend="vjDeviceInterface-section"/> and <xref linkend="vjProxy-section"/> for more information.)</para>
            <section>
               <title>How to Get Input</title>
               <para>While there has already been a brief presentation about getting input in an application, we need something more. Since all device interfaces look the same, we will focus on an example of getting positional input. All other types are very similar. We begin with a simple application object skeleton.</para>
               <programlisting>class myApp : public vrj::App
{
public:
   init();
   preFrame();
private:
   gadget::PositionInterface mWand;
}</programlisting>
               <para>Note the declaration of the variable <varname>mWand</varname> of type <classname>gadget::PositionInterface</classname>. This is the first addition to an application. Device interfaces are usually member variables of the user application class, as in this example.</para>
               <programlisting>myApp::init()
{
   mWand.init("NameOfPosDevInConfiguration");
}</programlisting>
               <para>The device interface has to be told about the device from which it will get data. This is done by calling the device interface object's <methodname>init()</methodname> method with the symbolic string name of the device. This device name comes from the active configuration. We are now ready to read from the device.</para>
               <programlisting>...
gmtl::Matrix44f wand_pos;
wand_pos = *(mWand-&gt;getData());
...</programlisting>
               <para>The above code shows an example of using the device interface in an application. It shows some sample code where the application copies the positional information from a device interface. When it is dereferenced, the device interface figures out what device it points to and returns the data from that device. Again, refer to <xref linkend="vjDeviceInterface-section"/> for more information about using <classname>gadget::DeviceInterface</classname>.</para>
            </section>
            <section>
               <title>Where to Get Input</title>
               <indexterm>
                  <primary>application programming</primary>
                  <secondary>where to get device input</secondary>
               </indexterm>
               <para>In the previous section, we showed how to get input from devices, but we never said where to put the code. The location, surprisingly, is application dependent. There are some very good guidelines regarding where applications should process input. Before explaining them, however, we should review the VR Juggler kernel control loop, presented again in <xref linkend="Kernel-seq-diag2"/>.</para>
               <figure float="1" id="Kernel-seq-diag2">
                  <title>VR Juggler kernel control loop</title>
                  <mediaobject>
                     <imageobject>
                        <imagedata fileref="figures/Kernel_Loop_Call_Sequence.png" format="PNG" align="center" scalefit="1"/>
                     </imageobject>
                  </mediaobject>
               </figure>
               <para>This diagram looks complicated, but the key here is the <methodname>updateAllData()</methodname> call near the bottom of the diagram. This is where VR Juggler updates all the cached device data that will be used in drawing the next frame. This updated copy is used by all user references to device data until the next update and the end of the next frame of execution.</para>
               <para>This means two things:</para>
               <orderedlist>
                  <listitem>
                     <para>The device data is most fresh in <methodname>vrj::App::preFrame()</methodname>, and</para>
                  </listitem>
                  <listitem>
                     <para>Any time spent in <methodname>vrj::App::preFrame()</methodname> increases the overall system latency.</para>
                  </listitem>
               </orderedlist>
               <para>The first point is important because it means that the copy of the device data with the lowest latency is always available in the <methodname>preFrame()</methodname> member function. The second point is equally important because it says why user applications should not waste any time in <methodname>preFrame()</methodname>. Any time spent in <methodname>preFrame()</methodname> increases system latency and in turn decreases the perceived quality of the environment. Hence, it is crucial to avoid placing computations in <methodname>preFrame()</methodname>.</para>
            </section>
            <section>
               <title>Tutorial: Getting Input</title>
               <indexterm>
                  <primary>tutorial</primary>
                  <secondary>getting input</secondary>
               </indexterm>
               <table>
                  <title>Tutorial Overview</title>
                  <tgroup cols="2">
                     <tbody>
                        <row>
                           <entry>Description</entry>
                           <entry>Simple application that prints the location of the head and the wand</entry>
                        </row>
                        <row>
                           <entry>Objective</entry>
                           <entry>Understand how to get positional and digital input in a VR Juggler application</entry>
                        </row>
                        <row>
                           <entry>Member functions</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><methodname>vrj::App::init()</methodname></para>
                                 </listitem>
                                 <listitem>
                                    <para><methodname>vrj::App::preFrame()</methodname></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                        <row>
                           <entry>Directory</entry>
                           <entry><filename>$VJ_BASE_DIR/share/samples/tutorials/simpleInput</filename></entry>
                        </row>
                        <row>
                           <entry>Files</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><filename>simpleInput.h</filename></para>
                                 </listitem>
                                 <listitem>
                                    <para><filename>simpleInput.cpp</filename></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <section>
                  <title>Class Declaration and Data Members</title>
                  <para>In the following class declaration, note the data members (<varname>mWand</varname>, <varname>mHead</varname>, etc.). This application has four device interface member variables: two for positional input (<varname>mHead</varname> and <varname>mWand</varname>) and two for digital input (<varname>mButton0</varname> and <varname>mButton1</varname>). Each of these member variables will act as a handle to a <quote>real</quote> device from which we will read data in <methodname>preFrame()</methodname>.</para>
                  <programlisting linenumbering="numbered">class simpleInput : public vrj::GlApp
{
public:
   virtual void init();
   virtual void preFrame();

public:
   gadget::PositionInterface mWand;     // Positional interface for Wand position
   gadget::PositionInterface mHead;     // Positional interface for Head position
   gadget::DigitalInterface  mButton0;  // Digital interface for button 0
   gadget::DigitalInterface  mButton1;  // Digital interface for button 1
};</programlisting>
               </section>
               <section>
                  <title>Initializing the Device Interfaces: <methodname>vrj::App::init()</methodname></title>
                  <para>The devices are initialized in the <methodname>init()</methodname> member function of the application. For each device interface member variable, the application calls the variable's own <methodname>init()</methodname> method. The argument passed is the symbolic name of the configured device from which data will be read. From this point on in the application, the member variables are <emphasis>handles</emphasis> to the named device.</para>
                  <programlisting linenumbering="numbered">virtual void init()
{
   // Initialize devices
   mWand.init("VJWand");
   mHead.init("VJHead");
   mButton0.init("VJButton0");
   mButton1.init("VJButton1");
}</programlisting>
               </section>
               <section>
                  <title>Examining the Device Data: <methodname>vrj::App::preFrame()</methodname></title>
                  <para>The following member function implementation gives an example of how to examine the input data using the device interface member variables.</para>
                  <programlistingco>
                     <areaspec>
                        <areaset coords="" id="button.reads">
                           <area coords="3" id="mButton0.read"/>
                           <area coords="7" id="mButton1.read"/>
                        </areaset>
                        <area coords="12" id="button.print"/>
                        <area coords="19" id="position.get"/>
                     </areaspec>
                     <programlisting linenumbering="numbered">virtual void preFrame()
{
   if ( mButton0-&gt;getData() )
   {
      std::cout &lt;&lt; "Button 0 pressed" &lt;&lt; std::endl;
   }
   if( mButton1-&gt;getData() )
   {
      std::cout &lt;&lt; "Button 1 pressed" &lt;&lt; std::endl;
   }
 
   std::cout &lt;&lt; "Wand Buttons:"
             &lt;&lt; " 0:" &lt;&lt; mButton0-&gt;getData()
             &lt;&lt; " 1:" &lt;&lt; mButton1-&gt;getData()
             &lt;&lt; std::endl;
                 
   // -- Get Wand matrix --- //
   gmtl::Matrix44f wand_matrix;
   wand_matrix = *(mWand-&gt;getData());
   std::cout &lt;&lt; "Wand pos: \n" &lt;&lt; wand_matrix &lt;&lt; std::endl;
}</programlisting>
                     <calloutlist>
                        <callout arearefs="button.reads">
                           <para>These statements check the status of the two digital buttons and write out a line if the button has been pressed.</para>
                        </callout>
                        <callout arearefs="button.print">
                           <para>This writes out the current state of both buttons.</para>
                        </callout>
                        <callout arearefs="position.get">
                           <para>The final section prints out the current location of the wand in the VR environment.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>
            </section>
         </section>
         <section id="ogl-app-sect">
            <title>OpenGL Applications</title>
            <indexterm>
               <primary>application programming</primary>
               <secondary>OpenGL</secondary>
            </indexterm>
            <para>We can now describe how to write OpenGL applications in VR Juggler. An OpenGL-based VR Juggler application must be derived from <classname>vrj::GlApp</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::GlApp</secondary>
               </indexterm>. This in turn is derived from <classname>vrj::App</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::App</secondary>
               </indexterm>. As was discussed in the application object section, <classname>vrj::App</classname> defines the base interface that VR Juggler expects of all applications. The <classname>vrj::GlApp</classname> class extends this interface by adding members that the VR Juggler OpenGL Draw Manager needs to render an OpenGL application correctly.</para>
            <figure float="1" id="vjGlApp-class-fig">
               <title><classname>vrj::GlApp</classname> application class</title>
               <mediaobject>
                  <imageobject>
                     <imagedata fileref="figures/userOglApp_hierarchy.png" format="PNG" align="center" scalefit="1"/>
                  </imageobject>
               </mediaobject>
            </figure>
            <para>In <xref linkend="vjGlApp-class-fig"/>, we see the functions added by the <classname>vrj::GlApp</classname> interface: <methodname>draw()</methodname>, <methodname>contextInit()</methodname>, and <methodname>contextPreDraw()</methodname><indexterm>
                  <primary>vrj::GlApp</primary>
                  <secondary>extensions to vrj::App</secondary>
               </indexterm>. These functions deal with OpenGL drawing and managing context-specific data (do not worry what context data is right now&mdash;we cover that in detail later). There are a few other functions in the interface, but these cover 99% of the issues that most developers face. In the following sections, we will describe how to add OpenGL drawing to an application and how to handle context-specific data. There is a tutorial for each topic.</para>
            <section>
               <title>OpenGL Drawing: <methodname>vrj::GlApp::draw()</methodname></title>
               <indexterm>
                  <primary>application programming</primary>
                  <secondary>OpenGL</secondary>
                  <tertiary>drawing</tertiary>
               </indexterm>
               <indexterm>
                  <primary>vrj::GlApp</primary>
                  <secondary>draw() method</secondary>
               </indexterm>
               <para>The most important (and visible) component of most OpenGL applications is the OpenGL drawing. The <classname>vrj::GlApp</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>vrj::GlApp</secondary>
                  </indexterm> class interface defines a <methodname>draw()</methodname> member function to hold the code for drawing a virtual environment. Hence, any OpenGL drawing calls should be placed in the <methodname>vrj::GlApp::draw()</methodname> function of the user application object.</para>
               <para>Adding drawing code to an OpenGL-based VR Juggler application is straightforward. The <methodname>draw()</methodname> method is called whenever the OpenGL Draw Manager needs to render a view of the virtual world created by the user's application. It is called for each defined OpenGL context, and it may be called multiple times per frame in the case of multi-surface setups and/or stereo configurations. Applications should <emphasis>never</emphasis> rely upon the number of times this member function is called per frame.</para>
               <para>When the method is called, the OpenGL model view and projection matrices have been configured correctly to draw the scene. Input devices are guaranteed to be in the same state (position, value, etc.) for each call to the <methodname>draw()</methodname> method for a given frame.</para>
               <section>
                  <title>Recommended Uses</title>
                  <para>The only code that should execute in this function is calls to OpenGL drawing routines. It is permissible to read from input devices to determine what to draw, but application data members should not be updated in this function.</para>
               </section>
               <section>
                  <title>Possible Misuses</title>
                  <para>The <methodname>draw()</methodname> method should not be used to perform any time-consuming computations. Code in this member function should not change the state of any application variables.</para>
               </section>
            </section>
            <section id="simple-ogl-app-sect">
               <title>Tutorial: Drawing a Cube with OpenGL</title>
               <indexterm>
                  <primary>tutorial</primary>
                  <secondary>drawing a cube with OpenGL</secondary>
               </indexterm>
               <table>
                  <title>Tutorial Overview</title>
                  <tgroup cols="2">
                     <tbody>
                        <row>
                           <entry>Description</entry>
                           <entry>Simple OpenGL application that draws a cube in the environment</entry>
                        </row>
                        <row>
                           <entry>Objectives</entry>
                           <entry>Understand how the <methodname>draw()</methodname> member function in <classname>vrj::GlApp</classname> works; create basic OpenGL-based VR Juggler applications</entry>
                        </row>
                        <row>
                           <entry>Member functions</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><methodname>vrj::App::init()</methodname></para>
                                 </listitem>
                                 <listitem>
                                    <para><methodname>vrj::GlApp::draw()</methodname></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                        <row>
                           <entry>Directory</entry>
                           <entry><filename>$VJ_BASE_DIR/share/samples/tutorials/simpleApp</filename></entry>
                        </row>
                        <row>
                           <entry>Files</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><filename>simpleApp.h</filename></para>
                                 </listitem>
                                 <listitem>
                                    <para><filename>simpleApp.cpp</filename></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <section>
                  <title>Class Declaration</title>
                  <para>The following application class is called <classname>simpleApp</classname>. It is derived from <classname>vrj::GlApp</classname> and has custom <methodname>init()</methodname> and <methodname>draw()</methodname> methods declared. Note that the application declares several device interface members that are used by the application for getting device data.</para>
                  <programlisting linenumbering="numbered">using namespace vrj;
using namespace gadget;

class simpleApp : public GlApp
{
public:
   simpleApp();
   virtual void init();
   virtual void draw();

public:
   PositionInterface mWand;
   PositionInterface mHead;
   DigitalInterface mButton0;
   DigitalInterface mButton1;
};</programlisting>
               </section>
               <section>
                  <title>The <methodname>draw()</methodname> Member Function</title>
                  <para>The implementation of <methodname>draw()</methodname> is located in <filename>simpleApp.cpp</filename>. Its job is to draw the environment. A partial implementation follows.</para>
                  <programlistingco>
                     <areaspec>
                        <area coords="5" id="box-offset.init"/>
                        <area coords="11" id="box-offset.push"/>
                        <area coords="13" id="draw.cube"/>
                     </areaspec>
                     <programlisting linenumbering="numbered">using namespace gmtl;

void simpleApp::draw()
{
   ...
   // Create box offset matrix
   Matrix44f box_offset;		
   const EulerAngleXYZf euler_ang(Math::deg2Rad(-90.0f), Math::deg2Rad(0.0f),
                                  Math::deg2Rad(0.0f));
   box_offset = gmtl::makeRot&lt;Matrix44f&gt;(euler_ang);
   gmtl::setTrans(box_offset, Vec3f(0.0, 1.0f, 0.0f));
   ...
   glPushMatrix();
      // Push on offset
      glMultMatrixf(box_offset.getData());
      ...
      drawCube();
   glPopMatrix();
   ...
}</programlisting>
                     <calloutlist>
                        <callout arearefs="box-offset.init">
                           <para>This creates a <classname>gmtl::Matrix44f</classname> object that defines the offset of the cube in the virtual world.</para>
                        </callout>
                        <callout arearefs="box-offset.push">
                           <para>The new matrix is pushed onto the OpenGL modelview matrix stack.</para>
                        </callout>
                        <callout arearefs="draw.cube">
                           <para>Finally, a cube is drawn.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
                  <para>In the above, there is no projection code in the function. When the function is called by VR Juggler, the projection matrix has already been set up correctly for the system. All the user application must do is draw the environment; VR Juggler handles the rest. In this example, the <methodname>draw()</methodname> function renders a cube at an offset location.</para>
               </section>
               <section>
                  <title>Exercise</title>
                  <para>Change the code so that the cube is drawn at the position of the wand instead of at the <varname>box_offset</varname> location.</para>
               </section>
            </section>
            <section id="cs-data-intro-sec">
               <title>Context-Specific Data</title>
               <indexterm>
                  <primary>application programming</primary>
                  <secondary>OpenGL</secondary>
                  <tertiary>context-specific data</tertiary>
               </indexterm>
               <indexterm>
                  <primary>context-specific data</primary>
               </indexterm>
               <para>Many readers may already be familiar with the specifics of OpenGL. In this section, we provide a very brief introduction to <firstterm>context-specific data</firstterm> within OpenGL, and we proceed to explain how it is used by VR Juggler. Those who are already familiar with context-specific data may skip ahead to <xref linkend="cs-data-needed-sect"/> or to <xref linkend="using-csdata-sec"/>.</para>
               <para>The OpenGL graphics API operates using a state machine that tracks the current settings and attributes set by the OpenGL code. Each window in which we render using OpenGL has a state machine associated with it. The state machines associated with these windows are referred to as <firstterm>OpenGL rendering contexts</firstterm><indexterm>
                     <primary>OpenGL rendering contexts</primary>
                  </indexterm>.</para>
               <para>Each context stores the current state of an OpenGL renderer instance. The state includes the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Current color</para>
                  </listitem>
                  <listitem>
                     <para>Current shading mode</para>
                  </listitem>
                  <listitem>
                     <para>Current texture</para>
                  </listitem>
                  <listitem>
                     <para>Display lists</para>
                  </listitem>
                  <listitem>
                     <para>Texture objects</para>
                  </listitem>
               </itemizedlist>
               <section id="cs-data-needed-sect">
                  <title>Why it is Needed</title>
                  <para>As outlined in the VR Juggler architecture documentation, VR Juggler uses a single memory area for all application data. All threads can see the same memory area and thus share the same copy of all variables. This makes programming normal application code very easy because programmers never have to worry about which thread can see which variables. In the case of context-specific data, however, it presents a problem.</para>
                  <para>To understand the problem, consider an environment where we use a single display list. That display list is created to draw some object in the scene. We would like to be able to call the display list in our <methodname>draw()</methodname> method and have it draw the primitives that were captured in it.</para>
                  <para>The following class skeleton shows an outline of this idea. Do not worry for now that we do not show the code where we allocate the display list&mdash;that will be covered later. For now, we see that there is a variable that stores the display list ID (<varname>mDispListId</varname>), and we use it in the <methodname>draw()</methodname> method.</para>
                  <programlisting>using namespace vrj;

class userApp : public GlApp
{
public:
  draw();
public:
  int mDispListId;
};

userApp::draw()
{
   glCallList(mDispListId);
}</programlisting>
                  <para>Now, imagine that we have a VR system configured that needs more than one display window (a multi-wall projection system, for example). There is a thread for each display, and all the display threads call <methodname>draw()</methodname> in parallel.</para>
                  <para>Since all threads share the same copy of the variables, they all use the same <varname>mDispListId</varname> when calling <function>glCallList()</function>. This is an error because we call draw from multiple windows (that is, multiple OpenGL rendering contexts). The display list ID is not the same in each context. What we need, then, is a way to use a different display list ID depending upon the OpenGL context within which we are currently rendering. Context-specific data comes to the rescue to address this problem.</para>
                  <para>Context-specific data provides us with a way to get a separate copy of a variable for each OpenGL rendering context. This may sound daunting at first, but VR Juggler manages this special variable so that it appears just as a normal variable. The developer never has to deal with contexts directly. VR Juggler transparently ensures that the correct copy of the variable is being used.</para>
               </section>
               <section>
                  <title>Context-Specific Variables in VR Juggler</title>
                  <indexterm>
                     <primary>context-specific variables</primary>
                  </indexterm>
                  <para>The following shows how a context-specific variable appears in a VR Juggler application:</para>
                  <programlisting>using namespace vrj;

class userApp : public GlApp
{
public:
   draw();
public:
   GlContextData&lt;int&gt; mDispListId; // Context-specific variable
};

userApp::draw()
{
   glCallList(*mDispListId);
}</programlisting>
                  <para>This code looks nearly the same as the previous example. In this case, <varname>mDispListId</varname> is treated as a pointer, and it has a special template-based type that tells VR Juggler it is context-specific data. When defining a context-specific data member, use the <classname>vrj::GlContextData&lt;&gt;</classname> template class and pass the <quote>true</quote> type of the variable to the template definition. From then on, it can be treated as a normal pointer.<note>
                        <para>The types that are used for context-specific data must provide default constructors. The user cannot directly call the constructor for the data item because VR Juggler has to allocate new items on the fly as new contexts are created.</para>
                     </note></para>
               </section>
               <section>
                  <title>The Inner Workings of Context-Specific Variables</title>
                  <para>Curious readers are probably wondering how all of this works. To satisfy any curiosity, we now provide a brief description.</para>
                  <para>The context data items are allocated using a template-based smart pointer class (<classname>vrj::GlContextData&lt;&gt;</classname>). Behind the scenes, VR Juggler keeps a list of currently allocated variables for each context. When the application wants to use a context data item, the smart pointer looks in the list and returns a reference to the correct copy for the current context.</para>
                  <para>This is all done in a fairly light-weight manner. It all boils down to one memory lookup and a couple of pointer dereferences. Not bad for all the power that it gives.</para>
               </section>
            </section>
            <section id="using-csdata-sec">
               <title>Using Context-Specific Data</title>
               <indexterm>
                  <primary>context-specific data</primary>
                  <secondary>use of</secondary>
               </indexterm>
               <para>The VR Juggler OpenGL graphics system is a complex, multi-headed beast. Luckily, developers do not have to understand how the system is working to use it correctly. As long as developers subscribe to several simple rules for allocating and using context data, everything will work fine. This section contains these rules, but it does not describe the rationale behind the rules. Those readers who are interested in the details of why these rules should be followed should please read the subsequent section. It contains much more (excruciating) detail.</para>
               <section>
                  <title>The Rules</title>
                  <para>With the background in how to make a context-specific data member and how to use it in a <methodname>draw()</methodname> function, we can move on to how and where the context-specific data should be allocated. If we want to create a display list, we need to know where we should allocate it.</para>
                  <section>
                     <title>Rule 1: Do not allocate context data in <methodname>draw()</methodname></title>
                     <para>This is straightforward: do not allocate context data in the <methodname>draw()</methodname> member function. There are many reasons for this, but the primary one is that allocation tests would be occurring too many times and at incorrect times. There are better places to allocate context data.</para>
                  </section>
                  <section>
                     <title>Rule 2: Initialize static context data in <methodname>contextInit()</methodname></title>
                     <para>The place to allocate static context-specific data is the <methodname>vrj::GlApp::contextInit()</methodname><indexterm>
                           <primary>vrj::GlApp</primary>
                           <secondary>contextInit() method</secondary>
                        </indexterm> member function. <quote>Static</quote> context data refers to context data that does not change during the application's execution. An example of static context data would be a display list to render an object model that is preloaded by the application and never changes. It is static because the display list only has to be generated once for each context, and the application can generate the display list as soon as it starts execution.</para>
                     <para>The <methodname>contextInit()</methodname> member function is called immediately after creation of any <emphasis>new</emphasis> OpenGL contexts. In other words, it is called whenever new windows open. When it is called, the newly created context is active. This method is the perfect place to allocate static context data because it is only called when we have a new context that we need to prepare (and also because that is what it is designed for).</para>
                     <para>The following code snippet shows a possible use of the application object's <methodname>contextInit()</methodname> method:</para>
                     <example id="context.data.init.example">
                        <title>Initializing context-specific data</title>
                        <programlisting linenumbering="numbered">void userApp::contextInit()
{
   // Allocate context specific data
   (*mDispListId) = glGenLists(1);

   glNewList((*mDispListId), GL_COMPILE);
      glScalef(0.50f, 0.50f, 0.50f);
      // Call func that draws a cube in OpenGL
      drawCube();
   glEndList();
   ...
}</programlisting>
                     </example>
                     <para>This shows the normal way that display lists should be allocated in VR Juggler. Allocate the display list, store it to a context-specific data member, and then fill the display list. Texture objects and other types of context-specific data are created in exactly the same manner.</para>
                  </section>
                  <section>
                     <title>Rule 3: Allocate and update dynamic context data in <methodname>contextPreDraw()</methodname></title>
                     <para>The place to allocate dynamic context-specific data is the <methodname>contextPreDraw()</methodname><indexterm>
                           <primary>vrj::GlApp</primary>
                           <secondary>contextPreDraw() method</secondary>
                        </indexterm> member function. <quote>Dynamic</quote> context data differs from static context data in that dynamic data may change during the application's execution. An example of dynamic data would be a display list for rendering an object from a data set that changes as the applications executes. This requires dynamic context data because the display list has to be regenerated every time the application changes the data set.</para>
                     <para>Consider also the following example. While running an application, the user requests to load a new model from a file. After the model data is loaded, it may be best to put the drawing functions into a fresh display list for rendering the model. In this case, <methodname>vrj::GlApp::contextInit()</methodname> cannot be used because it is only called when a new context is created. Here, all the windows have already been created. What we need, then, is a callback that is called once per existing context so that we can add and change the context-specific data. That is what <methodname>contextPreDraw()</methodname> does. It is called once per context for each VR Juggler frame with the current context active.</para>
                     <para>Please notice, however, that since this method is called often and is called in performance-critical areas, you should not do much work in it. Any time taken by this method directly decreases the draw performance of the application. In most cases, we recommend trying to make the function have a very simple early exit clause such as in the following example. This makes the average cost only that of a single comparison operation.</para>
                     <programlisting>userApp::contextInit()
{
   if (have work to do)
   {
     // Do it
   }
}</programlisting>
                  </section>
               </section>
            </section>
            <section>
               <title>Context-Specific Data Details</title>
               <indexterm>
                  <primary>context-specific data</primary>
                  <secondary>details</secondary>
               </indexterm>
               <para>Within this section, we provide the details of context-specific data in VR Juggler and justify the rules presented in the previous section.</para>
               <figure float="1" id="vrj-ogl-system-chart">
                  <title>VR Juggler OpenGL system</title>
                  <mediaobject>
                     <imageobject>
                        <imagedata fileref="JugglerOGLSystemChart.png" format="PNG" align="center" scalefit="1"/>
                     </imageobject>
                  </mediaobject>
               </figure>
               <section>
                  <title>Do Not Allocate Context-Specific Data in <methodname>draw()</methodname></title>
                  <para>Rule 1 says that context-specific data should not be allocated in an application object's <methodname>draw()</methodname> method. We have already stated that the main reason is that <methodname>draw()</methodname> is called too many times, and it is called at the wrong time for allocation of context-specific data. To be more specific, the <methodname>draw()</methodname> method is called for each surface, or for each eye, every frame. Static context-specific data only needs to be allocated when a new window is opened. (Dynamic context-specific data is handled separately.)</para>
               </section>
            </section>
            <section>
               <title>Tutorial: Drawing a Cube using OpenGL Display Lists</title>
               <indexterm>
                  <primary>tutorial</primary>
                  <secondary>drawing a cube using display lists</secondary>
               </indexterm>
               <table>
                  <title>Tutorial Overview</title>
                  <tgroup cols="2">
                     <tbody>
                        <row>
                           <entry>Description</entry>
                           <entry>Drawing a cube using a display list in the <methodname>draw()</methodname> member function</entry>
                        </row>
                        <row>
                           <entry>Objectives</entry>
                           <entry>Understand how to use context-specific data in an application</entry>
                        </row>
                        <row>
                           <entry>Member functions</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><methodname>vrj::App::init()</methodname></para>
                                 </listitem>
                                 <listitem>
                                    <para><methodname>vrj::GlApp::contextInit()</methodname></para>
                                 </listitem>
                                 <listitem>
                                    <para><methodname>vrj::GlApp::draw()</methodname></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                        <row>
                           <entry>Directory</entry>
                           <entry><filename>$VJ_BASE_DIR/share/samples/tutorials/contextApp</filename></entry>
                        </row>
                        <row>
                           <entry>Files</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><filename>contextApp.h</filename></para>
                                 </listitem>
                                 <listitem>
                                    <para><filename>contextApp.cpp</filename></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <section>
                  <title>Class Declaration and Data Members</title>
                  <para>The following code example shows the basics of declaring the class interface and data members for an application that will use context-specific data. This is an extension of the simple OpenGL application presented in <xref linkend="simple-ogl-app-sect"/>. Note the addition of the <methodname>contextInit()</methodname> declaration and the use of the context-specific data member <varname>mCubeDlId</varname>.</para>
                  <programlisting linenumbering="numbered">using namespace vrj;

class contextApp : public GlApp
{
public:
   contextApp() {;}
   virtual void init();
   virtual void contextInit();
   virtual void draw();
    ...
public:
   // Id of the cube display list
   GlContextData&lt;GLuint&gt; mCubeDlId;
   ...
};</programlisting>
               </section>
               <section>
                  <title>The <methodname>contextInit()</methodname> Member Function</title>
                  <para>We now show the implementation of <methodname>contextApp::contextInit()</methodname>. Here the display list is created and stored using context-specific data. Recall <xref linkend="context.data.init.example"/>, presented in <xref linkend="using-csdata-sec"/>. That example was based on this tutorial application.</para>
                  <programlisting linenumbering="numbered">void contextApp::contextInit()
{
   // Allocate context specific data
   (*mCubeDlId) = glGenLists(1);

   glNewList((*mCubeDlId), GL_COMPILE);
      glScalef(0.50f, 0.50f, 0.50f);
      drawCube();
   glEndList();
   ...
}</programlisting>
               </section>
               <section>
                  <title>The <methodname>draw()</methodname> Member Function</title>
                  <para>Now that we have a display list ID in context-specific data, we can use it in the <methodname>draw()</methodname> member function. We render the display list by dereferencing the context-specific display list ID.</para>
                  <programlisting linenumbering="numbered">using namespace gmtl;

void contextApp::draw()
{
   // Get Wand matrix
   gmtl::Matrix44f wand_matrix;
   wand_mat = *(mWand-&gt;getData());
   ...
   glPushMatrix();
      glPushMatrix();
         glMultMatrixf(wand_mat.getData());    
         glCallList(*mCubeDlId);
      glPopMatrix();
      ...
   glPopMatrix();
}</programlisting>
               </section>
               <section>
                  <title>Exercise</title>
                  <para>In the tutorial application code, replace the call to <methodname>drawAxis()</methodname> with a display list call.</para>
               </section>
            </section>
         </section>
         <section id="pf-app-sect">
            <title>OpenGL Performer Applications</title>
            <indexterm>
               <primary>application programming</primary>
               <secondary>OpenGL Performer</secondary>
            </indexterm>
            <para>Programmers familiar with the use of scene graphs may prefer to use that data structure rather than writing OpenGL manually. While VR Juggler does not provide a scene graph of its own, its design allows the use of existing scene graph software. In VR Juggler 1.1 DR2, the supported scene graphs are OpenGL Performer from SGI, OpenSG, and Open Scene Graph. This section explains how to use OpenGL Performer to write VR Juggler applications.</para>
            <para>A Performer-based VR Juggler application must derive from <classname>vrj::PfApp</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::PfApp</secondary>
               </indexterm>. Similar to <classname>vrj::GlApp</classname> presented in the previous section, <classname>vrj::PfApp</classname> derives from <classname>vrj::App</classname>. <classname>vrj::PfApp</classname> extends <classname>vrj::App</classname> by adding methods that deal with scene graph initialization and access. <xref linkend="vjPfApp-class-diag2"/> shows how <classname>vrj::PfApp</classname> fits into the class hierarchy of a Performer-based VR Juggler application.</para>
            <figure float="1" id="vjPfApp-class-diag2">
               <title><classname>vrj::PfApp</classname> application class</title>
               <mediaobject>
                  <imageobject>
                     <imagedata fileref="figures/userPfApp_hierarchy.png" format="PNG" align="center" scalefit="1"/>
                  </imageobject>
               </mediaobject>
            </figure>
            <para>Two of the methods added to the application interface by <classname>vrj::PfApp</classname> are <methodname>initScene()</methodname> and <methodname>getScene()</methodname><indexterm>
                  <primary>vrj::PfApp</primary>
                  <secondary>extensions to vrj::App</secondary>
               </indexterm>. These are called by the Performer Draw Manager to initialize the application scene graph and to get the root of the scene graph respectively. They must be implemented by the application (they are pure virtual methods within <classname>vrj::PfApp</classname>). Additional methods will be discussed in this section, but in many cases the default implementations of these other methods may be used. A simple tutorial application will be provided to illustrate the concepts presented.</para>
            <section>
               <title>Scene Graph Initialization: <methodname>vrj::PfApp::initScene()</methodname></title>
               <indexterm>
                  <primary>vrj::PfApp</primary>
                  <secondary>initScene() method</secondary>
               </indexterm>
               <indexterm>
                  <primary>application programming</primary>
                  <secondary>OpenGL Performer</secondary>
                  <tertiary>scenegraph initialization</tertiary>
               </indexterm>
               <para>In an application using OpenGL Performer, the scene graph must be initialized before it can be used. The method <methodname>vrj::PfApp::initScene()</methodname> is provided for that purpose. Within this method, the root of the application scene graph should be created, and any required models should be loaded and attached to the root in some way. The exact mechanisms for accomplishing this will vary depending on what the application will do.</para>
               <para>During the initialization of OpenGL Performer by VR Juggler, <methodname>vrj::PfApp::initScene()</methodname> is invoked after the Performer functions <function>pfInit()</function> and <function>pfConfig()</function> but before <methodname>vrj::App::apiInit()</methodname>.</para>
            </section>
            <section>
               <title>Scene Graph Access: <methodname>vrj::PfApp::getScene()</methodname></title>
               <indexterm>
                  <primary>vrj::PfApp</primary>
                  <secondary>getScene() method</secondary>
               </indexterm>
               <indexterm>
                  <primary>application programming</primary>
                  <secondary>OpenGL Performer</secondary>
                  <tertiary>scenegraph access</tertiary>
               </indexterm>
               <para>In order for Performer to render the application scene graph, it must get access to the scene graph root. The method <methodname>vrj::PfApp::getScene()</methodname> will be called by the Performer Draw Manager so that it can give the scene graph root node to Performer. Since the job of <methodname>getScene()</methodname> is straightforward, its implementation can be very simple. A typical implementation will have a single statement that returns a member variable that holds a pointer to the application scene graph root node.<note>
                     <para>Make sure that the node returned is <emphasis>not</emphasis> a <classname>pfScene</classname> object. If it is, then lighting will not work.</para>
                  </note></para>
               <section>
                  <title>Possible Misuses</title>
                  <para>Do not load any models in this member function. This sort of operation should be done within <methodname>initScene()</methodname>.</para>
               </section>
            </section>
            <section>
               <title>Tutorial: Loading a Model with OpenGL Performer</title>
               <indexterm>
                  <primary>tutorial</primary>
                  <secondary>loading a model with OpenGL Performer</secondary>
               </indexterm>
               <table>
                  <title>Tutorial Overview</title>
                  <tgroup cols="2">
                     <tbody>
                        <row>
                           <entry>Description</entry>
                           <entry>Simple OpenGL Performer application that loads a model</entry>
                        </row>
                        <row>
                           <entry>Objectives</entry>
                           <entry>Understand how to load a model, add it to a scene graph, and return the root to VR Juggler</entry>
                        </row>
                        <row>
                           <entry>Member functions</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><methodname>vrj::PfApp::initScene()</methodname></para>
                                 </listitem>
                                 <listitem>
                                    <para><methodname>vrj::PfApp::getScene()</methodname></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                        <row>
                           <entry>Directory</entry>
                           <entry><filename>$VJ_BASE_DIR/share/samples/tutorials/simplePf</filename></entry>
                        </row>
                        <row>
                           <entry>Files</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><filename>simplePfApp.h</filename></para>
                                 </listitem>
                                 <listitem>
                                    <para><filename>simplePfApp.cpp</filename></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <section>
                  <title>Class Declaration</title>
                  <para>The following application class is called <classname>simplePfApp</classname>. It is derived from <classname>vrj::PfApp</classname> and has custom <methodname>initScene()</methodname> and <methodname>getScene()</methodname> methods declared. Note that this application uses <methodname>preForkInit()</methodname> which will be discussed later. Refer to <filename>simplePfApp.h</filename> for the implementations of <methodname>preForkInit()</methodname> and <methodname>setModel()</methodname>.</para>
                  <programlisting linenumbering="numbered">class simplePfApp : public vrj::PfApp
{
public:
   simplePfApp();
   virtual ~simplePfApp();

   virtual void preForkInit();
   virtual void initScene();
   virtual pfGroup* getScene();
   void setModel(std::string modelFile);

public:
   std::string    mModelFileName;

   pfGroup*       mLightGroup;
   pfLightSource* mSun;
   pfGroup*       mRootNode;
   pfNode*        mModelRoot;
};</programlisting>
               </section>
               <section>
                  <title>The <methodname>initScene()</methodname> Member Function</title>
                  <para>The implementation of <methodname>initScene()</methodname> is in <filename>simplePfApp.cpp</filename>. Within this method, we create the scene graph root node, the lighting node, and load a user-specified model. The implementation follows:</para>
                  <programlistingco>
                     <areaspec>
                        <area coords="4" id="rootnode.create"/>
                        <area coords="7" id="light.source.create"/>
                        <area coords="17" id="model.load"/>
                        <areaset coords="" id="scenegraph.add.all">
                           <area coords="20" id="scenegraph.add.model"/>
                           <area coords="21" id="scenegraph.add.light"/>
                        </areaset>
                     </areaspec>
                     <programlisting linenumbering="numbered">void simplePfApp::initScene ()
{
   // Allocate all the nodes needed
   mRootNode = new pfGroup;

   // Create the SUN light source
   mLightGroup = new pfGroup;
   mSun = new pfLightSource;
   mLightGroup-&gt;addChild(mSun);
   mSun-&gt;setPos(0.3f, 0.0f, 0.3f, 0.0f);
   mSun-&gt;setColor(PFLT_DIFFUSE, 1.0f, 1.0f, 1.0f);
   mSun-&gt;setColor(PFLT_AMBIENT, 0.3f, 0.3f, 0.3f);
   mSun-&gt;setColor(PFLT_SPECULAR, 1.0f, 1.0f, 1.0f);
   mSun-&gt;on();

   // --- LOAD THE MODEL -- //
   mModelRoot = pfdLoadFile(mModelFileName.c_str());

   // -- CONSTRUCT STATIC STRUCTURE OF SCENE GRAPH -- //
   mRootNode-&gt;addChild(mModelRoot);
   mRootNode-&gt;addChild(mLightGroup);
}</programlisting>
                     <calloutlist>
                        <callout arearefs="rootnode.create">
                           <para>First, the root node is constructed as a <classname>pfGroup</classname> object.</para>
                        </callout>
                        <callout arearefs="light.source.create">
                           <para>Next, some steps are taken to create a light source for the application.</para>
                        </callout>
                        <callout arearefs="model.load">
                           <para>Finally, the model is loaded using <function>pfdLoadFile()</function>, and the model scene graph root node is stored in <varname>mModelRoot</varname>. (The model loader must be initialized prior to calling <function>pfdLoadFile()</function>. This is done in <methodname>preForkInit()</methodname>.)</para>
                        </callout>
                        <callout arearefs="scenegraph.add.all">
                           <para>Finally, the model and the light source nodes are added as children of the root.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>
               <section>
                  <title>The <methodname>getScene()</methodname> Member Function</title>
                  <para>The Performer Draw Manager will call the application's <methodname>getScene()</methodname> method to get the root of the scene graph. The implementation of this method can be found in <filename>simplePfApp.h</filename>. The code is as follows:</para>
                  <programlisting>pfGroup* simplePfApp::getScene ()
{
   return mRootNode;
}</programlisting>
                  <para>The simplicity of this method implementation is not limited to the simple tutorial from which it is taken. All Performer-based VR Juggler applications can take advantage of this idiom where the root node is a member variable returned in <methodname>getScene()</methodname>.</para>
               </section>
            </section>
            <section>
               <title>Other <classname>vrj::PfApp</classname> Methods</title>
               <para>Besides the two methods discussed so far, there are several other methods in <classname>vrj::PfApp</classname> that extend the basic <classname>vrj::App</classname> interface. Each is discussed in this section.</para>
               <section>
                  <title><methodname>preForkInit()</methodname></title>
                  <indexterm>
                     <primary>vrj::PfApp</primary>
                     <secondary>preForkInit() method</secondary>
                  </indexterm>
                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>
                        <type>void</type>
                        <methodname>preForkInit</methodname>
                        <void/>
                     </methodsynopsis></para>
                  <para>This member function allows the user application to do any processing that needs to happen before Performer forks its processes but after <function>pfInit()</function> is called. In other words, it is invoked after <function>pfInit()</function> but before <function>pfConfig()</function>.</para>
               </section>
               <section>
                  <title><methodname>appChanFunc()</methodname></title>
                  <indexterm>
                     <primary>vrj::PfApp</primary>
                     <secondary>appChanFunc() method</secondary>
                  </indexterm>
                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>
                        <type>void</type>
                        <methodname>appChanFunc</methodname>
                        <methodparam>
                           <type>pfChannel*</type>
                           <parameter>chan</parameter>
                        </methodparam>
                     </methodsynopsis></para>
                  <para>This method is called every frame in the application process for each active channel. It is called immediately before rendering (<function>pfFrame()</function>).</para>
               </section>
               <section>
                  <title><methodname>configPWin()</methodname></title>
                  <indexterm>
                     <primary>vrj::PfApp</primary>
                     <secondary>configPWin() method</secondary>
                  </indexterm>
                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>
                        <type>void</type>
                        <methodname>configPWin</methodname>
                        <methodparam>
                           <type>pfPipeWindow*</type>
                           <parameter>pWin</parameter>
                        </methodparam>
                     </methodsynopsis></para>
                  <para>This method is used to initialize a pipe window. It is called as soon as the pipe window is opened.</para>
               </section>
               <section>
                  <title><methodname>getFrameBufferAttrs()</methodname></title>
                  <indexterm>
                     <primary>vrj::PfApp</primary>
                     <secondary>getFrameBufferAttrs() method</secondary>
                  </indexterm>
                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>
                        <type>std::vector&lt;int&gt;</type>
                        <methodname>getFrameBufferAttrs</methodname>
                        <void/>
                     </methodsynopsis></para>
                  <para>This method returns the needed parameters for the Performer frame buffer. Stereo, double buffering, depth buffering, and RGBA are all requested by default.</para>
               </section>
               <section>
                  <title><methodname>drawChan()</methodname></title>
                  <indexterm>
                     <primary>vrj::PfApp</primary>
                     <secondary>drawChan() method</secondary>
                  </indexterm>
                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>
                        <void/>
                        <methodname>drawChan</methodname>
                        <methodparam>
                           <type>pfChannel*</type>
                           <parameter>chan</parameter>
                        </methodparam>
                        <methodparam>
                           <type>void*</type>
                           <parameter>chandata</parameter>
                        </methodparam>
                     </methodsynopsis></para>
                  <para>This is the method called in the channel draw function to do the actual rendering. For most programs, the default behavior of this function is correct. It makes the following calls:</para>
                  <programlisting>chan-&gt;clear();
pfDraw();</programlisting>
                  <para>Advanced users may want to override this behavior for complex rendering effects such as overlays or multi-pass rendering. (See the OpenGL Performer manual pages about overriding the draw traversal function.) This function is the draw traversal function but with the projections set correctly for the given displays and eye. Prior to the invocation of this method, <varname>chan</varname> is ready to draw.</para>
               </section>
               <section>
                  <title><methodname>preDrawChan()</methodname></title>
                  <indexterm>
                     <primary>vrj::PfApp</primary>
                     <secondary>preDrawChan() method</secondary>
                  </indexterm>
                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>
                        <type>void</type>
                        <methodname>preDrawChan</methodname>
                        <methodparam>
                           <type>pfChannel*</type>
                           <parameter>chan</parameter>
                        </methodparam>
                        <methodparam>
                           <type>void*</type>
                           <parameter>chandata</parameter>
                        </methodparam>
                     </methodsynopsis></para>
                  <para>This is the function called by the <emphasis>default</emphasis> <methodname>drawChan()</methodname> member function before clearing the channel and drawing the next frame (<function>pfFrame()</function>).</para>
               </section>
               <section>
                  <title><methodname>postDrawChan()</methodname></title>
                  <indexterm>
                     <primary>vrj::PfApp</primary>
                     <secondary>postDrawChan() method</secondary>
                  </indexterm>
                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>
                        <void/>
                        <methodname>postDrawChan</methodname>
                        <methodparam>
                           <type>pfChannel*</type>
                           <parameter>chan</parameter>
                        </methodparam>
                        <methodparam>
                           <type>void*</type>
                           <parameter>chandata</parameter>
                        </methodparam>
                     </methodsynopsis></para>
                  <para>This is the function called by the <emphasis>default</emphasis> <methodname>drawChan()</methodname> member function after clearing the channel and drawing the next frame (<function>pfFrame()</function>).</para>
               </section>
            </section>
         </section>
         <section id="opensg-app-sect">
            <title>OpenSG Applications</title>
            <indexterm>
               <primary>application programming</primary>
               <secondary>OpenSG</secondary>
            </indexterm>
            <para>This section explains how to use the OpenSG scene graph in a VR Juggler application. OpenSG is an opensource scenegraph that is available at <ulink url="http://www.opensg.org/">www.opensg.org</ulink>.</para>
            <para>An OpenSG VR Juggler must derive from <classname>vrj::OpenSGApp</classname><indexterm>
                  <primary>classes</primary>
                  <secondary>vrj::OpenSGApp</secondary>
               </indexterm>. The <classname>vrj::OpenSGApp</classname> class is derived from the <classname>vrj::GlApp</classname> presented previously, which in turn derives from <classname>vrj::App</classname>. <classname>vrj::OpenSGApp</classname> extends <classname>vrj::GlApp</classname> by adding methods that deal with scene graph initialization and access. <emphasis>[Insert diagram ref]</emphasis> shows how <classname>vrj::OpenSGApp</classname> fits into the class hierarchy of an OpenSG VR Juggler application.</para>
            <figure float="1" id="vjOpenSGApp-class-diag">
               <title><classname>vrj::OpenSGApp</classname> application class</title>
               <mediaobject>
                  <imageobject>
                     <imagedata fileref="figures/userPfApp_hierarchy.png" format="PNG" align="center" scalefit="1"/>
                  </imageobject>
               </mediaobject>
            </figure>
            <para>The two main application methods for <classname>vrj::OpenSGApp</classname> VR Juggler applications are <methodname>initScene()</methodname> and <methodname>getSceneRoot()</methodname><indexterm>
                  <primary>vrj::OpenSGApp</primary>
                  <secondary>extensions to vrj::GlApp</secondary>
               </indexterm>. These are called by the OpenSG application class wrapper to initialize the application scene graph and to get the root of the scene graph respectively. They must be implemented by the application (they are pure virtual methods within <classname>vrj::OpenSGApp</classname>). The rest of this section gives a more detailed description of these methods and some sample code to illustrate the concepts presented.</para>
            <section>
               <title>Scene Graph Initialization: <methodname>vrj::OpenSGApp::initScene()</methodname></title>
               <indexterm>
                  <primary>vrj::OpenSGApp</primary>
                  <secondary>initScene() method</secondary>
               </indexterm>
               <indexterm>
                  <primary>application programming</primary>
                  <secondary>OpenSG</secondary>
                  <tertiary>scenegraph initialization</tertiary>
               </indexterm>
               <para>In an application using OpenSG, the scene graph must be initialized before it can be used. The method <methodname>vrj::OpenSGApp::initScene()</methodname> is provided for that purpose. Within this method, the root of the application scene graph should be created, and any required models should be loaded and attached to the root in some way. The exact mechanisms for accomplishing this will vary depending on what the application will do.</para>
               <para>During the api initialization, <methodname>vrj::OpenSGApp::initScene()</methodname> is invoked. This happens after <methodname>OSG::osgInit()</methodname> has been called, so OpenSG should be fully initialized and ready to be used.</para>
            </section>
            <section>
               <title>Scene Graph Access: <methodname>vrj::OpenSGApp::getSceneRoot()</methodname></title>
               <indexterm>
                  <primary>vrj::OpenSGApp</primary>
                  <secondary>getSceneRoot() method</secondary>
               </indexterm>
               <indexterm>
                  <primary>application programming</primary>
                  <secondary>OpenSG</secondary>
                  <tertiary>scenegraph access</tertiary>
               </indexterm>
               <para>In order for OpenSG to render the application scene graph, it must get access to the scene graph root. The method <methodname>vrj::OpenSGApp::getSceneRoot()</methodname> will be called by the OpenSG application class wrapper so that it can get access to the currently active scene graph whenever the wrapper needs to use it (ex. rendering, updating). Since the job of <methodname>getSceneRoot()</methodname> is straightforward, its implementation can be very simple. A typical implementation will have a single statement that returns a member variable that holds a pointer to the current scene graph root node.</para>
               <section>
                  <title>Possible Misuses</title>
                  <para>Do not do any cpu-heavy processing in this method. Because this method is called frequently, it should only do the minimum amount of processing necessary to return the root scene graph node. In most cases this method should only be one line of code. See the following code for an example.</para>
                  <programlisting>virtual OSG::NodePtr getSceneRoot()
{
   return mSceneRoot;  // Return the root of the graph
}</programlisting>
                  <para></para>
                  <para>If you need to update the scene graph, you should use either <methodname>preFrame()</methodname>, <methodname>intraFrame()</methodname>, or <methodname>postFrame()</methodname>.</para>
               </section>
            </section>
            <section>
               <title>Tutorial: Loading a Model with OpenSG</title>
               <indexterm>
                  <primary>tutorial</primary>
                  <secondary>loading a model with OpenSG</secondary>
               </indexterm>
               <table>
                  <title>Tutorial Overview</title>
                  <tgroup cols="2">
                     <tbody>
                        <row>
                           <entry>Description</entry>
                           <entry>Simple OpenSG application that loads a model</entry>
                        </row>
                        <row>
                           <entry>Objectives</entry>
                           <entry>Understand how to load a model, add it to a scene graph, and return the root to VR Juggler</entry>
                        </row>
                        <row>
                           <entry>Member functions</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><methodname>vrj::PfApp::initScene()</methodname></para>
                                 </listitem>
                                 <listitem>
                                    <para><methodname>vrj::PfApp::getScene()</methodname></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                        <row>
                           <entry>Directory</entry>
                           <entry><filename>$VJ_BASE_DIR/share/vrjuggler/test/Draw/OpenSG/OpenSGNav</filename></entry>
                        </row>
                        <row>
                           <entry>Files</entry>
                           <entry><itemizedlist>
                                 <listitem>
                                    <para><filename>OpenSGNav.h</filename></para>
                                 </listitem>
                                 <listitem>
                                    <para><filename>OpenSGNav.cpp</filename></para>
                                 </listitem>
                              </itemizedlist></entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <!-- NEED example app for OpenSG
               <section>
                  <title>Class Declaration</title>
                  <para>The following application class is called <classname>simplePfApp</classname>. It is derived from <classname>vrj::PfApp</classname> and has custom <methodname>initScene()</methodname> and <methodname>getScene()</methodname> methods declared. Note that this application uses <methodname>preForkInit()</methodname> which will be discussed later. Refer to <filename>simplePfApp.h</filename> for the implementations of <methodname>preForkInit()</methodname> and <methodname>setModel()</methodname>.</para>
                  <programlisting linenumbering="numbered">class simplePfApp : public vrj::PfApp
{
public:
   simplePfApp();
   virtual ~simplePfApp();

   virtual void preForkInit();
   virtual void initScene();
   virtual pfGroup* getScene();
   void setModel(std::string modelFile);

public:
   std::string    mModelFileName;

   pfGroup*       mLightGroup;
   pfLightSource* mSun;
   pfGroup*       mRootNode;
   pfNode*        mModelRoot;
};</programlisting>
               </section>
               <section>
                  <title>The <methodname>initScene()</methodname> Member Function</title>
                  <para>The implementation of <methodname>initScene()</methodname> is in <filename>simplePfApp.cpp</filename>. Within this method, we create the scene graph root node, the lighting node, and load a user-specified model. The implementation follows:</para>
                  <programlistingco>
                     <areaspec>
                        <area coords="4" id="cr-rootnode.create"/>
                        <area coords="7" id="cr.light.source.create"/>
                        <area coords="17" id="cr.model.load"/>
                        <areaset coords="" id="cr.scenegraph.add.all">
                           <area coords="20" id="cr.scenegraph.add.model"/>
                           <area coords="21" id="cr.scenegraph.add.light"/>
                        </areaset>
                     </areaspec>
                     <programlisting linenumbering="numbered">void simplePfApp::initScene ()
{
   // Allocate all the nodes needed
   mRootNode = new pfGroup;

   // Create the SUN light source
   mLightGroup = new pfGroup;
   mSun = new pfLightSource;
   mLightGroup-&gt;addChild(mSun);
   mSun-&gt;setPos(0.3f, 0.0f, 0.3f, 0.0f);
   mSun-&gt;setColor(PFLT_DIFFUSE, 1.0f, 1.0f, 1.0f);
   mSun-&gt;setColor(PFLT_AMBIENT, 0.3f, 0.3f, 0.3f);
   mSun-&gt;setColor(PFLT_SPECULAR, 1.0f, 1.0f, 1.0f);
   mSun-&gt;on();

   // - LOAD THE MODEL - //
   mModelRoot = pfdLoadFile(mModelFileName.c_str());

   // - CONSTRUCT STATIC STRUCTURE OF SCENE GRAPH - //
   mRootNode-&gt;addChild(mModelRoot);
   mRootNode-&gt;addChild(mLightGroup);
}</programlisting>
                     <calloutlist>
                        <callout arearefs="rootnode.create">
                           <para>First, the root node is constructed as a <classname>pfGroup</classname> object.</para>
                        </callout>
                        <callout arearefs="light.source.create">
                           <para>Next, some steps are taken to create a light source for the application.</para>
                        </callout>
                        <callout arearefs="model.load">
                           <para>Finally, the model is loaded using <function>pfdLoadFile()</function>, and the model scene graph root node is stored in <varname>mModelRoot</varname>. (The model loader must be initialized prior to calling <function>pfdLoadFile()</function>. This is done in <methodname>preForkInit()</methodname>.)</para>
                        </callout>
                        <callout arearefs="scenegraph.add.all">
                           <para>Finally, the model and the light source nodes are added as children of the root.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>
               <section>
                  <title>The <methodname>getScene()</methodname> Member Function</title>
                  <para>The Performer Draw Manager will call the application's <methodname>getScene()</methodname> method to get the root of the scene graph. The implementation of this method can be found in <filename>simplePfApp.h</filename>. The code is as follows:</para>
                  <programlisting>pfGroup* simplePfApp::getScene ()
{
   return mRootNode;
}</programlisting>
                  <para>The simplicity of this method implementation is not limited to the simple tutorial from which it is taken. All Performer-based VR Juggler applications can take advantage of this idiom where the root node is a member variable returned in <methodname>getScene()</methodname>.</para>
               </section>
-->
            </section>
         </section>
         <section>
            <title>VTK Applications</title>
            <indexterm>
               <primary>application programming</primary>
               <secondary>VTK</secondary>
            </indexterm>
            <para></para>
         </section>
      </chapter>
      <chapter id="porting.CAVElib.chapter">
         <title>Porting to VR Juggler from the <trademark>CAVElib</trademark></title>
         <indexterm>
            <primary>porting applications from</primary>
            <secondary><trademark>CAVElib</trademark></secondary>
         </indexterm>
         <indexterm>
            <primary><trademark>CAVElib</trademark></primary>
            <secondary>porting to VR Juggler</secondary>
         </indexterm>
         <para>In this chapter, we give some methods for porting an application written with the <trademark>CAVElib</trademark> software to VR Juggler. We explain the process for an OpenGL application. Throughout, we compare and contrast the techniques used by VR Juggler and the <trademark>CAVElib</trademark> software, and we translate concepts familiar to <trademark>CAVElib</trademark> programmers into VR Juggler terms.</para>
         <section>
            <title>The Initialize, Draw, and Frame Routines</title>
            <para>In the <trademark>CAVElib</trademark>, the initialize, draw, and frame routines are known as <firstterm>callbacks</firstterm> implemented with C function pointers. In VR juggler, the equivalent routines are <quote>called back</quote> using an application object. An application object is a C++ class that defines methods to encapsulate the functionality of the application within a single C++ object.</para>
            <section>
               <title>In <trademark>CAVElib</trademark></title>
               <para>The following lists the draw, frame, and initialize routines used in the <trademark>CAVElib</trademark> software.</para>
               <itemizedlist>
                  <listitem>
                     <para>Draw: An application's display callback function is defined by passing a function pointer to <function>CAVEDisplay()</function></para>
                  </listitem>
                  <listitem>
                     <para>Frame: The frame function is defined with <function>CAVEFrameFunction()</function></para>
                  </listitem>
                  <listitem>
                     <para>Init: The initialization callback is defined using <function>CAVEInitApplication()</function></para>
                  </listitem>
               </itemizedlist>
            </section>
            <section>
               <title>In VR Juggler</title>
               <para>With VR Juggler, no C function pointers are necessary, but a pointer to an application object must be given to the VR Juggler kernel. As described in earlier sections of this chapter, the first step is to derive a new application class from <classname>vrj::GlApp</classname>. For more information on application objects, it may be helpful to review <xref linkend="ch2"/>. Briefly, the application class definition would appear similar to the following:</para>
               <programlisting>class MyApplication : public vrj::GlApp
{
   ...
};</programlisting>
               <para>The draw, frame, and initialize routine concepts in VR Juggler are presented in the following list.</para>
               <itemizedlist>
                  <listitem>
                     <para>Draw: An application's display <quote>callback</quote> function is defined by a member function called <methodname>draw()</methodname> in the derived class. This is where OpenGL rendering commands such as <function>glBegin()</function>, <function>glVertex()</function>, etc. are placed.</para>
                  </listitem>
                  <listitem>
                     <para>Frame: Calculations such as navigation, collision, physics, artificial intelligence, etc. are often placed in the frame function. The frame function is split across three member functions:</para>
                     <orderedlist>
                        <listitem>
                           <para><methodname>MyApplication::preFrame()</methodname>, called before <methodname>draw()</methodname></para>
                        </listitem>
                        <listitem>
                           <para><methodname>MyApplication::intraFrame()</methodname>, called during <methodname>draw()</methodname></para>
                        </listitem>
                        <listitem>
                           <para><methodname>MyApplication::postFrame()</methodname>, called after <methodname>draw()</methodname></para>
                        </listitem>
                     </orderedlist>
                  </listitem>
                  <listitem>
                     <para>Init: There is an initialization member function for data and an initialization member function for creating context-specific data (display lists, texture objects). The latter is called for each display context in the system. These two member functions are:</para>
                     <orderedlist>
                        <listitem>
                           <para><methodname>MyApplication::init()</methodname>, called once per application startup</para>
                        </listitem>
                        <listitem>
                           <para><methodname>MyApplication::contextInit()</methodname>, called once per display context <emphasis>creation</emphasis></para>
                        </listitem>
                     </orderedlist>
                  </listitem>
               </itemizedlist>
               <para>Readers who find some of these concepts unfamiliar are encouraged to read <xref linkend="ogl-app-sect"/>. For information about context-specific data, refer to <xref linkend="cs-data-intro-sec"/>.</para>
            </section>
         </section>
         <section>
            <title>Getting Input from Devices</title>
            <para>Getting input from the hardware devices is conceptually the same, but the implementations are quite different between the <trademark>CAVElib</trademark> software and VR Juggler.</para>
            <section>
               <title>In <trademark>CAVElib</trademark></title>
               <para>To get tracking information, the following functions are used:</para>
               <itemizedlist>
                  <listitem>
                     <para><function>CAVEGetPosition(id, pos)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>CAVEGetOrientation(id, orient)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>CAVEGetVector(id, vec)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>CAVEGetSensorPosition(sensor, coords, pos)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>CAVEGetSensorOrientation(sensor, coords, orient)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>CAVEGetSensorVector(sensor, id, vec)</function></para>
                  </listitem>
               </itemizedlist>
               <para>For button input, the following macros are used:</para>
               <itemizedlist>
                  <listitem>
                     <para><constant>CAVEBUTTON1</constant>, <constant>CAVEBUTTON2</constant>, <constant>CAVEBUTTON3</constant>, <constant>CAVEBUTTON4</constant>, <constant>CAVE_JOYSTICK_X</constant>, and <constant>CAVE_JOYSTICK_Y</constant></para>
                  </listitem>
                  <listitem>
                     <para><function>CAVEButtonChange()</function></para>
                  </listitem>
               </itemizedlist>
            </section>
            <section>
               <title>In VR Juggler</title>
               <para>To get device input, use the classes derived from <classname>gadget::DeviceInterface</classname>. They include the following:</para>
               <itemizedlist>
                  <listitem>
                     <para><classname>gadget::PositionInterface</classname> (for trackers and other positional devices)</para>
                  </listitem>
                  <listitem>
                     <para><classname>gadget::DigitalInterface</classname> (for buttons and other on/off devices)</para>
                  </listitem>
                  <listitem>
                     <para><classname>gadget::AnalogInterface</classname> (for potentiometers and other multi-range data devices)</para>
                  </listitem>
               </itemizedlist>
               <para>For more information about the VR Juggler device interfaces, refer to <xref linkend="ch3"/>. A tutorial on getting device input in VR Juggler applications can be found in <xref linkend="get-input-sect"/>.</para>
            </section>
         </section>
         <section>
            <title>Configuration</title>
            <para>Configuration of VR Juggler and the <trademark>CAVElib</trademark> software is very different. The differences are too numerous to list here, but we give a brief overview and a pointer to the documentation that explains configuration of VR Juggler.</para>
            <section>
               <title>In <trademark>CAVElib</trademark></title>
               <para>All configurable parameters go in a single file called <filename>.caverc</filename>. The configuration mechanism is proprietary and not usable by external VR system software. In particular, VR Juggler cannot get its configuration information from an existing <filename>.caverc</filename> file.</para>
            </section>
            <section>
               <title>In VR Juggler</title>
               <para>Configuration of VR Juggler is much more powerful and flexible than what is used by the <trademark>CAVElib</trademark> software. As a result, it is also more complex. All configurable parameters could be in one or more files with any names desired. VR Juggler comes with example configuration files that may be found in the directory <filename>$VJ_BASE_DIR/share/vrjuggler/data/configFiles</filename>.</para>
               <para>The VR Juggler configuration system is completely extensible and could be used outside of VR Juggler. Indeed, it could be used outside of any VR paradigm altogether. Refer to the Configuration Guide for more information on configuring VR Juggler.</para>
            </section>
         </section>
         <section>
            <title>Important Notes</title>
            <para>Finally, before we get to the source code, there are some important notes about programming VR Juggler applications in general. Please read these carefully and refer to the indicated chapters for more information as necessary.</para>
            <section>
               <title>Shared Memory</title>
               <para>Unlike the <trademark>CAVElib</trademark> software, VR Juggler does not have to manage shared memory with other VR Juggler instances. Thus, when writing a VR Juggler application, memory can be created as in a normal, single-threaded C or C++ application.</para>
            </section>
            <section>
               <title>OpenGL Context-Specific Data</title>
               <para>As a result of the shared memory model described above, VR Juggler has different requirements for context-specific data than the <trademark>CAVElib</trademark> software. Information such as display lists and texture objects must be managed using context-specific data. A <firstterm>display context</firstterm> is the location to which OpenGL rendering commands draw. Compiled OpenGL commands such as display lists do not get shared across multiple contexts (or windows), and thus, they must be initialized once per display context. In a VR Juggler application, these OpenGL initializations must be placed in <methodname>vrj::GlApp::contextInit()</methodname>. It is called once per display context after each context has become active. For a more detailed description of these concepts and a tutorial on how to use them, please refer to <xref linkend="cs-data-intro-sec"/>.</para>
            </section>
         </section>
         <section>
            <title>Source Code</title>
            <para>This final section is the heart of the porting discussion. We present some source code as a means to illustrate how <trademark>CAVElib</trademark> concepts map to VR Juggler.</para>
            <section>
               <title>The Form of a Basic <trademark>CAVElib</trademark> Program</title>
               <programlisting linenumbering="numbered">void app_shared_init();
void app_compute_init();
void app_init_gl();
void app_draw();
void app_compute();

void main(int argc, char **argv)
{
   CAVEConfigure(&amp;argc,argv,NULL);
   app_shared_init(argc,argv);
   CAVEInit();
   CAVEInitApplication(app_init_gl,0);
   CAVEDisplay(app_draw,0);
   app_compute_init(argc,argv);
   while (!getbutton(ESCKEY))
   {
       app_compute();
   }
   CAVEExit();
}</programlisting>
            </section>
            <section>
               <title>The Form of a Basic VR Juggler Program</title>
               <programlisting linenumbering="numbered">class MyApplication : public vrj::GlApp
{
public:
// Data callbacks  (Do not put OpenGL code here)
   virtual void init();
   virtual void preFrame();
   virtual void intraFrame();
   virtual void postFrame();
      
// OpenGL callbacks (put only OpenGL code here)
   virtual void contextInit();
   virtual void draw();
};

int main(int argc, char* argv[]) 
{
   // configure kernel with *.config files
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   for(int i=1; i&lt;argc; i++)
   {
      // loading config file passed on command line...
      kernel-&gt;loadConfigFile(argv[i]);
   }

   // start the kernel
   kernel-&gt;start();

   // set the application for the kernel to run
   MyApplication* application = new MyApplication();
   kernel-&gt;setApplication(application);

   // Block until the kernel exits.
   kernel-&gt;waitForKernelStop();

   return 0;
}</programlisting>
            </section>
         </section>
      </chapter>
      <chapter>
         <title>Porting to VR Juggler from GLUT</title>
         <indexterm>
            <primary>porting applications from</primary>
            <secondary>GLUT</secondary>
         </indexterm>
         <indexterm>
            <primary>GLUT</primary>
            <secondary>porting to VR Juggler</secondary>
         </indexterm>
         <para>In this chapter, we give some methods for porting an application written with GLUT to VR Juggler. Throughout, we compare and contrast the techniques used by VR Juggler and GLUT, and we translate concepts familiar to GLUT programmers into VR Juggler terms.</para>
         <section>
            <title>Window Creation and Management</title>
            <para>In VR Juggler, window creation is done behind the scenes based on configuration file settings. There are two display types: Surface and Simulator. A Surface Display can be put into three modes: stereo, right eye, or left eye. Most interesting is the stereo mode. Stereo mode requires special hardware to display stereo, and it creates the most immersive experience. A Simulator Display is special because it emulates an active VR system. It can show the all active user head positions and orientation, any active devices such as gloves or wands, and any Surface Displays. The simulator window is nice for debugging tracking systems and for visualizing configured Surface Displays.</para>
         </section>
         <section>
            <title>The Initialize, Draw, and Frame Routines</title>
            <section>
               <title>In GLUT</title>
               <para>In GLUT, the initialize, draw, and frame routines are known as <firstterm>callbacks</firstterm> implemented with C function pointers. In VR juggler, the equivalent routines are <firstterm>called back</firstterm> using an application object. An application object is a C++ class that defines methods to encapsulate the functionality of the application within a single C++ object.</para>
               <itemizedlist>
                  <listitem>
                     <para>Draw: OpenGL commands are placed in the draw routine. The callback function is defined by passing a function pointer to <function>glutDisplayFunc()</function>.</para>
                  </listitem>
                  <listitem>
                     <para>Frame: Operations on application data are done within the frame routine. No OpenGL commands are allowed here because the display window is undefined at this point. The frame function is defined with <function>glutIdleFunc()</function>. This function generally does a <function>glutPostRedisplay()</function> to cause the display callback to be executed.</para>
                  </listitem>
                  <listitem>
                     <para>Init: There is no callback for initialization. Data initialization is done usually before the application starts. Context initialization is done during the first run of the function set with <function>glutDisplayFunc()</function> (once for each window opened).</para>
                  </listitem>
               </itemizedlist>
            </section>
            <section>
               <title>In VR Juggler</title>
               <para>With VR Juggler, no C function pointers are necessary, but a pointer to an application object must be given to the VR Juggler kernel. As described in earlier sections of this chapter, the first step is to derive a new application class from <classname>vrj::GlApp</classname>. For more information on application objects, it may be helpful to review <xref linkend="ch2"/>. Briefly, the application class definition would appear similar to the following:</para>
               <programlisting>class MyApplication : public vrj::GlApp
{
   ...
};</programlisting>
               <para>The draw, frame, and initialize routine concepts in VR Juggler are presented in the following list.</para>
               <itemizedlist>
                  <listitem>
                     <para>Draw: An application's display <quote>callback</quote> function is defined by a new member function called <methodname>draw()</methodname> in the derived class. This is where OpenGL rendering commands such as <function>glBegin()</function>, <function>glVertex()</function>, etc. are placed.</para>
                  </listitem>
                  <listitem>
                     <para>Frame: Calculations such as navigation, collision, physics, artificial intelligence, etc. are often placed in the frame function. The frame function is split across three member functions:</para>
                     <orderedlist>
                        <listitem>
                           <para><methodname>MyApplication::preFrame()</methodname>, called before <methodname>draw()</methodname></para>
                        </listitem>
                        <listitem>
                           <para><methodname>MyApplication::intraFrame()</methodname>, called during <methodname>draw()</methodname></para>
                        </listitem>
                        <listitem>
                           <para><methodname>MyApplication::postFrame()</methodname>, called after <methodname>draw()</methodname></para>
                        </listitem>
                     </orderedlist>
                  </listitem>
                  <listitem>
                     <para>Init: There is an initialization member function for data and an initialization member function for creating context-specific data (display lists, texture objects). The latter is called for each display context in the system. These two member functions are:</para>
                     <orderedlist>
                        <listitem>
                           <para><methodname>MyApplication::init()</methodname>, called once per application startup</para>
                        </listitem>
                        <listitem>
                           <para><methodname>MyApplication::contextInit()</methodname>, called once per display context creation</para>
                        </listitem>
                     </orderedlist>
                  </listitem>
               </itemizedlist>
               <para>Readers who find some of these concepts unfamiliar are encouraged to read <xref linkend="ogl-app-sect"/>. For information about context-specific data, refer to <xref linkend="cs-data-intro-sec"/>.</para>
            </section>
         </section>
         <section>
            <title>Getting Input from Devices</title>
            <section>
               <title>In GLUT</title>
               <para>For keyboard input, the following functions are used:</para>
               <itemizedlist>
                  <listitem>
                     <para><function>glutKeyboardFunc(OnKeyboardDown)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>glutKeyboardUpFunc(OnKeyboardUp)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>glutSpecialFunc(OnSpecialKeyboardDown)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>glutSpecialUpFunc(OnSpecialKeyboardUp)</function></para>
                  </listitem>
               </itemizedlist>
               <para>For mouse input, the following functions are used:</para>
               <itemizedlist>
                  <listitem>
                     <para><function>glutMouseFunc(OnMouseButton)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>glutMotionFunc(OnMousePosition)</function></para>
                  </listitem>
                  <listitem>
                     <para><function>glutPassiveMotionFunc(OnMousePosition)</function></para>
                  </listitem>
               </itemizedlist>
            </section>
            <section>
               <title>In VR Juggler</title>
               <para>To get device input, use the classes derived from <classname>gadget::DeviceInterface</classname>. They include the following:</para>
               <itemizedlist>
                  <listitem>
                     <para><classname>gadget::PositionInterface</classname> (for trackers and other positional devices)</para>
                  </listitem>
                  <listitem>
                     <para><classname>gadget::DigitalInterface</classname> (for buttons and other on/off devices)</para>
                  </listitem>
                  <listitem>
                     <para><classname>gadget::AnalogInterface</classname> (for potentiometers and other multi-range data devices)</para>
                  </listitem>
               </itemizedlist>
               <para>For more information about the VR Juggler device interfaces, refer to <xref linkend="ch3"/>. A tutorial on getting device input in VR Juggler applications can be found in <xref linkend="get-input-sect"/>.</para>
            </section>
         </section>
         <section>
            <title>Configuration</title>
            <para>Configuration of GLUT applications is quite different than configuration of VR Juggler applications. In particular, VR Juggler is much more dynamic because configurations are maintained as files separate from the application. In GLUT, the configuration must be written into the application somehow. This can lead to very static, hard-coded configurations.</para>
            <section>
               <title>In GLUT</title>
               <para>There is no built-in configuration system. All system settings are coded using the GLUT API.</para>
            </section>
            <section>
               <title>In VR Juggler</title>
               <para>VR Juggler has a powerful and flexible configuration system. As a result, it is also complex. All configurable parameters could be in one or more files with any names desired. VR Juggler comes with example configuration files that may be found in the directory <filename>$VJ_BASE_DIR/share/vrjuggler/data/configFiles</filename>.</para>
               <para>The VR Juggler configuration system is completely extensible and could be used outside of VR Juggler. Indeed, it could be used outside of any VR paradigm altogether. Refer to the VjControl book for more information on configuring VR Juggler.</para>
            </section>
         </section>
         <section>
            <title>Important Notes</title>
            <para>Finally, before we get to the source code, there are some important notes about programming VR Juggler applications in general. Please read these carefully and refer to the indicated chapters for more information as necessary.</para>
            <section>
               <title>Shared Memory</title>
               <para>VR Juggler is multi-threaded, and it uses a shared memory model across all threads. Thus, when writing a VR Juggler application, memory can be created as in a normal, single-threaded C or C++ application. VR Juggler is written entirely in C++, and as such, new and delete must be used instead of <function>malloc()</function> and <function>free()</function>.</para>
            </section>
            <section>
               <title>OpenGL Context-Specific Data</title>
               <para>As a result of the shared memory model described above, VR Juggler has different requirements for context-specific data than GLUT. Information such as display lists and texture objects must be managed using context-specific data. A <firstterm>display context</firstterm> is the location to which OpenGL rendering commands draw. Compiled OpenGL commands such as display lists do not get shared across multiple contexts (or windows), and thus, they must be initialized once per display context. In a VR Juggler application, these OpenGL initializations must be placed in <methodname>vrj::GlApp::contextInit()</methodname>. It is called once per display context after each context has become active. For a more detailed description of these concepts and a tutorial on how to use them, please refer to <xref linkend="cs-data-intro-sec"/>.</para>
            </section>
         </section>
         <section>
            <title>Source Code</title>
            <para>This final section is the heart of the porting discussion. We present some source code as a means to illustrate how GLUT concepts map to VR Juggler.</para>
            <section>
               <title>The Form of a Basic GLUT Program</title>
               <programlisting linenumbering="numbered">void main(int argc, char* argv[])
{
   /* initialize the application data here */
   OnApplicationInit();

   /* create a window to render graphics in
    * In VR Juggler, window creation is done for you based on your configuration file
    * settings.
    */
   glutInitWindowSize( 640, 480 );
   glutInit( &amp;argc, argv );
   glutInitDisplayMode( GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE );
   glutCreateWindow( "GLUT application" );

   /* display callbacks.
    * NOTE: the first time OnIdle is called is when you should 
    *       initialize the display context for each window
    *       (doing this is analogous to VR Juggler's 
    *       vrj::GlApp::contextInit() function)
    */
   glutReshapeFunc( OnReshape );
   glutIdleFunc( OnIdle );
   glutDisplayFunc( OnIdle );

   /* tell glut to not call the keyboard callback repeatedly 
    * when holding down a key. (uses edge triggering, like the mouse does)
    */
   glutIgnoreKeyRepeat( 1 );

   /* keyboard callback functions. */
   glutKeyboardFunc( OnKeyboardDown );
   glutKeyboardUpFunc( OnKeyboardUp );
   glutSpecialFunc( OnSpecialKeyboardDown );
   glutSpecialUpFunc( OnSpecialKeyboardUp );

   /* mouse callback functions... */
   glutMouseFunc( OnMouseClick );
   glutMotionFunc( OnMousePos );
   glutPassiveMotionFunc( OnMousePos );

   /* start the application loop, your callbacks will now be called
    * time for glut to sit and spin.  In Juggler this is the same as the while(1)
    * (see below)
    */
   glutMainLoop();
}</programlisting>
            </section>
            <section>
               <title>The Form of a Basic VR Juggler Program</title>
               <programlisting linenumbering="numbered">class MyApplication : public vrj::GlApp
{
public:
// Data callbacks  (Do not put OpenGL code here)
   virtual void init();
   virtual void preFrame();
   virtual void intraFrame();
   virtual void postFrame();
      
// OpenGL callbacks (put only OpenGL code here)
   virtual void contextInit();
   virtual void draw();
};

int main(int argc, char* argv[]) 
{
   // configure kernel with *.config files
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   for(int i=1; i&lt;argc; i++)
   {
      // loading config file passed on command line...
      kernel-&gt;loadConfigFile(argv[i]);
   }

   // start the kernel
   kernel-&gt;start();

   // set the application for the kernel to run
   MyApplication* application = new MyApplication();
   kernel-&gt;setApplication(application);

   // Block until the kernel exits.
   kernel-&gt;waitForKernelStop();

   return 0;
}</programlisting>
            </section>
         </section>
      </chapter>
   </part>
   <part id="adv.topics.part">
      <title>Advanced Topics</title>
      <chapter id="system.interaction.chapter">
         <title>System Interaction</title>
         <para>In this part of the book, we present information for advanced users who want to create applications that take advantage of VR Juggler features such as threading, run-time reconfiguration, and device driver authoring. While we do recommend that all programmers be familiar with these topics, readers who are not familiar with the basic concepts of multi-threaded programming, for example, may find these chapters difficult to understand.</para>
      </chapter>
      <chapter id="multi-threading.chapter">
         <title>Multi-threading</title>
         <indexterm>
            <primary>multi-threading</primary>
         </indexterm>
         <para>In this chapter, we present how to use multi-threading within VR Juggler applications. Readers who are not familiar with the basic concepts of multi-threaded programming may find the following sections difficult to understand. This chapter is written with the assumption that readers already know the necessary background material and want to learn about how VR Juggler implements the concepts.</para>
         <section id="multi-threading-sect">
            <title>Techniques</title>
            <indexterm>
               <primary>multi-threading</primary>
               <secondary>techniques</secondary>
            </indexterm>
            <para>VR Juggler is a multi-threaded software system. We have built up a cross-platform abstraction for threads and synchronization primitives as part of making VR Juggler more portable. This abstraction is available to application developers. In addition, the basic VR Juggler application object interface provides a mechanism for inherent parallel programming in applications. In this section, we provide a more detailed description of these techniques and how to put them into use.</para>
            <para>To begin the discussion on multi-threaded programming with VR Juggler, we describe the techniques available to application programmers. There are three options from which programmers may choose:</para>
            <orderedlist>
               <listitem>
                  <para>Use the <methodname>vrj::App::intraFrame()</methodname> application object member function</para>
               </listitem>
               <listitem>
                  <para>Use triple-buffered data</para>
               </listitem>
               <listitem>
                  <para>Use separate threads with the <classname>vpr::Thread</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>vpr::Thread</secondary>
                     </indexterm> class</para>
               </listitem>
            </orderedlist>
         </section>
         <section id="multi-threading-classes">
            <title>Helper Classes</title>
            <indexterm zone="multi-threading-classes">
               <primary>multi-threading</primary>
               <secondary>helper classes</secondary>
            </indexterm>
            <para>All the techniques presented in the previous section require some form of synchronization to protect the data accessed by multiple threads. Developers who choose the third option and use separate threads must learn the VR Juggler thread API. This section presents all the helper classes available for multi-threaded VR Juggler application programming. We begin with the thread API and then move on to the synchronization primitive API.</para>
            <section id="using-vjThread-sect">
               <title>Using the <classname>vpr::Thread</classname> Interface</title>
               <indexterm zone="using-vjThread-sect">
                  <primary>multi-threading</primary>
                  <secondary>vpr::Thread</secondary>
               </indexterm>
               <indexterm zone="using-vjThread-sect">
                  <primary>vpr::Thread</primary>
               </indexterm>
               <para>When considering multi-threaded programming, it is important to know that with great power comes great responsibility. The power is being able to provide multiple threads of control in a single application. The responsibility is making sure those threads get along with each other and do not step on each other's data. VR Juggler is a multi-threaded library which makes it very powerful and very complex.</para>
               <para>As a cross-platform framework, VR Juggler uses an internal threading abstraction that provides a uniform interface to platform-specific threading implementations. That cross-platform interface is available to programmers to make applications multi-threaded without tying them to a specific operating system's threading implementation.</para>
               <section>
                  <title>Recommended Reading</title>
                  <para>It is assumed that readers already know the basics of multi-threaded programming including the definition of <firstterm>thread of control</firstterm><indexterm>
                        <primary>thread of control</primary>
                     </indexterm>. What is described here is how to use the VR Juggler thread interface, <classname>vpr::Thread</classname>, not how to write multi-threaded software. For that reason, it is recommended that readers be familiar with the following publications before continuing:</para>
                  <itemizedlist>
                     <listitem>
                        <para><ulink url="http://www.oreilly.com/catalog/pthread/"><emphasis>Pthreads Programming</emphasis></ulink> by Bradford Nichols, Dick Buttlar, and Jacqueline Proulx Farrell.</para>
                     </listitem>
                     <listitem>
                        <para>The <function>sproc(2)</function> manual page on IRIX or on <ulink url="http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;db=man&amp;fname=/usr/share/catman/p_man/cat2/standard/nsproc.z&amp;srch=sproc">SGI's technical publications site</ulink>.</para>
                     </listitem>
                     <listitem>
                        <para>The <function>pthread(3)</function> manual page for your operating system. The pthread functions are part of a POSIX standard and will be the same across platforms.</para>
                     </listitem>
                  </itemizedlist>
               </section>
               <section id="vjThread-desc">
                  <title>High-Level Description</title>
                  <indexterm zone="vjThread-desc">
                     <primary>vpr::Thread</primary>
                     <secondary>description of</secondary>
                  </indexterm>
                  <para>The threading interface in VR Juggler is modeled after the POSIX thread specification of POSIX.1b (formerly POSIX.4). The main difference is that VR Juggler's interface is object-oriented while POSIX threads (pthreads) are procedural. The basic principles are exactly the same, however. A function (or class method) is provided to the <classname>vpr::Thread</classname> class, and that function is executed in a thread of control that is independent of the creating thread.</para>
                  <para>Threads are spawned (initialized and begin execution) when the <classname>vpr::Thread</classname> constructor is called. That is, when instantiating a <classname>vpr::Thread</classname> object, a new thread of execution is created. The semantics of threads says that a thread can begin execution at any time after being created, and this is true with <classname>vpr::Thread</classname>s. Do not make any assumptions about when the thread will begin running. It may happen before or after the constructor returns the <classname>vpr::Thread</classname> object.</para>
                  <para>To pass arguments to threads, the common mechanism of encapsulating them in a C++ <type>struct</type> must be used. The function executed by the thread takes only a single argument of type <type>void*</type>. An argument is not required, of course, but to pass more than one argument to a thread, the best way to do this is to create a structure and pass a pointer to it to the <classname>vpr::Thread</classname> constructor.</para>
                  <para>Once a <classname>vpr::Thread</classname> object is created, it acts as an interface into controlling the thread it encapsulates. Thread signals can be sent, priority changes can be made, execution can be suspended, etc. This interface is the focus of this section.</para>
               </section>
               <section id="vjThread-use">
                  <title>Using <classname>vpr::Thread</classname></title>
                  <indexterm zone="vjThread-use">
                     <primary>vpr::Thread</primary>
                     <secondary>use</secondary>
                  </indexterm>
                  <para>Use of <classname>vpr::Thread</classname> is intended to be easy. Multi-threaded programming has enough complications without having a difficult API as well. In almost all cases, thread creation can be done in a single step, executed one of two ways:</para>
                  <orderedlist>
                     <listitem>
                        <para>Pass a function pointer to the <classname>vpr::Thread</classname> constructor along with any argument that should be passed to the function when the thread is created</para>
                     </listitem>
                     <listitem>
                        <para>Pass a <firstterm>functor</firstterm><indexterm>
                              <primary>functor</primary>
                           </indexterm> to the <classname>vpr::Thread</classname> constructor<classname></classname></para>
                     </listitem>
                  </orderedlist>
                  <para>The second appears easier, but to create the functor, an argument to the function executed by the thread may still have to be passed. The presence of the argument depends on the specific function being run by the thread. In addition to the function pointer or functor, parameters such as the priority and the stack size may be passed to the <classname>vpr::Thread</classname> constructor, but the defaults for the constructor are quite reasonable.</para>
                  <para>A minor issue with creating a <classname>vpr::Thread</classname> is the concept of functors. The topic of functors will be put off until another section. For now, just think of them as wrappers around function pointers.</para>
                  <para>Before writing code that uses <classname>vpr::Thread</classname>s, make sure that the header file <filename>vpr/Thread/Thread.h</filename> is included. Never include the platform-specific headers such as <filename>vpr/md/POSIX/Thread/ThreadPosix.h</filename>. The single file <filename>vpr/Thread/Thread.h</filename> is all that is required.</para>
               </section>
               <section>
                  <title>Creating <classname>vpr::Thread</classname>s</title>
                  <indexterm>
                     <primary>vpr::Thread</primary>
                     <secondary>creating</secondary>
                  </indexterm>
                  <para>The following example illustrates how to create a thread that will execute a function called <function>run()</function> that takes no arguments. The prototype for <function>run()</function> is: </para>
                  <programlisting>void run(void* args);</programlisting>
                  <para>This will be the same across all platforms. The thread creation code is then:</para>
                  <programlisting>vpr::Thread* thread;

thread = new vpr::Thread(run);</programlisting>
                  <para>At this point, a newly spawned thread is executing the code in <function>run()</function>. It is advisable to hang onto the variable <varname>thread</varname> so that the thread may be controlled as necessary.</para>
                  <para>That was pretty easy. What if you want to pass one or more arguments to <function>run()</function> so that its behavior can be modified based on some variables? Not surprisingly, that is fairly easy too. As mentioned above, if there is more than one argument to pass to the thread function, they will have to be collected into a <type>struct</type>, and pointer to that struct will have to be passed. A common way to do this is as follows: </para>
                  <programlisting>struct ThreadArgs
{
   int id;
   char name[40];
   // And so on...
};

void someFunc ()
{
   // Other code ...

   ThreadArgs* args;
   vpr::Thread* thread;

   args = new ThreadArgs();

   // Fill in the elements of args ...

   thread = new vpr::Thread(run, (void*) args);
}</programlisting>
                  <para>When creating a single thread, this works beautifully. If multiple threads are needed, all taking the same type of argument, there must be a separate argument structure instance for each one. A bunch of pointers can be declared, or the same pointer can be reused over and over. The address passed to each thread will be unique either way. Using this method requires that the argument memory be released before the thread exits, of course.</para>
               </section>
               <section>
                  <title>Waiting for a Thread to Complete</title>
                  <indexterm>
                     <primary>vpr::Thread</primary>
                     <secondary>joining threads</secondary>
                  </indexterm>
                  <para>Once we have a thread running, it is often useful to synchronize another thread so that its execution halts until the running thread has completed. This is called <quote>joining threads</quote>. The following example illustrates how this can be done:</para>
                  <programlisting>vpr::Thread* thread;

thread = new vpr::Thread(run);

// Do other things while the thread is going ...

thread-&gt;join();

// Now that the thread is done, continue.</programlisting>
                  <para>Here, the creator of thread can be another <classname>vpr::Thread</classname>, or it can be the main thread of execution (though it will not be that way in a VR Juggler application). In other words, any thread can create more threads and control them. What happens in this example is that thread is created and begins running. Meanwhile, the creator thread continues to do some more work and then must wait for <varname>thread</varname> to finish its work before continuing. It calls the <methodname>join()</methodname> method, a blocking call, and it will not return until <varname>thread</varname> has completed.</para>
                  <para>While it is not demonstrated here, the <methodname>join()</methodname> method can take a single argument of type <type>void**</type>. It is a pointer to a pointer where the exit status of the joined thread is stored. The operating system fills the pointed to pointer with the exit status when the thread exits.</para>
               </section>
               <section>
                  <title>Suspending and Resuming a Thread's Execution</title>
                  <indexterm>
                     <primary>vpr::Thread</primary>
                     <secondary>suspend, resume</secondary>
                  </indexterm>
                  <para>Sometimes, it may be necessary to suspend the execution of a running thread and resume it again later. There are two methods in the <classname>vpr::Thread</classname> interface that do just this. Assuming that there is already a running thread pointed to by the object <varname>thread</varname>, it can be suspended as follows:</para>
                  <programlisting>thread-&gt;suspend();</programlisting>
                  <para>Resuming execution of the suspended thread is just as easy:</para>
                  <programlisting>thread-&gt;resume();</programlisting>
                  <para>On successful completion, both methods return <constant>vpr::ReturnStatus::Succeed</constant>. If the operation could not be performed for some reason, <constant>vpr::ReturnStatus::Fail</constant> is returned to indicate error status.</para>
               </section>
               <section>
                  <title>Getting and Setting a Thread's Priority</title>
                  <indexterm>
                     <primary>vpr::Thread</primary>
                     <secondary>priority</secondary>
                  </indexterm>
                  <para>Changing the priority of a thread tells the underlying operating system how important a thread is and gives it hints about how to schedule the threads. If no value for the priority is given to the constructor, all <classname>vpr::Thread</classname>s are created with the default priority for all threads. Values higher than 0 for the priority request a higher priority when the thread is created.</para>
                  <para>Besides being able to set the priority when the thread is created, it is possible to query and to adjust the priority of a running thread. Assuming that there is already a running thread pointed to by the object <varname>thread</varname>, its priority can be requested as follows: </para>
                  <programlisting>int prio;

thread-&gt;getPrio(&amp;prio);</programlisting>
                  <para>The thread's priority is stored in <varname>prio</varname> and returned via the pointer passed to the <methodname>getPrio()</methodname> method. Setting that thread's priority is also easy:</para>
                  <programlisting>int prio;

// Assign some priority value to prio ...

thread-&gt;setPrio(prio);</programlisting>
                  <para>On successful completion, both methods return <constant>vpr::ReturnStatus::Succeed</constant>. If the operation could not be performed for some reason, <constant>vpr::ReturnStatus::Fail</constant> is returned to indicate error status.</para>
               </section>
               <section>
                  <title>Sending Signals to a Thread</title>
                  <indexterm>
                     <primary>vpr::Thread</primary>
                     <secondary>sending signals</secondary>
                  </indexterm>
                  <para>On UNIX-based systems, a signal is sent to a process using the <function>kill(2)</function> system call. With POSIX threads, signals are sent using <function>pthread_kill(3)</function>. VR Juggler's thread interface implements these ideas using a <methodname>kill()</methodname><methodname></methodname> method. There are two ways to call this method: with an argument naming the signal to be delivered to the thread or without an argument which cancels the thread's execution. The first of these is described in this section, and the second is described in the next section.</para>
                  <para>A problem does arise here, unfortunately. Signals are not supported on all operating systems (notably, Win32). The interface is consistent, but code written on IRIX will not compile on Win32 if, for example, it sends a <constant>SIGHUP</constant> to a thread. An improved thread interface is being designed to overcome problems such as this one. For now, we describe this part of the interface as though it is supported completely on all platforms.</para>
                  <para>As usual, assume there is a running thread, a pointer to which is stored in <varname>thread</varname>. To send it a signal (<constant>SIGINT</constant>, for example), use the following:</para>
                  <programlisting>thread-&gt;kill(SIGINT);</programlisting>
                  <para>The signal will be delivered to the thread by the operating system, and the thread is expected to handle it properly. This version of the <methodname>kill()</methodname> method returns <constant>vpr::ReturnStatus::Succeed</constant> if the signal is sent successfully. Otherwise, <constant>vpr::ReturnStatus::Fail</constant> is returned to indicate that an error occurred.</para>
               </section>
               <section>
                  <title>Canceling a Thread's Execution</title>
                  <indexterm>
                     <primary>vpr::Thread</primary>
                     <secondary>canceling</secondary>
                  </indexterm>
                  <para>As described in the previous section, using the <methodname>kill()</methodname> method with no argument cancels the execution of the thread. When using POSIX threads, this is actually implemented using <methodname>pthread_cancel(3)</methodname>. On IRIX with SPROC threads, a <constant>SIGKILL</constant> is sent to the thread to end its execution forcibly. The syntax for using this method is basically the same as in the previous section, but it is repeated to make that clear. Again assuming that there is a running thread with a pointer to its <classname>vpr::Thread</classname> object stored in <varname>thread</varname>, use the following:</para>
                  <programlisting>thread-&gt;kill();</programlisting>
                  <para>Unlike the syntax used to send a signal to a thread, this version of <methodname>kill()</methodname> does not have a return value.</para>
                  <para>Users of POSIX threads may be wondering if the <classname>vpr::Thread</classname> API provides a way to set cancellation points in the code. Unfortunately, it does not at this time. Extending the interface in this way is being considered, but cancellation points do not have meaning with all thread implementations.</para>
               </section>
               <section>
                  <title>Requesting the Current Thread's Identifier</title>
                  <indexterm>
                     <primary>vpr::Thread</primary>
                     <secondary>self</secondary>
                  </indexterm>
                  <para>Lastly, it is common to request the currently running thread's identifier. This only makes sense when called from a point on that thread's flow of execution. (In POSIX threads, this is the notion of <quote>self</quote>. For IRIX SPROC threads, this means getting the process ID.) The <classname>vpr::Thread</classname> API provides a static method that can be called at any time in the thread that is currently running. It returns a pointer to a <classname>vpr::BaseThread</classname> (the basic type from which <classname>vpr::Thread</classname> inherits its interface). The syntax is as follows:</para>
                  <programlisting>vpr::BaseThread* my_id;

my_id = vpr::Thread::self();</programlisting>
                  <para>The returned pointer can then be used to perform all of the previously described operations on the current thread.</para>
               </section>
               <section>
                  <title>The Gory Details</title>
                  <indexterm>
                     <primary>vpr::Thread</primary>
                     <secondary>details</secondary>
                  </indexterm>
                  <para>The current threading implementation in VR Juggler is a little difficult to understand. The code is not complicated at all, but because all platform-specific implementations are referred to as <classname>vpr::Thread</classname>s, the details can get lost in the shuffle. To begin, the current list of platform-specific thread implementation wrapper classes are:</para>
                  <itemizedlist>
                     <listitem>
                        <para><classname>vpr::ThreadSGI</classname>: A wrapper around IRIX SPROC threads (refer to the <function>sproc(2)</function> manual page for more information)</para>
                     </listitem>
                     <listitem>
                        <para><classname>vpr::ThreadPosix</classname>: A wrapper around POSIX threads (both Draft 4 and Draft 10 of the standard are supported)</para>
                     </listitem>
                     <listitem>
                        <para><classname>vpr::ThreadNSPR</classname>: A wrapper around Netscape Portable Runtime threads</para>
                     </listitem>
                  </itemizedlist>
                  <para>The interface itself is defined in <classname>vpr::BaseThread</classname>, and all of the above classes inherit from that class.</para>
                  <para>The threading implementation used is chosen when VR Juggler is compiled. To use a certain type of thread system, be sure that the version of VR Juggler in use was compiled with the type of threads desired. When the VR Juggler build is configured, preprocessor <function>#define</function> statements are made in <filename>vpr/vprDefines.h</filename> that describe the threading system to use. Based on that, the header file <filename>vpr/Thread/Thread.h</filename> makes several <type>typedef</type>s that set up one of the platform-specific thread implementations to act as the <classname>vpr::Thread</classname> interface. For example, if compiling on Win32, the class <classname>vpr::ThreadNSPR</classname> is <type>typedef</type>'d to be <classname>vpr::Thread</classname>. Since the interface is consistent among all the wrappers, everything works as though that was the way it was written to behave.</para>
                  <para>The current implementation is modeled after the POSIX thread API for the most part. When designing it, we approached it with the idea that having a more complete API was more important than having a <quote>lowest-common-denominator</quote> API. That is, just because not all threading implementations support a specific feature does not mean that the API should suffer by not having that feature. Whether this was a good approach or not is an open debate.</para>
                  <para>The VR Juggler Portable Runtime (VPR), used by VR Juggler 1.1 and newer, has a wrapper around <ulink url="http://www.mozilla.org/projects/nspr/index.html">Netscape Portable Runtime</ulink> (NSPR) threads<indexterm>
                        <primary>NSPR</primary>
                     </indexterm>. We have removed the Win32-specific threads because NSPR already supports that implementation. Further implementations may be removed in favor of using what NSPR offers. Doing this will offload much of our efforts onto the NSPR. Most of what has been described in the <classname>vpr::Thread</classname> interface has remained consistent after this change. NSPR threads do not support all the features we have, however, because they took the lowest-common-denominator approach. As with all technology, there is a trade-off in relieving some of our work load by using an existing cross-platform thread implementation: our interface becomes limited to what features that implementation provides. It remains to be seen exactly how much of VR Juggler's threading subsystem will be removed, and those programmers who choose to use it should be careful to watch the mailing lists for discussions and announcements about changes.</para>
               </section>
            </section>
            <section>
               <title>Using the <classname>vpr::BaseThreadFunctor</classname> Interface</title>
               <indexterm>
                  <primary>vpr::BaseThreadFunctor</primary>
                  <seealso>vpr::ThreadMemberFunctor, vpr::ThreadNonMemberFunctor</seealso>
               </indexterm>
               <para>In this section, we explain the concept and use of functors. As with much of VR Juggler, a functor is a high-level concept that encapsulates something quite simple. A functor is defined as <quote>something that performs an operation or a function.</quote> While this is not very detailed, it is clear and concise. In VR Juggler, functors can be used as the code executed by a thread (refer to <xref linkend="using-vjThread-sect"/> for more detail on the topic of <classname>vpr::Thread</classname>s). This section describes how to use functors for exactly that purpose.</para>
               <section>
                  <title>High-Level Description</title>
                  <indexterm>
                     <primary>vpr::BaseThreadFunctor</primary>
                     <secondary>description of</secondary>
                  </indexterm>
                  <indexterm>
                     <primary>functor</primary>
                     <secondary>use with vpr::Thread</secondary>
                     <seealso>vpr::Thread</seealso>
                  </indexterm>
                  <para>As mentioned, a functor<indexterm>
                        <primary>functor</primary>
                     </indexterm> is used in VR Juggler with <classname>vpr::Thread</classname>s<indexterm>
                        <primary>classes</primary>
                        <secondary>vpr::Thread</secondary>
                     </indexterm>. VR Juggler's threads can execute two types of functions: normal C/C++ functions and class methods or functors. The former was described in the section about using <classname>vpr::Thread</classname>s, and the latter is described here. The use of functors is given more attention because the concept may be foreign to some programmers. Those who already know about functors can skip this short description and go straight to the section on using functors.</para>
                  <para>In VR Juggler, a functor is simply another object type that happens to encapsulate a user-defined function. The details on how this is done are not important here, but they are provided later for those who are interested. What is important to know is that a functor can be thought of as a normal function. When using them, programmers simply implement a function and then pass the function pointer (and the function's optional argument) to the functor's constructor. The object does the rest.</para>
                  <para>Observant readers may have noticed the parenthetical phrase in the previous paragraph mentioning a function's optional argument. Note that <quote>argument</quote> is singular meaning that only one parameter can be passed to the function that will be run by the created thread. The type of that argument is the wonderfully vague <type>void*</type>, an artifact of basing the threading subsystem on C libraries. As discussed in the section on using <classname>vpr::Thread</classname>s, if there is a need to pass multiple arguments, they must be encapsulated in a struct or a comparable object.</para>
                  <para>Once a functor object exists, it is passed to the <classname>vpr::Thread</classname> constructor, and the new thread will execute the functor (which knows about the function). The end result is the same as using a normal C/C++ function or a static class member function, but there is one special benefit: with functors, non-static class member functions can be passed. In many cases, there arises a need to run a member function in a separate thread, but making it static is infeasible or awkward. Thus, it would be best to pass a non-static member function to the created thread. To get access to the non-static data members, however, the C++ <varname>this</varname> pointer must be available to the thread. By using a VR Juggler functor, that is all handled behind the scenes so that passing a non-static member function is straightforward.</para>
                  <para>Before getting into specifics, there is a header file that must be included to use VR juggler thread functors. In this case, the header is <filename>vpr/Thread/ThreadFunctor.h</filename>. Within this header, <classname>vpr::BaseThreadFunctor</classname> is declared as an abstract base class. It has two subclasses implementing its interface: <classname>vpr::ThreadMemberFunctor</classname> and <classname>vpr::ThreadNonMemberFunctor</classname>. Both of these subclasses will be discussed in turn next.</para>
               </section>
               <section>
                  <title><classname>vpr::ThreadMemberFunctor</classname></title>
                  <indexterm>
                     <primary>vpr::ThreadMemberFunctor</primary>
                     <secondary>use</secondary>
                  </indexterm>
                  <para>This implementation of <classname>vpr::BaseThreadFunctor</classname> is for all functions that fall into the rather elite category of being non-static class member functions. To be more specific, those member functions (heretofore referred to as <quote>methods</quote>) must have the following prototype: </para>
                  <programlisting>void methodName(void* arg);</programlisting>
                  <para>Those readers with experience in multi-threaded programming will recognize this prototype instantly. It is no different than that used in common threading implementations. Constructing the functor to use this method, however, is quite different than what readers may have seen before.</para>
                  <para>Say there is a class <classname>MyObject</classname> with a method <methodname>run()</methodname> having the appropriate prototype that will be executed by a <classname>vpr::Thread</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>vpr::Thread</secondary>
                     </indexterm> object. In this case, <methodname>run()</methodname> takes an argument that is a pointer to a pre-defined type <type>thread_args_t</type>. Also assume that there is an instance of <classname>MyObject</classname> pointed to by the variable <varname>my_obj</varname>. The following code creates the <classname>vpr::ThreadMemberFunctor</classname> object that will encapsulate the method:</para>
                  <programlisting>vpr::ThreadMemberFunctor&lt;MyObject&gt;* my_functor;
thread_args_t* args;
vpr::Thread* thread;

args = new thread_args_t();

// Fill in the arguments to be passed to the thread...

my_functor = new vpr::ThreadMemberFunctor&lt;MyObject&gt;(my_obj, &amp;MyObject::run, (void*) args);
thread = new vpr::Thread(my_functor);</programlisting>
                  <para>The important thing to note in this example is that <classname>vpr::ThreadMemberFunctor</classname> is a template class. When creating the functor instance, the class must be specified as the template parameter. (If you do not understand this syntax, take a look at a C++ book that covers the current C++ standard.) Also note that when creating the new <classname>vpr::Thread</classname> object, the argument structure is not passed to the constructor. The argument to <methodname>run()</methodname> is packaged up with the function in the functor object <varname>my_functor</varname>. Once this code has executed, a new thread is spawned that will run the <methodname>run()</methodname> method given the provided argument structure.</para>
                  <para>The <classname>vpr::BaseThreadFunctor</classname> interface defines an extra method <methodname>setArg()</methodname><indexterm>
                        <primary>vpr::BaseThreadFunctor</primary>
                        <secondary>setArg() method</secondary>
                     </indexterm> that allows the function's argument to be set after the functor object is created. The argument to the constructor providing the function's argument is optional and will default to <constant>NULL</constant> if not specified. At a later time, should there be an argument to provide, the following can be used:</para>
                  <programlisting>thread_args_t* args = new thread_args_t();

// Fill in args ...

my_functor-&gt;setArg(args);</programlisting>
                  <para>This assumes that there is already a functor object instantiated called <varname>my_functor</varname>. Alternatively, <methodname>setArg()</methodname> could be used to remove a previously defined argument by passing <constant>NULL</constant>.</para>
                  <para>The last thing to note is that a lot of memory is being allocated dynamically in the example code. Be careful to deallocate the memory when it is no longer needed.</para>
               </section>
               <section>
                  <title><classname>vpr::ThreadNonMemberFunctor</classname></title>
                  <indexterm>
                     <primary>vpr::ThreadNonMemberFunctor</primary>
                     <secondary>use</secondary>
                  </indexterm>
                  <para>This implementation of <classname>vpr::BaseThreadFunctor</classname> is the complement of the set of functions contained by <classname>vpr::ThreadMemberFunctor</classname>. It is used for normal C/C++ functions and for static class member functions. There is nothing terribly interesting about this class, and its use is straightforward. The following example, an adaptation of that presented in the previous section, shows how to use this interface rather than passing a function pointer and an argument to the <classname>vpr::Thread</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>vpr::Thread</secondary>
                     </indexterm> constructor. In this case, assume that the function <function>run()</function> is appropriately defined for use here.</para>
                  <programlisting>vpr::ThreadNonMemberFunctor* my_functor;
thread_args_t* args;
vpr::Thread* thread;

args = new thread_args_t();

// Fill in the arguments to be passed to the thread...

my_functor = new vpr::ThreadNonMemberFunctor(run, (void*) args);
thread = new vpr::Thread(my_functor);</programlisting>
                  <para>That is all there is to it. Programmers end up doing more work than if they had just passed the function pointer and the associated argument to the <classname>vpr::Thread</classname> constructor directly, but the <classname>vpr::Thread</classname> constructor is relieved of some work. (The reason for this is described below.) Thus, either way is equally efficient, and what you use is up to you.</para>
               </section>
               <section>
                  <title>The Gory Details</title>
                  <indexterm>
                     <primary>vpr::BaseThreadFunctor</primary>
                     <secondary>details</secondary>
                  </indexterm>
                  <indexterm>
                     <primary>vpr::ThreadMemberFunctor</primary>
                     <secondary>details</secondary>
                  </indexterm>
                  <indexterm>
                     <primary>vpr::ThreadNonMemberFunctor</primary>
                     <secondary>details</secondary>
                  </indexterm>
                  <para>The magic behind these functors is done by overloading <methodname>operator()</methodname> for <classname>vpr::BaseThreadFunctor</classname> objects. Both implementations of the interface store the function pointer (and optional argument pointer), and when <methodname>vpr::BaseThreadFunctor::operator()</methodname> is invoked, they call the function and pass the argument if there is one. There is a little more magic with the <classname>vpr::ThreadMemberFunctor</classname>, however, that allows it to work with the non-static methods of a given class.</para>
                  <para>The class <classname>vpr::ThreadMemberFunctor</classname> works its extra-special magic through the use of a template and one of C++'s dustier operators, ::*. This operator is used to point to a member of a class. In this case, it points to the method that will be executed by the thread. When used in conjunction with the provided class instance (the <varname>this</varname> pointer), the non-static method can be invoked by the functor.</para>
                  <para>One interesting thing to note about <classname>vpr::Thread</classname>s is that they deal only in functors. More specifically, they deal only with objects that subsume to <classname>vpr::BaseThreadFunctor</classname>. If a function pointer and its argument are passed directly to the <classname>vpr::Thread</classname> constructor, a <classname>vpr::ThreadNonMemberFunctor</classname> object is created to package those arguments. That new functor is then used internally by the thread. Thus, whether you choose to create a non-member functor or to pass the function pointer and associated argument, the same code will be executed.</para>
               </section>
            </section>
            <section>
               <title>Using the <classname>vpr::Semaphore</classname> Interface</title>
               <indexterm>
                  <primary>vpr::Semaphore</primary>
               </indexterm>
               <para>The most important part of multi-threaded programming is proper thread synchronization so that access to shared data is controlled. Doing so results in consistency among all threads. Semaphores are a very common synchronization mechanism and have been used widely in concurrent systems. This short section describes the cross-platform semaphore interface provided with and used by VR Juggler. It does not explain what semaphores are or how to use them&mdash;it is assumed that readers are already familiar with the topic lest they probably would not be reading this chapter on advanced classes at all.</para>
               <section>
                  <title>High-Level Description</title>
                  <indexterm>
                     <primary>vpr::Semaphore</primary>
                     <secondary>description of</secondary>
                  </indexterm>
                  <para>As with threads, a cross-platform abstraction layer has been written into VR Juggler to provide a consistent way to use semaphores on all supported platforms. The primary goal behind the interface design is to provide the common <emphasis>P</emphasis> (acquire) and <emphasis>V</emphasis> (release) operations. The interface does include methods for read/write semaphores, but as of this writing, that part of the interface is not complete. Because of that, the use section does not cover that part of the interface. When the implementation is complete, this section will be expanded.</para>
                  <para>As always, there is a header file that must be included to use <classname>vpr::Semaphore</classname>. This time around, the file is <filename>vpr/Sync/Semaphore.h</filename>. Do not include any of the platform-specific implementation files. That is all handled appropriately within <filename>vpr/Sync/Semaphore.h</filename>.</para>
               </section>
               <section>
                  <title>Creating a <classname>vpr::Semaphore</classname></title>
                  <indexterm>
                     <primary>vpr::Semaphore</primary>
                     <secondary>creating</secondary>
                  </indexterm>
                  <para>When creating a <classname>vpr::Semaphore</classname> object, give the initial value that represents the number of resources being controlled by the semaphore. If no value is given, the default is 1 which of course gives a binary semaphore. Binary semaphores are better known as mutexes (see <xref linkend="using-vjMutex-sect"/> for more information about mutex use in VR Juggler). An example of creating a simple semaphore to control access to five resources is as follows:</para>
                  <programlisting>vpr::Semaphore sema(5);</programlisting>
                  <para>This creates a semaphore capable of controlling concurrent access to five resources. At some point, if there is a need to change the number of resources, a method called <methodname>reset()</methodname><indexterm>
                        <primary>vpr::Semaphore</primary>
                        <secondary>reset() method</secondary>
                     </indexterm> is provided. Pass the new number of resources, and the semaphore object is updated appropriately:</para>
                  <programlisting>sema.reset(4);</programlisting>
                  <para>The semaphore <varname>sema</varname> now controls access to only four resources.</para>
               </section>
               <section>
                  <title>Locking a Semaphore</title>
                  <indexterm>
                     <primary>vpr::Semaphore</primary>
                     <secondary>locking</secondary>
                  </indexterm>
                  <para>When a thread needs to acquire access to shared data, it locks a semaphore. In the <classname>vpr::Semaphore</classname> interface, this is accomplished using the <methodname>acquire()</methodname> method: </para>
                  <programlisting>sema.acquire();</programlisting>
                  <para>As expected, <methodname>acquire()</methodname> is a blocking call, so if the semaphore's value is less than or equal to 0, the thread requesting the lock will block until the semaphore's value is greater than 0. Note that the return value of <methodname>acquire()</methodname> is a little different than most calls. If the lock is acquired, <constant>vpr::ReturnStatus::Succeed</constant> is returned. If the attempt to lock the semaphore fails for some reason, <constant>vpr::ReturnStatus::Fail</constant> is returned.</para>
               </section>
               <section>
                  <title>Releasing a Locked Semaphore</title>
                  <indexterm>
                     <primary>vpr::Semaphore</primary>
                     <secondary>releasing</secondary>
                  </indexterm>
                  <para>Finally, when access to the critical section is complete, the semaphore is released using the <methodname>release()</methodname> method:</para>
                  <programlisting>sema.release();</programlisting>
                  <para>If the locked semaphore is released successfully, <constant>vpr::ReturnStatus::Succeed</constant> is returned. Otherwise, <constant>vpr::ReturnStatus::Fail</constant> is returned.</para>
               </section>
               <section>
                  <title>The Gory Details</title>
                  <indexterm>
                     <primary>vpr::Semaphore</primary>
                     <secondary>details</secondary>
                  </indexterm>
                  <para>Those who have read the Gory Details section for <classname>vpr::Thread</classname>s will find this section very familiar. As with <classname>vpr::Thread</classname>s, there are several platform-specific semaphore implementation wrapper classes:</para>
                  <itemizedlist>
                     <listitem>
                        <para> <classname>vpr::SemaphoreSGI</classname>: A wrapper around IRIX shared-arena semaphores (refer to the <function>usnewsema(3P)</function> and related manual pages for more information)</para>
                     </listitem>
                     <listitem>
                        <para><classname>vpr::SemaphorePosix</classname>: A wrapper around POSIX real-time semaphores (POSIX.1b, formerly POSIX.4)</para>
                     </listitem>
                     <listitem>
                        <para><classname>vpr::SemaphoreNSPR</classname>: An implementation of semaphores using NSPR primitives</para>
                     </listitem>
                  </itemizedlist>
                  <para>Unlike <classname>vpr::Thread</classname>, however, there is no base interface from which these implementations inherit. Performance decreases caused by virtual functions are avoided this way.</para>
                  <para>The semaphore implementation used is chosen when VR Juggler is compiled and will always match the thread implementation being used. When the VR Juggler build is configured, preprocessor <symbol>#define</symbol> statements are made in <filename>vpr/vprDefines.h</filename> that describe the threading system and thus the semaphores to use. Based on that, the header file <filename>vpr/Sync/Semaphore.h</filename> makes several <type>typedef</type>s that set up one of the platform-specific implementations to act as the <classname>vpr::Semaphore</classname> interface. For example, if compiling on Linux, the class <classname>vpr::SempahorePosix</classname> is <type>typedef</type>'d to <classname>vpr::Semaphore</classname>. Since the interface is consistent among all the wrappers, everything works as though that was the way it was written to behave.</para>
               </section>
            </section>
            <section id="using-vjMutex-sect">
               <title>Using the <classname>vpr::Mutex</classname> Interface</title>
               <indexterm>
                  <primary>vpr::Mutex</primary>
               </indexterm>
               <para>In addition to cross-platform semaphores, VR Juggler provides an abstraction for cross-platform mutexes. Mutexes are a special type of semaphore known as a binary semaphore. Exactly one thread can hold the lock at any time. This very short section, however, is not about mutexes but rather about the <classname>vpr::Mutex</classname> interface provided with and used by VR Juggler.</para>
               <section>
                  <title>High-Level Description</title>
                  <indexterm>
                     <primary>vpr::Mutex</primary>
                     <secondary>description of</secondary>
                  </indexterm>
                  <para>The cross-platform mutex abstraction in VR Juggler is critical for synchronizing access to shared data. Those who have read the section on <classname>vpr::Semaphore</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>vpr::Semaphore</secondary>
                     </indexterm> will find this section very, very familiar. The interface for <classname>vpr::Mutex</classname> is a subset of that for <classname>vpr::Semaphore</classname> since mutexes are binary semaphores. They can be locked and unlocked. That is all there is to know. The <classname>vpr::Mutex</classname> interface does include some methods for read/write mutexes, but this implementation is incomplete and is not documented here for that reason. When the implementation is finished, this documentation will be expanded.</para>
                  <para>The header file to include for using <classname>vpr::Mutex</classname> is <filename>vpr/Sync/Mutex.h</filename>. As with other classes discussed in this chapter, it is important not to include the platform-specific header files.</para>
               </section>
               <section>
                  <title>Creating a <classname>vpr::Mutex</classname></title>
                  <indexterm>
                     <primary>vpr::Mutex</primary>
                     <secondary>creating</secondary>
                  </indexterm>
                  <para>When creating a <classname>vpr::Mutex</classname> object, there are no special parameters to pass or considerations to be made. An example of creating a mutex is as follows: </para>
                  <programlisting>vpr::Mutex mutex;</programlisting>
                  <para>There is nothing more to say this time.</para>
               </section>
               <section>
                  <title>Locking a Mutex</title>
                  <indexterm>
                     <primary>vpr::Mutex</primary>
                     <secondary>locking</secondary>
                  </indexterm>
                  <para>When a thread needs to acquire access to shared data, it can lock a mutex. In the <classname>vpr::Mutex</classname> interface, this is accomplished using the <methodname>acquire()</methodname> method:</para>
                  <programlisting>mutex.acquire();</programlisting>
                  <para>As expected, <methodname>acquire()</methodname> is a blocking call, so if the mutex is already locked by another thread, the thread requesting the lock will block until the mutex is released by the other thread. Note that the return value of <methodname>acquire()</methodname> is a little different than most calls. If the lock is acquired, <constant>vpr::ReturnStatus::Succeed</constant> is returned. If the attempt to lock the semaphore fails for some reason, <constant>vpr::ReturnStatus::Fail</constant> is returned.</para>
               </section>
               <section>
                  <title>Attempting to Lock a Mutex</title>
                  <indexterm>
                     <primary>vpr::Mutex</primary>
                     <secondary>locking</secondary>
                     <tertiary>without blocking</tertiary>
                  </indexterm>
                  <para>If there is a need to lock a mutex only when the call would <emphasis>not</emphasis> block, a method is provided to do this. It is called <methodname>tryAcquire()</methodname>, and it will not block if the mutex is already locked. It works as follows:</para>
                  <programlisting>mutex.tryAcquire();</programlisting>
                  <para>If the mutex is locked, <constant>vpr::ReturnStatus::Succeed</constant> is returned. Otherwise, <constant>vpr::ReturnStatus::Fail</constant> is returned. The call does not block.</para>
               </section>
               <section>
                  <title>Testing the State of a Mutex</title>
                  <indexterm>
                     <primary>vpr::Mutex</primary>
                     <secondary>testing state</secondary>
                  </indexterm>
                  <para>In addition to conditional locking, the state of a mutex can be tested to see if it is locked or unlocked. This is done using the <methodname>test()</methodname> method as follows:</para>
                  <programlisting>int state = mutex.test();</programlisting>
                  <para>If the mutex is <emphasis>not</emphasis> locked, <constant>vpr::ReturnStatus::Fail</constant> is returned. Otherwise, <constant>vpr::ReturnStatus::Succeed</constant> is returned.</para>
               </section>
               <section>
                  <title>Releasing a Locked Mutex</title>
                  <indexterm>
                     <primary>vpr::Mutex</primary>
                     <secondary>releasing</secondary>
                  </indexterm>
                  <para>When access to the critical section is complete, a locked mutex is released using the <methodname>release()</methodname> method:</para>
                  <programlisting>sema.release();</programlisting>
                  <para>If the locked mutex is released successfully, <constant>vpr::ReturnStatus::Succeed</constant> is returned. Otherwise, <constant>vpr::ReturnStatus::Fail</constant> is returned.</para>
               </section>
               <section>
                  <title>The Gory Details</title>
                  <indexterm>
                     <primary>vpr::Mutex</primary>
                     <secondary>details</secondary>
                  </indexterm>
                  <para>Those who have read the Gory Details sections for <classname>vpr::Thread</classname>s or for <classname>vpr::Semaphore</classname>s will find this last section very familiar (and probably uninteresting at this point). As with <classname>vpr::Thread</classname>s and <classname>vpr::Semaphore</classname>s, there are several platform-specific mutex implementation wrapper classes:</para>
                  <itemizedlist>
                     <listitem>
                        <para> <classname>vpr::MutexSGI</classname>: A wrapper around IRIX shared-arena mutexes (refer to the <function>usnewlock(3P)</function> and related manual pages for more information)</para>
                     </listitem>
                     <listitem>
                        <para><classname>vpr::MutexPosix</classname>: A wrapper around POSIX real-time mutexes (POSIX.1b, formerly POSIX.4)</para>
                     </listitem>
                     <listitem>
                        <para><classname>vpr::MutexNSPR</classname>: A wrapper around NSPR mutexes</para>
                     </listitem>
                  </itemizedlist>
                  <para>Similar to <classname>vpr::Semaphore</classname>, there is no base interface from which these implementations inherit. Performance issues caused by virtual functions are avoided by doing this.</para>
                  <para>The mutex implementation used is chosen when VR Juggler is compiled and will always match the thread implementation being used. When the VR Juggler build is configured, preprocessor <symbol>#define</symbol> statements are made in <filename>vpr/vprDefines.h</filename> that describe the threading system and thus the mutexes to use. Based on that, the header file <filename>vpr/Sync/Mutex.h</filename> makes several <type>typedef</type>s that set up one of the platform-specific implementations to act as the <classname>vpr::Mutex</classname> interface. For example, if compiling on Solaris, the class <classname>vpr::MutexPosix</classname> is <type>typedef</type>'d to be <classname>vpr::Mutex</classname>. Since the interface is consistent among all the wrappers, everything works as though that was the way it was written to behave.</para>
               </section>
            </section>
         </section>
      </chapter>
      <chapter id="run-time.reconfig.chapter">
         <title>Run-Time Reconfiguration</title>
         <indexterm>
            <primary>run-time reconfiguration</primary>
         </indexterm>
         <para>In this chapter, we introduce run-time reconfiguration, one of the most powerful features of VR Juggler. We will give an overview of how it works before proceeding into how to use it. The idea here is to introduce the concepts, justify the value of run-time reconfiguration, and then present its use so that developers can take full advantage of this feature.</para>
         <section>
            <title>How Run-Time Reconfiguration Works</title>
            <para></para>
         </section>
         <section>
            <title>Reasons to Use Run-Time Reconfiguration</title>
            <para></para>
         </section>
         <section>
            <title>Using Run-Time Reconfiguration in an Application</title>
            <indexterm>
               <primary>run-time reconfiguration</primary>
               <secondary>use in application</secondary>
            </indexterm>
            <para>There are four steps involved in adding run-time reconfiguration to a VR Juggler application. We describe each of them in detail here.</para>
            <orderedlist>
               <listitem>
                  <para>Define application chunk descriptions (ChunkDescs)</para>
                  <para>The first step in adding dynamic reconfiguration capabilities to an application is to decide what aspects of the application should be configurable. Naturally, this is very application-specific, but some of the following choices are common:</para>
                  <itemizedlist>
                     <listitem>
                        <para>Initial parameters (position, color, etc.) of objects in the environment</para>
                     </listitem>
                     <listitem>
                        <para>Navigational position</para>
                     </listitem>
                     <listitem>
                        <para>Global settings such as difficulty level of a game, or network settings for a distributed application</para>
                     </listitem>
                  </itemizedlist>
                  <para>Once decisions are made regarding configuration information, it is time to define the kinds of ConfigChunks that will contain it. This essentially means creating a file containing one or more ChunkDescs. To understand this better, consider the following example. One might define an <quote>Object</quote> ChunkDesc in an application. The ChunkDesc would have properties that include the name and type of an object, its color and size, and so forth.</para>
                  <para>There are several ways to ensure that custom ChunkDescs are read by the application. One way is to load the ChunkDesc file explicitly (described below), but the simplest way is to include the custom ChunkDesc file from one of the configuration files the application loads at startup. Instructions for editing ChunkDesc files and creating new kinds of ChunkDescs are included in the <emphasis>VjControl User's Guide</emphasis>.</para>
               </listitem>
               <listitem>
                  <para>Implement dynamic reconfiguration interface</para>
                  <para>The next step is to implement the dynamic reconfiguration interface for the application object. This interface is defined by the <classname>jccl::ConfigChunkHandler</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>jccl::ConfigChunkHandler</secondary>
                     </indexterm> class and consists of three methods:</para>
                  <orderedlist>
                     <listitem>
                        <methodsynopsis>
                           <modifier>virtual</modifier>
                           <type>bool</type>
                           <methodname>configCanHandle</methodname>
                           <methodparam>
                              <type>jccl::ConfigChunkPtr</type>
                              <parameter>chunk</parameter>
                           </methodparam>
                        </methodsynopsis>
                        <indexterm>
                           <primary>vrj::App</primary>
                           <secondary>configCanHandle() method</secondary>
                        </indexterm>
                        <para>This function should simply return a Boolean (true or false) depending on whether this object knows how to deal with the ConfigChunk passed to it. If this Chunk uses an application-custom ChunkDescs, this should return true. For example:</para>
                        <programlisting>std::string s = chunk-&gt;getType();

if ( !jccl::strcasecmp(s, "my_custom_chunk_type") )
{
   return true;
}</programlisting>
                     </listitem>
                     <listitem>
                        <methodsynopsis>
                           <modifier>virtual</modifier>
                           <type>bool</type>
                           <methodname>configAdd</methodname>
                           <methodparam>
                              <type>jccl::ConfigChunkPtr</type>
                              <parameter>chunk</parameter>
                           </methodparam>
                        </methodsynopsis>
                        <indexterm>
                           <primary>vrj::App</primary>
                           <secondary>configAdd() method</secondary>
                        </indexterm>
                        <para>This method is called whenever a ConfigChunk is added to the application, whether by loading a configuration file or through a dynamic reconfiguration event. Prior to this, the chunk will have been passed through the application object's <methodname>configCanHandle()</methodname> method. Thus, when <methodname>configAdd()</methodname> is called, the chunk is destined for the application object.</para>
                        <para>When <methodname>configAdd()</methodname> is called, the application should look at the chunk passed to it and decide what to do. This might involve creating a new object, changing the configuration of an already extant object, changing the values of certain variables, or any number of other possibilities. This flexibility is part of the power of dynamic reconfiguration with VR Juggler.</para>
                     </listitem>
                     <listitem>
                        <methodsynopsis>
                           <modifier>virtual</modifier>
                           <type>bool</type>
                           <methodname>configRemove</methodname>
                           <methodparam>
                              <type>jccl::ConfigChunkPtr</type>
                              <parameter>chunk</parameter>
                           </methodparam>
                        </methodsynopsis>
                        <indexterm>
                           <primary>vrj::App</primary>
                           <secondary>configRemove() method</secondary>
                        </indexterm>
                        <para>This method is analogous to <methodname>configAdd()</methodname>. It is called when VR Juggler receives a command to remove a particular ConfigChunk. If the ConfigChunk refers to a specific object in the application, the most obvious behavior would be to remove that particular object. If the ConfigChunk refers to some other properties of the application, there are several choices for the correct behavior. For example, one might choose to reset those properties to their default values. In some cases, it may be desirable or necessary to ignore the remove request.</para>
                     </listitem>
                  </orderedlist>
               </listitem>
               <listitem>
                  <para>Processing ConfigChunks</para>
                  <para>When an application receives a ConfigChunk to process via <methodname>configAdd()</methodname> or <methodname>configRemove()</methodname>, it needs to retrieve the data in that Chunk in order to decide what to do. ConfigChunks can be very complex, but the interface has been designed to be as simple as possible. We now describe a few of the most important methods in the ConfigChunk API.</para>
                  <itemizedlist>
                     <listitem>
                        <methodsynopsis>
                           <type>std::string&amp;</type>
                           <methodname>jccl::ConfigChunk::getType</methodname>
                           <void/>
                        </methodsynopsis>
                        <indexterm>
                           <primary>jccl::ConfigChunk</primary>
                           <secondary>getType() method</secondary>
                        </indexterm>
                        <para>This method returns the token of the ChunkDesc which describes this ConfigChunk. This is useful if an application uses several kinds of custom ConfigChunk types. With this method, it is possible to distinguish one from another.</para>
                     </listitem>
                     <listitem>
                        <methodsynopsis>
                           <type>jccl::VarValue&amp;</type>
                           <methodname>jccl::ConfigChunk::getProperty</methodname>
                           <methodparam>
                              <type>std::string&amp;</type>
                              <parameter>property_token</parameter>
                           </methodparam>
                           <methodparam>
                              <type>int</type>
                              <parameter>num</parameter>
                           </methodparam>
                        </methodsynopsis>
                        <indexterm>
                           <primary>jccl::ConfigChunk</primary>
                           <secondary>getProperty() method</secondary>
                        </indexterm>
                        <para>This is the key method for getting the information contained in a ConfigChunk. Its arguments are the token associated with a property, and a numeric index. For example, a property might store a coordinate with three values, each of which can be accessed separately by using the numbers 0, 1, or 2 for the <varname>num</varname> parameter.</para>
                        <para>The return value for this method needs some explanation. <classname>jccl::VarValue</classname><indexterm>
                              <primary>classes</primary>
                              <secondary>jccl::VarValue</secondary>
                           </indexterm> is a placeholder class designed to be cast safely to one of a variety of data types. Basically, the return value of <methodname>getProperty()</methodname> is cast to whichever type the caller expects to receive. It is assumed that the caller knows the types of values stored in a given property.</para>
                        <para><classname>jccl::VarValue</classname> tries to coax the data in a variety of ways for convenience. For example, the VarValue returned from an integer, float, or boolean property can be safely cast to a string or <type>char*</type>. Booleans can be cast to integers and vice versa. The following code fragment gives a few examples of this usage:</para>
                        <programlisting>std::string s1 = (std::string) chunk-&gt;getProperty("name", 0);
char* s2 = (char*) chunk-&gt;getProperty("name");
// NOTE: the cast allocates new memory for s2, which you are
// responsible for deleting.

bool b = (bool) chunk-&gt;getProperty("enabled");
std::string s3 = (std::string) chunk-&gt;getProperty("enabled");
// s3 will be one of the strings "True" or "False"

jccl::ConfigChunkPtr ch = (jccl::ConfigChunkPtr) chunk-&gt;getProperty("embedded_chunk", 2);
// ch is a copy of the embedded chunk. Once again, the caller
// of getProperty() is responsible for freeing this memory.</programlisting>
                     </listitem>
                     <listitem>
                        <methodsynopsis>
                           <type>int</type>
                           <methodname>jccl::ConfigChunk::getNum</methodname>
                           <methodparam>
                              <modifier>const</modifier>
                              <type>std::string&amp;</type>
                              <parameter>property_token</parameter>
                           </methodparam>
                           <modifier>const</modifier>
                        </methodsynopsis>
                        <para></para>
                        <indexterm>
                           <primary>jccl::ConfigChunk</primary>
                           <secondary>getNum() method</secondary>
                        </indexterm>
                        <para>Sometimes properties of a ConfigChunk can have a variable number of values. A good example is a property that lists a set of files to be loaded. The <methodname>getNum()</methodname> method returns the actual number of values of the named property.</para>
                     </listitem>
                  </itemizedlist>
                  <para>For definitive information about the ConfigChunk API, refer to the VR Juggler <emphasis>Programmer's Reference</emphasis>.</para>
               </listitem>
               <listitem>
                  <para>Loading and saving configurations</para>
               </listitem>
            </orderedlist>
         </section>
         <section>
            <title>Application Tutorial</title>
            <para></para>
         </section>
      </chapter>
      <chapter id="add.dev.driver.chapter">
         <title>Adding Device Drivers to VR Juggler</title>
         <indexterm>
            <primary>device drivers</primary>
            <secondary>adding</secondary>
         </indexterm>
         <para>In this final chapter, we explain how to add device drivers to VR Juggler. We begin with a detailed description of device driver conventions in VR Juggler and how the drivers fit into the VR Juggler Input Manager. We then explain how device drivers are configured. The chapter concludes with example code showing a very simple driver that reads button presses.</para>
         <section>
            <title>In-Depth Driver Guide</title>
            <indexterm>
               <primary>device drivers</primary>
               <secondary>guide</secondary>
            </indexterm>
            <para>All device drivers in VR Juggler must derive from one or more of the following classes:</para>
            <itemizedlist>
               <listitem>
                  <para><classname>gadget::Input</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::Input</secondary>
                     </indexterm> (base case of all device drivers)</para>
               </listitem>
               <listitem>
                  <para><classname>gadget::Digital</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::Digital</secondary>
                     </indexterm>, <classname>gadget::SimDigital</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::SimDigital</secondary>
                     </indexterm></para>
               </listitem>
               <listitem>
                  <para><classname>gadget::Analog</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::Analog</secondary>
                     </indexterm>, <classname>gadget::SimAnalog</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::SimAnalog</secondary>
                     </indexterm></para>
               </listitem>
               <listitem>
                  <para><classname>gadget::Position</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::Position</secondary>
                     </indexterm>, <classname>gadget::SimPosition</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::SimPosition</secondary>
                     </indexterm></para>
               </listitem>
               <listitem>
                  <para><classname>gadget::Glove</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::Glove</secondary>
                     </indexterm>, <classname>gadget::SimDigitalGlove</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::SimDigitalGlove</secondary>
                     </indexterm>, <classname>gadget::GloveGesture</classname><indexterm>
                        <primary>classes</primary>
                        <secondary>gadget::GloveGesture</secondary>
                     </indexterm></para>
               </listitem>
            </itemizedlist>
            <para>For example, to make a driver that registers button presses, derive from <classname>gadget::Digital</classname>:</para>
            <programlisting>class MyNewButtonDevice : public gadget::Digital</programlisting>
            <para>Supposed that a joystick driver supporting buttons and movement is needed. In this case, an additional component, this one for analog input, is needed for the X and Y axes. Since the device is both digital and analog, its class must derive from both <classname>gadget::Digital</classname> and <classname>gadget::Analog</classname> using C++ multiple inheritance:</para>
            <programlisting>class MyNewJoystickDevice : public gadget::Digital, public gadget::Analog</programlisting>
            <note>
               <para>To use the joystick in place of a tracker, it should derive instead from <classname>gadget::Position</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>gadget::Position</secondary>
                  </indexterm>. This way, you can replace real trackers with your joystick <quote>pseudo tracker</quote>. The main idea is that to be able to replace one device with another, the alternate device class must derive from the same base classes as the original device.</para>
            </note>
            <section>
               <title>Implementing the Device Driver</title>
               <indexterm>
                  <primary>device drivers</primary>
                  <secondary>implementing</secondary>
               </indexterm>
               <para>Using basic class declaration for <classname>MyNewButtonDevice</classname> from above, we will proceed with the implementation of the driver class. First, there are six member functions that must be implemented:</para>
               <orderedlist>
                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>int</type>
                        <methodname>startSampling</methodname>
                        <void/>
                     </methodsynopsis>
                     <para>Within this function, a new thread is started. This thread is used to sample the data from the device. The thread creation step may look something like the following:</para>
                     <programlisting>vpr::ThreadMemberFunctor&lt;MyNewButtonDevice&gt;* functor =
   new vpr::ThreadMemberFunctor&lt;MyNewButtonDevice&gt;(this,
                                                   &amp;MyNewButtonDevice::sampleFunction,
                                                   NULL);
mThread = new vpr::Thread(functor);</programlisting>
                     <para>The above creates a thread that will execute <methodname>MyNewButtonDevice::sampleFunction()</methodname>, a non-static member function in the class <classname>MyNewButtonDevice</classname>. The implementation of that method would be similar to the following in most cases</para>
                     <programlisting>void MyNewButtonDevice::sampleFunction (void* arg)
{
   // Keep working until someone kills mThread.
   while ( 1 )
   {
      this-&gt;sample();
   }
}</programlisting>
                     <para>The thread can be tested for validity using the method <methodname>vpr::BaseThread::valid()</methodname>. For more information on VR Juggler threads, refer to <xref linkend="using-vjThread-sect"/>.</para>
                  </listitem>
                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>int</type>
                        <methodname>stopSampling</methodname>
                        <void/>
                     </methodsynopsis>
                     <para>The job of this function is to kill the thread created in <methodname>startSampling()</methodname>. Again, refer to <xref linkend="using-vjThread-sect"/> for more information on the use of VR Juggler threads.</para>
                  </listitem>
                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>int</type>
                        <methodname>sample</methodname>
                        <void/>
                     </methodsynopsis>
                     <para>This method reads data from the device and stores it for later use by <methodname>getDigitalData()</methodname>. Note that <methodname>MyNewButtonDevice::sampleFunction()</methodname>, defined above, invokes this method.</para>
                     <para>VR Juggler devices typically use triple-buffered data management. This is done to ensure that data is not being written into a buffer when the Input Manager is trying to read the most recent value. The <classname>gadget::Input</classname> class defines three variables to help programmers keep track of which buffer is in use at any given time: <varname>gadget::Input::current</varname>, <varname>gadget::Input::valid</varname>, and <varname>gadget::Input::progress</varname>. The sampled data would be read into a three-element array of the correct type (this is driver-specific). When writing the freshly sampled data into the array, use <varname>gadget::Input::progress</varname>:</para>
                     <programlisting>mSampledDigitalData[gadget::Input::progress] = sampled_digital_value;</programlisting>
                  </listitem>
                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>
                        <void/>
                        <methodname>updateData</methodname>
                        <void/>
                     </methodsynopsis>
                     <para>Triple-buffered device drivers use this method to swap the data indices. The member function is usually implemented as follows:</para>
                     <programlisting>void MyNewButtonDevice::updateData()
{
   vpr::Guard&lt;vpr::Mutex&gt; updateGuard(lock);

   // Copy the valid data to the current data so that both are valid
   mSampledDigitalData[current] = mSampledDigitalData[valid];   

   // swap the indices for the tri-buffer pointers
   gadget::Input::swapCurrentIndexes();
}</programlisting>
                     <para>Note the use of a <classname>vpr::Guard&lt;&gt;</classname> object to synchronize access to the <varname>mSampledDigitalData</varname> array. This is needed because the sampling and the reading are occurring in separate threads, but both threads need access to <varname>mSampledDigitalData</varname>.</para>
                  </listitem>
                  <listitem>
                     <methodsynopsis>
                        <modifier>static</modifier>
                        <type>std::string</type>
                        <methodname>getChunkType</methodname>
                        <void/>
                     </methodsynopsis>
                     <para>In the <methodname>getChunkType()</methodname> function, the <firstterm>chunk type</firstterm> of the device must be returned. Its name must be as it appears in the chunk description file for the driver. For example, the implementation for the simple button driver would appear as:</para>
                     <programlisting>std::string MyNewButtonDevice::getChunkType()
{
   return std:string("MyNewButtonDevice");
}</programlisting>
                     <para>At this time, it is useful to point out that every VR Juggler device needs a <firstterm>chunk type</firstterm> associated with it. A chunk type is similar to a struct in C or C++. The data structure is defined in a chunk description file (which usually has the extension <filename>.desc</filename>). Once defined, the type for a new driver can be used in VR Juggler configuration files.</para>
                  </listitem>
                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>int</type>
                        <methodname>getDigitalData</methodname>
                        <methodparam>
                           <type>int</type>
                           <parameter>devNum = 0</parameter>
                        </methodparam>
                     </methodsynopsis>
                     <para>The VR Juggler Input Manager uses this method to read digital data sampled by the driver. This is when the triple-buffered data scheme becomes especially valuable. To provide the Input Manager with the most up-to-date sample, use <varname>gadget::Input::current</varname> as the index, as shown below:</para>
                     <programlisting>int MyNewJoystickDevice::getDigitalData(int devNum)
{
  return mSampledDigitalData[current];
}</programlisting>
                     <para>Note that in this example, the parameter <varname>devNum</varname> is ignored. This is not always the case. Indeed, this button driver would likely have support for more than one button, and in that case, we would use <varname>devNum</varname> as the index into an array or vector containing data sampled from all the buttons.</para>
                  </listitem>
               </orderedlist>
               <para>There are other methods that must be implemented depending on the classes from which a given driver class derives. In the joystick example given earlier, the method <methodname>getAnalogData()</methodname> would have to be implemented in addition to <methodname>getDigitalData()</methodname>. The prototype for <methodname>getAnalogData()</methodname> is:</para>
               <programlisting>virtual float getAnalogData(int devNum = 0)</programlisting>
               <para>The joystick driver would use this to return values for the X and Y axes. The data here is more complex because it would be for triple-buffered two-dimensional samples. An implementation might look similar to the following:</para>
               <programlisting>float MyNewJoystickDevice::getAnalogData(int axis)
{
   vprASSERT(axis &gt;= 0 &amp;&amp; axis &lt;= 1 &amp;&amp; "only 2 axes (x and y) available");
   return mSampledAnalogData[current][axis];
}</programlisting>
               <para>In this driver, the integer argument to the method is used to represent either the X or the Y axis. The assertion ensures that a valid axis index is passed.</para>
            </section>
            <section>
               <title>Register the Device Driver with VR Juggler</title>
               <indexterm>
                  <primary>device drivers</primary>
                  <secondary>registering</secondary>
               </indexterm>
               <para>Device driver registration is done through a templated constructor called <classname>gadget::DeviceConstructor</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>gadget::DeviceConstructor</secondary>
                  </indexterm>. It is used as follows:</para>
               <programlisting>#include &lt;gadget/Type/DeviceFactory.h&gt;

gadget::DeviceConstructor&lt;MyNewButtonDevice&gt;* this_ptr_not_used =
   new gadget::DeviceConstructor&lt;MyNewButtonDevice&gt;;</programlisting>
               <para>The new device driver can be compiled along with the <classname>gadget::DeviceConstructor</classname> call into a standalone library (<filename>.a</filename>, <filename>.so</filename>, <filename>.lib</filename>, and <filename>.dll</filename> are common). This library can then be linked with applications. In this way, there is no need to modify the VR Juggler source code to add a new driver. The driver code can be centralized into a single, neat driver that can be distributed as a <quote>plug-in</quote> for VR Juggler.</para>
               <note>
                  <para>When linking, it is important that the linker include <emphasis>all</emphasis> library symbols. On IRIX with the MIPSpro Compilers, the <parameter>-all</parameter> option informs the linker of this need. The GNU linker uses <parameter>--whole-archive</parameter>. Refer to your compiler documentation for more detailed information.</para>
               </note>
            </section>
         </section>
         <section>
            <title>Device Driver Configuration</title>
            <indexterm>
               <primary>device drivers</primary>
               <secondary>configuring</secondary>
            </indexterm>
            <para>To configure a device, two things are needed:</para>
            <orderedlist>
               <listitem>
                  <para>Configuration files</para>
               </listitem>
               <listitem>
                  <para>Driver code that accepts the configuration</para>
               </listitem>
            </orderedlist>
            <section>
               <title>Configuration Files</title>
               <para>Before configuring a device, a new configuration chunk description must be created. We recommend that this be done using VjControl. For the button device, the chunk description will look similar to the following:</para>
               <programlisting>chunk MyButtonDevice "MyButtonDevice" "Configuration for my one-button device"
   Name String 1 "Name" "Unique name of an instance of this chunk type"
   port String 1 "Port" "Serial port this device is connected to"
   baud Int 1 "Baud Rate" "Serial port speed"
   end</programlisting>
               <para>For a real device, all of these parameters may or may not be needed. Again, the VjControl chunk description editor simplifies the creation of this description so that only the required elements are present.</para>
               <note>
                  <para>If the new driver is for a positional device, its name must be added to the enumeration in the <varname>PosProxy</varname> chunk description. VjControl aids this addition.</para>
               </note>
               <para>Once the chunk description is in place, a new configuration chunk can be created. Once again, VjControl makes the step easier. The following is an example configuration file that configures the one-button device we have been using thus far:</para>
               <programlisting>vjincludedescfile
  Name "mybuttondevice.desc"
  end
MyButtonDevice
  Name"Button Device"
  port { "/dev/ttyd4" }
  baud { "9600" }
  end
End</programlisting>
            </section>
            <section>
               <title>Writing Code that Accepts the Configuration</title>
               <para>In the driver, there are two methods that must be implemented in order to handle config chunks:</para>
               <orderedlist>
                  <listitem>
                     <methodsynopsis>
                        <modifier>static</modifier>
                        <type>std::string</type>
                        <methodname>MyNewButtonDevice::getChunkType</methodname>
                        <void/>
                     </methodsynopsis>
                     <para>When the VR system configuration changes, the system asks every registered driver for their chunk type. If it matches the new configuration chunk passed into the system, then the driver's <methodname>config()</methodname> method is invoked. This will happen, for example, when a new configuration file is loaded into the VR Juggler kernel. The implementation of this method was described above.</para>
                  </listitem>
                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>bool</type>
                        <methodname>gadget::Input::config</methodname>
                        <methodparam>
                           <type>jccl::ConfigChunkPtr</type>
                           <parameter>c</parameter>
                        </methodparam>
                     </methodsynopsis>
                     <para>When the system detects a configuration change for a given driver, it will pass the new <classname>jccl::ConfigChunkPtr</classname> object to this method. For more information about how to access config chunk objects, refer to the <emphasis>Programmer's Reference</emphasis>. The following is a simple example for the basic button device we have used thus far:</para>
                     <programlisting>bool MyNewButtonDevice::config( jccl::ConfigChunkPtr c )
{
   if (!gadget::Digital::config(c))
      return false;

   port_id = c-&gt;getProperty("port");
   baudRate = c-&gt;getProperty("baud");

   return true;
}</programlisting>
                  </listitem>
               </orderedlist>
            </section>
         </section>
         <section>
            <title>Example Code</title>
            <indexterm>
               <primary>device drivers</primary>
               <secondary>example</secondary>
            </indexterm>
            <para>Now that we have explained the concepts involved in adding a device driver to VR Juggler, we can show some code. The following example is for a fictitious piece of hardware that has only one button.</para>
            <programlisting linenumbering="numbered">#include &lt;gadget/Type/Digital.h&gt;
#include &lt;gadget/Type/DeviceFactory.h&gt;
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Sync/Guard.h&gt;


class MyButtonDevice : public gadget::Digital
{
public:
   MyButtonDevice() : mSampleThread(NULL)
   {;}

   virtual ~MyButtonDevice()
   {
      this-&gt;stopSampling();
   }

   virtual void  getData();
   virtual int   startSampling();
   virtual int   sample();
   virtual int   stopSampling();
   static std::string getChunkType();

private:
   static void   threadedSampleFunction(void* classPointer);
   int           mDigitalData;
   vpr::Thread*  mSampleThread;
   
   // configuration data set by config()
   int           mPortId, mBaud;
};

gadget::DeviceConstructor&lt;MyButtonDevice&gt;* this_ptr_not_used =
   new gadget::DeviceConstructor;

//: What is the name of this device?
//  This function returns a string that should match this device's 
//  config chunk name.
static std::string MyButtonDevice::getChunkType() 
{ 
   return std::string("MyButtonDevice");
}

// spawn a sample thread, 
// which calls MyButtonDevice::sample() repeatedly
int MyButtonDevice::startSampling()
{
   mSampleThread = new vpr::Thread(threadedSampleFunction, (void*)this);

   if ( !mSampleThread-&gt;valid() )
      return 0; // thread creation failed
   else 
      return 1; // thread creation success
}
   
//: Record (or sample) the current data
// this is called repeatedly by the sample thread created by startSampling()
int MyButtonDevice::sample()
{
   // here you would add your code to 
   // sample the hardware for a button press:
   mDigitalData[progress] = rand_number_0_or_1();
   return 0;
}

// kill sample thread
int MyButtonDevice::stopSampling()
{
   if ( mSampleThread != NULL )
   {
      mSampleThread-&gt;kill();
      delete mSampleThread;
      mSampleThread = NULL;
   }
   return 1;
}

//: function for users to get the digital data.
//  here we overload gadget::Digital::getDigitalData
int MyButtonDevice::getDigitalData(int d)
{
   // only one button, so we ignore "d"
   return mDigitalData[current];
}

// Our threaded sample function
// This function is declared as a static member of MyButtonDevice
// just spins... calling sample() over and over.
void MyButtonDevice::threadedSampleFunction(void* classPointer)
{
   MyButtonDevice* this_ptr = static_cast&lt;MyButtonDevice*&gt;( classPointer );

   // spin until someone kills "mSampleThread"
   while (1)   
   {
     this_ptr-&gt;sample();
     sleep(1); //specify some time here, so you don't waste CPU cycles
   }
}

//: When the system detects a configuration change for your driver, it will
//  pass the new jccl::ConfigChunkPtr into this function.  See the documentation
//  on config chunks, for information on how to access them.
bool MyButtonDevice::config(jccl::ConfigChunkPtr c)
{
  if ( !gadget::Digital::config(c) )
     return false;

  mPortId = c-&gt;getProperty("port");
  mBaud = c-&gt;getProperty("baud");

  return true;
}</programlisting>
         </section>
      </chapter>
   </part>
   <index/>
</book>
