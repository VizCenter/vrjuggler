<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="../src/Juggler/docs/stylesheet/docbook_ab.css" type="text/css"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article>
   <articleinfo>
      <title>VR Juggler</title>
      <subtitle>FAQ</subtitle>
      <releaseinfo>Version 1.1 DR2</releaseinfo>
      <pubdate>$Date$</pubdate>
   </articleinfo>
   <qandaset>
      <qandadiv>
         <title>General Information</title>
         <qandaentry>
            <question>
               <para>Is there a FAQ for VR Juggler?</para>
            </question>
            <answer>
               <para>Yes, check out <ulink url="http://www.vrjuggler.org/">http://www.vrjuggler.org/</ulink> where you will find a FAQ on the menu to the left. Submit any new questions, or any solutions you've found that are useful to <ulink url="http://www.sourceforge.net/mail/?group_id=8041">the user mail list</ulink>.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>Are there any applications (other than the demos) that can be downloaded?</para>
            </question>
            <answer>
               <para><ulink url="mailto:vrjuggler-contact@vrjuggler.org"></ulink>Not yet, but we will take submissions! You could become famous with your cool app! Mail it to us.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>What is VR Juggler?</para>
            </question>
            <answer>
               <para>VR Juggler is a C++ class library that is used as a framework for application development. VR Juggler controls the low-level aspects of the system on which the user application is executing. It provides a generic interface to common input and output devices that VR Juggler can control. VR Juggler controls the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Graphics rendering</para>
                  </listitem>
                  <listitem>
                     <para>VR devices</para>
                  </listitem>
                  <listitem>
                     <para>Graphic projection setup</para>
                  </listitem>
                  <listitem>
                     <para>Multi-processing</para>
                  </listitem>
                  <listitem>
                     <para>Process synchronization</para>
                  </listitem>
               </itemizedlist>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>What is VR Juggler not?</para>
            </question>
            <answer>
               <para>VR Juggler does not have its own graphics API. It requires you to use a standard API such as OpenGL. VR Juggler does not have any support for scene graphs or other data structures for the application graphics. VR Juggler is not a visual development environment.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>Great, where do I begin?</para>
            </question>
            <answer>
               <para>To begin, we suggest reading one of VR Juggler's books called the <emphasis>Getting Started Guide</emphasis>. You will find this book in the tree control on the <ulink url="http://www.vrjuggler.org/">VR Juggler website</ulink>. In the tree control, the path to getting started is: <quote>Documentation</quote>/<quote>Getting Started</quote>.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>What do I need to run a VR Juggler application?</para>
            </question>
            <answer>
               <para>For a very specific answer to this question, check out the <ulink url="http://www.vrjuggler.org/html/download/">downloads page</ulink>. There will be requirements next to each VR Juggler distribution. Generally you will need OpenGL or OpenGL Performer as your image generator. VR Juggler will run by itself otherwise (you will not need any other display driver such as <trademark>CAVElib</trademark>, or <trademark>World Toolkit</trademark>).</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>What C++ compilers are supported?</para>
            </question>
            <answer>
               <para>The following lists supported platforms and the compilers that we use in developing and distributing versions of VR Juggler for those platforms: If you do not have the supported compiler for your operating system, we will be limited in how much we can help you.</para>
               <itemizedlist>
                  <listitem>
                     <para><emphasis>IRIX</emphasis>: we require the MIPSpro Compilers, version 7.3.1.1m or higher and the associated STL implementation. Previous versions had bugs that caused VR Juggler to crash.</para>
                  </listitem>
                  <listitem>
                     <para><emphasis>Win32</emphasis>: we only support Microsoft Visual C++ 6.0 with Service Pack 4. You can use Service Pack 3, but it is recommended that you upgrade if possible. There have been reports of VR Juggler compiling with Visual C++ 5.0, but we do not officially support that version.</para>
                  </listitem>
                  <listitem>
                     <para><emphasis>Other platforms</emphasis>: we support the latest versions of GCC only. You must use at least GCC 2.95.2. GCC 3.0 is also supported.</para>
                  </listitem>
               </itemizedlist>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>How do I compile the VR Juggler source code under Win32?</para>
            </question>
            <answer>
               <para>You really don't need to do this unless you plan to modify the code and submit the changes to us. You can find precompiled binaries for Win32 on our <ulink url="http://www.vrjuggler.org/html/download/">downloads page</ulink>. To compile the source code to VR Juggler on Win32 platforms, you will want to <ulink url="http://sources.redhat.com/cygwin/download.html">download the Cygwin set of UNIX tools</ulink> including Perl 5.6.1, GNU Autoconf, and GNU Automake. You can find detailed information about all of this in <quote>Documentation</quote>/<quote>Juggler Team Guide</quote>/<quote>Build Systems</quote>/<quote>Juggler</quote>/<quote>Win32 Caveats</quote> of the <emphasis>Juggler Team Guide</emphasis> (book) on our web site.</para>
            </answer>
         </qandaentry>
      </qandadiv>
      <qandadiv>
         <title>VjControl</title>
         <qandaentry>
            <question>
               <para>Why doesn't VjControl run?</para>
            </question>
            <answer>
               <para>Prior to the release of VR Juggler 0.1.97, VjControl would work with Java 1.1 provided that the Java Swing classes were available in a JAR file called <filename>swingall.jar</filename>. VjControl purposely ignores your <varname>$CLASSPATH</varname> environment variable, so with the old releases we recommend that you place <filename>swingall.jar</filename> file into your <filename>bin</filename> directory along with the <command>vjcontrol</command> or <command>vjcontrol1.1</command> executable. Since VR Juggler 0.1.97, VjControl <emphasis>only</emphasis> works with Java 2 or newer (JDK versions 1.2 and higher). Because of this, <filename>swingall.jar</filename> is no longer needed.</para>
               <para>Another possibility is that you do not have the <varname>$VJ_BASE_DIR</varname> environment variable set. Setting this variable is <emphasis>required</emphasis> to run VjControl because the shell script (or batch file on Win32) needs to be able to find the file <filename>VjControl.jar</filename> which is always located in <varname>$VJ_BASE_DIR/bin</varname> with the <command>vjcontrol</command> script and <command>vjcontrol.bat</command> batch file. Refer to the documentation describing <ulink url="http://www.vrjuggler.org/html/getting.started/environment.variables.html">environment variables</ulink> for more information. It explains all the environment variables related to VR Juggler (and VjControl).</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>What is <filename>swingall.jar</filename>?</para>
            </question>
            <answer>
               <para>The file <filename>swingall.jar</filename> contains the Swing classes that are part of the Java 2 distribution. These classes were need to use Swing with Java 1.1. You may need to install the Java Swing distribution from <ulink url="http://www.sun.com/">Sun</ulink>. After you do that, find the file <filename>swingall.jar</filename> (in the Java installed location), and copy it to the same place as where the <command>vjcontrol</command> executable is (usually in <filename>$VJ_BASE_DIR/bin</filename>).</para>
            </answer>
         </qandaentry>
      </qandadiv>
      <qandadiv>
         <title>VR Applications</title>
         <qandaentry>
            <question>
               <para>When I run on IRIX, the application hangs right after printing <quote>New application set</quote></para>
            </question>
            <answer>
               <para>This most often happens when using the IRIX SPROC version of VR Juggler and linking the POSIX thread library (<filename>libpthread</filename>) into the application. When you compile your VR Juggler application, make sure not to use <parameter>-lpthread</parameter>. If your application requires POSIX threads, use the pthreads version of VR Juggler instead.</para>
               <para>On IRIX, there are two ways to write multithreaded softare, and VR Juggler supports both. The methods are IRIX SPROC and POSIX threads. These two systems are incompatible, and a SPROC application will hang the first time it tries to createa thread if the POSIX thread library is linked. Removing <parameter>-lpthread</parameter> fixes the problem.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>Why is there a blue sphere and a green cone in my way when I run in simulator mode?</para>
            </question>
            <answer>
               <para>When you run in simulator mode, typically there will be VR Juggler simulator displays open showing the 3D space you are simulating. These are a special type of VR Juggler display. Instead of basing its viewpoint on the head position of one of the users, the viewpoint is controlled by a separate <quote>camera</quote> that is just another positional device. The Sim Display also draws certain objects to help visualize the environment. For example, the heads of users are represented as blue spheres with gray eyes, and a wand (if present) is drawn as a green cone. These are seen only in simulator displays and are there to help you if you are doing development using the simulator environment.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>How do I port a <trademark>CAVElib</trademark> application to VR Juggler?</para>
            </question>
            <answer>
               <para>Refer to the CAVElib-to-Juggler porting guide in the <emphasis>Programmer's Guide</emphasis> for details and code examples. For something quick, an overview follows.</para>
               <para>In a VR Juggler <classname>vjApp</classname> class, there are five functions which you'll find immediately important: one for initialization, one for drawing (OpenGL only), and three for computation (I usually use only one of these). The two initialization functions are called upon execution of the application:</para>
               <orderedlist>
                  <listitem>
                     <para><methodname>init()</methodname> (called once when the application starts)</para>
                  </listitem>
                  <listitem>
                     <para><methodname>contextInit()</methodname> (called once per window/graphics context creation) </para>
                  </listitem>
               </orderedlist>
               <para>The other three are called repeatedly in this order:</para>
               <orderedlist>
                  <listitem>
                     <para><methodname>preFrame()</methodname></para>
                  </listitem>
                  <listitem>
                     <para><methodname>draw()</methodname> (called once per open display)</para>
                  </listitem>
                  <listitem>
                     <para><methodname>postFrame()</methodname></para>
                  </listitem>
               </orderedlist>
               <para>These are the conceptual steps your application will take and should thus influence the structure of your application:</para>
               <orderedlist>
                  <listitem>
                     <para>Initialize your data in <methodname>init()</methodname>.</para>
                  </listitem>
                  <listitem>
                     <para>Initialize your display contexts and texture objects in <methodname>contextInit()</methodname>. You will need to keep track of the ID/index per graphics window. The <classname>vjContextData</classname> class will help you with this.</para>
                  </listitem>
                  <listitem>
                     <para>Do your computations (such as modifying your data with VR Juggler input devices) in <methodname>preFrame()</methodname> and/or <methodname>postFrame()</methodname>.</para>
                  </listitem>
                  <listitem>
                     <para>Don't do your computations in <methodname>draw()</methodname>. Instead, just read your current data state, and draw (render) it. If you have display lists or texture objects, you will need to keep track of the ID/index per graphics window and call them accordingly.</para>
                  </listitem>
               </orderedlist>
               <para>Note that <methodname>draw()</methodname> is threaded, so may be called during <methodname>preFrame()</methodname> or during <methodname>postFrame()</methodname>. <methodname>contextInit()</methodname> is similar.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>I'm a <trademark>CAVELib</trademark> user that's trying to learn VR Juggler for a new project. Is there an easy way to setup a 2D projection on the walls? In <trademark>CAVElib</trademark> you'd do a <function>CAVEWallTransform()</function> which puts you in a 2D projection on the current wall so you can do 2D overlay stuff (disable lights &amp; depth test, then a lot of <function>glVertex2f()</function>). </para>
            </question>
            <answer>
               <para>This is OpenGL specific. Turn off the depth buffer testing, and then draw your 3D geometry at the same position that the wall is at. Make sure you draw it last too. Also, don't transform the geometry with your navigation matrix.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>I am used to <trademark>CAVELib</trademark> capabilities. Is there a way to tell which wall you're drawing on?</para>
            </question>
            <answer>
               <para>You will know what wall you're drawing on by the position of your geometry. This way, you won't have to do any thing weird or morally wrong, like draw 2D in a 3D VR environment. Personally though, I wouldn't ever draw just on one wall, since technically the user isn't supposed to know the walls are there (that's what we call immersion). It could ruin the effect for them. I'd just put it up somewhere convenient in 3D space (if that happens to be the wall, then I wouldn't let that stop me. The depth buffer trick (described in the previous answer) will ensure that you'll always see it, but be careful since it can really confuse your users if something gets positioned in front of your head up display.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>How do I port a GLUT application to VR Juggler?</para>
            </question>
            <answer>
               <para>Please refer to the VR Juggler <emphasis>Programmer's Guide</emphasis> for a discussion on this topic and for example code.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>When I compile, the file <filename>vector</filename> (or <filename>algorithm</filename> or <filename>iostream</filename> etc.) cannot be found</para>
            </question>
            <answer>
               <para>VR Juggler depends on the C++ compiler implementing the latest C++ standard. This is especially true in the case of Standard Template Library support. The latest VR Juggler code also uses the standard <filename>iostream</filename> classes (part of the <literal remap="tt">std</literal> namespace). If your compiler does not support these features, it cannot be used to compile VR Juggler or any VR Juggler applications. Make sure that you are using one of the supported compilers. If not, you will need to upgrade.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>When mouse/wand clicks are setup to register as digital button presses it is hard to get just one click</para>
            </question>
            <answer>
               <para>You will want to look at <firstterm>edge triggering</firstterm> on vjDigital devices.. An edge trigger gives you 4 states: on, off, just-on, or just-off. VR Juggler digital devices do edge triggering for you automatically. You will want to test for <quote>just-on</quote> so that your presses do not keep retriggering. For example, you can test it in the following to see when the button is first pressed:</para>
               <programlisting>if ( vjDigital::TOGGLE_ON == vjDigitalProxy::getData() )
{
   // Button just pressed
}</programlisting>
            </answer>
         </qandaentry>
      </qandadiv>
      <qandadiv>
         <title>VR Juggler Development</title>
         <qandaentry>
            <question>
               <para>How can I submit changes/patches?</para>
            </question>
            <answer>
               <para>This question is too broad to be answered concisely here. Lucky for you, there is an entire chapter in the <emphasis>Juggler Team Guide</emphasis> just on exactly this topic.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>How do I join the VR Juggler development team?</para>
            </question>
            <answer>
               <para>It's easy: just <ulink url="mailto:vrjuggler-contact@vrjuggler.org">email us</ulink>. Currently there is much to be done, especially in the device driver department. We are very interested in working with anyone, especially people willing to port their drivers to Juggler. <ulink url="mailto:vrjuggler-contact@vrjuggler.org">Contact us directly</ulink> with your thoughts, ideas, and be ready to work on a cool and upcoming player in the world of VR! (shameless plug) </para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>I wrote and regierstered my device driver correctly, but VR Juggler cannot find it.</para>
            </question>
            <answer>
               <para>When the compiler sees the following code, it thinks that no one is using the code. As a result, it optimizes this code out when you link against your library.</para>
               <programlisting>#include Input/InputManager/vjDeviceFactory.h
vjDeviceConstructorMyButtonDevice* this_ptr_not_used =
   new vjDeviceConstructorMyButtonDevice;</programlisting>
               <para>The solution is to make sure that the compiler is told to include <emphasis>all</emphasis> library symbols. On IRIX with the MIPSpro Compilers, you will need to use the <parameter>-all</parameter> option when linking the application. With GCC, the equivalent options are-Wl,--whole-archive and -Wl,--no-whole-archive. Wrap these around statically listings of statically linked libraries. For example:</para>
               <programlisting>$(LINK) -o app --Wl,-Bstatic --Wl,--whole-archive -lJuggler \
  -lmy_driver_lib --Wl,--no-whole-archive --Wl,-Bdynamic</programlisting>
            </answer>
         </qandaentry>
      </qandadiv>
      <qandadiv>
         <title>Troubleshooting: General Compiling</title>
         <qandaentry>
            <question>
               <para>When I compile a sample application, the compiler cannot find any VR Juggler headers.</para>
            </question>
            <answer>
               <para>The most common reason for this is that you did not set the environment variable <varname>$VJ_BASE_DIR</varname>. This is required for compiling as well as running because the makefiles for the shipped sample applications reference <varname>$VJ_BASE_DIR</varname> when telling the compiler where to look for files. VR Juggler itself needs <varname>$VJ_BASE_DIR</varname> at run time in order to find the configuration description information.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>When I compile a sample application, the compiler cannot find any VR Juggler libraries.</para>
            </question>
            <answer>
               <para>Refer to the previous answer.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>I just compiled on Platform X, but now my application's makefile does not work at all on Platform Y.</para>
            </question>
            <answer>
               <para>In general, different platforms have different development environments. It is very difficult to guarantee that a compiler will behave exactly the same between two different platforms. This is especially true when moving from a Win32 environment to a version of UNIX or vice versa. The sample applications shipped with VR Juggler binary distributions all have their own makefile (unsurprisingly named <filename>Makefile</filename>) that was generated for use on the specific platform where VR Juggler was compiled. The fifth line of these files names this platform. This information is there to tell you where you can expect the makefile to work. If you have based your application's makefile on one of these samples, you should expect to do some work to get your application to build on another platform. While the code will not have to change (ideally), the way the compiling works probably will change. That is just a fact of life when working with multiple platforms. While it is theoretically possible to use the same single makefile on many different platforms, VR Juggler itself does not offer such a solution. That is most definitely not within the scope of the VR Juggler project.</para>
            </answer>
         </qandaentry>
      </qandadiv>
      <qandadiv>
         <title>Troubleshooting: OpenGL Performer</title>
         <qandaentry>
            <question>
               <para>Why does texturing not work? I copied the <filename>pfNav</filename> sample!</para>
            </question>
            <answer>
               <para>An old version of Juggler had a <function>pfDisable()</function> in its <command>pfNav</command> sample program. Remove this and the <function>pfOverride()</function> line, and you'll be golden.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>Why don't my Performer-based VR Juggler applications compile on Linux?</para>
            </question>
            <answer>
               <para> Maybe you aren't using the <parameter>-O</parameter> option to your compiler. You must compile with the <parameter>-O</parameter> option when using <ulink url="http://www.sgi.com/software/performer/linux.html">Performer 2.3, 2.4, or 2.5 for LiNUX</ulink>. See the <ulink url="http://www.sgi.com/software/performer/linux-buglist.html">Performer LiNUX bug-list (item SCR 767188)</ulink> for more info.</para>
            </answer>
         </qandaentry>
         <qandaentry>
            <question>
               <para>Why don't my Performer-based VR Juggler applications compile on IRIX? I get an error that says <quote><filename>be.so</filename> not found</quote>.</para>
            </question>
            <answer>
               <para>Some SGI systems, specifically those using the MIPSpro Compiler version 7.3, need another directory added to the <varname>$LD_LIBRARY_PATH</varname> environment variable. It can be set as follows:<programlisting>% setenv LD_LIBRARY_PATH $VJ_BASE_DIR/lib32:/usr/lib32/cmplrs</programlisting>You will need to set this if your compiler reports it has trouble finding the file <filename>be.so</filename>. For more information on environment variables, refer to the <ulink url="http://www.vrjuggler.org/html/getting.started/"><emphasis>Getting Started Guide</emphasis></ulink>.</para>
            </answer>
         </qandaentry>
      </qandadiv>
   </qandaset>
</article>
