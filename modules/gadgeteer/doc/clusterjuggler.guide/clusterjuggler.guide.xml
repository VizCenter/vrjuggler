<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="file://localhost/home6/users/aronb/Source/StyleSheets/docs/stylesheet/docbook_ab.css" type="text/css"?>
<?morphon-document-settings
  morphon.document.settings.print.fixed.attributes="true"
  morphon.document.settings.relative.systemids="2"
  morphon.document.settings.print.defaultvalues.attributes="false"
  morphon.document.settings.print.empty.tags="true"
  morphon.document.settings.whitespaces.amount="3"
  morphon.document.settings.stylesheetpi.autoupdate="true"
  morphon.document.settings.maxlinelength="0"
  morphon.document.settings.whitespaces.type="indent"
  morphon.document.settings.endofline.type="2"
?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>VR Juggler</title>
      <subtitle>Cluster Juggler Guide</subtitle>
      <releaseinfo>Version 1.1 DR2</releaseinfo>
      <pubdate>$Date$</pubdate>
   </bookinfo>
   <preface>
      <title>Preface</title>
      <para>This book is intended for people who are interested in using the Cluster Juggler extension to VRJuggler. It gives the user a brief background of what ClusterJuggler is and what it was created for. The user will also learn how to configure a simple application using Cluster Juggler. </para>
      <para>The prerequisites for reading this book are minimal. They are:</para>
      <itemizedlist>
         <listitem>
            <para>Experience running and configuring VRJuggler applications</para>
         </listitem>
         <listitem>
            <para>A basic knowledge of simple networking</para>
         </listitem>
      </itemizedlist>
   </preface>
   <chapter label="1">
      <title>What is Cluster Juggler</title>
      <abstract>
         <title>Overview</title>
         <para>Cluster Juggler is designed to make PC clusters a feasible alternative to expensive shared memory systems. It cannot simply utilize the design of traditional clusters because virtual reality requires special functionality not present in conventional cluster applications. It also should not put the burden on the VR application developer to perform communication between cluster nodes. To prevent burdening the developer, the design retains some of the features that shared memory systems provide for virtual reality by hiding the complexities of a cluster. Our goal is to design a distributed shared memory system for VR application I/O (input/output) data. As a result of distributed I/O, application development and execution can transparently move between shared memory VR systems and PC cluster VR systems. This means the same VR applications will run on both systems, with no or very minimal changes. </para>
         <para>Not only is this design intended to make a useful virtual reality cluster, it intends to make this technology easily available to anyone who desires to use it. To allow this, the key components to this cluster design are commodity hardware and open software. The commodity computer hardware needed to power the cluster is personal computers with Ethernet cards, but there is still no commodity replacement for some specialized components such as tracking devices and quality projection systems (although trade-offs can be made with technology such as passive stereo). The specific nodes and components in an individual cluster will vary and can be customized to the needs of each cluster. </para>
      </abstract>
      <abstract>
         <title>Cluster Functions</title>
         <para>The design for ClusterJuggler presents two main types of cluster functionality. The purpose of distinguishing between these functions is to allow them to be separated so that their tasks can be performed on different cluster nodes if desired. Any node can perform one or both of these functions. The two types include:<simplelist>
               <member>Input Functions: receive and interpret data from input devices </member>
               <member>Rendering Functions: produce data for displays</member>
            </simplelist></para>
      </abstract>
      <abstract>
         <title>Cluster Input/Output</title>
         <para>Virtual reality systems have input devices to allow them to be interactive. The input functions in the PC cluster involve handling the data from these devices. It is not necessary to dedicate an entire node to processing input, but this can help if the burden of running other tasks simultaneously is too great and there are extra nodes available. Also, if a large number of input devices are to be used, our design allows the devices to be spread across the cluster nodes. This prevents problems such as multiple input devices creating a large workload on a single computer, or all input hardware not being able to attach to a single PC. </para>
         <para>In order to distribute input from one computer to other nodes in the cluster, ClusterJuggler makes additions to VR Juggler software. VR Juggler already has an input manager that handles local input data on a single computer. As seen in Figure 1, the input manager is part of VR Juggler's specialized microkernel design that uses managers to handle different tasks. </para>
         <para><graphic fileref="figures/micro.png" format="PNG"/></para>
         <para>Figure 1. VR Juggler Microkernel Architecture </para>
         <para>ClusterJuggler extends VR Juggler by adding a remote input manager to the existing input manager. This addition handles the communication of input data between cluster nodes. In communicating the data, the remote input manager also synchronizes the nodes each frame. </para>
         <para>There are other benefits to the remote input manager besides synchronization. Depending on the type of input device and the number of devices, the process of receiving input can be burdensome. The remote input manager can alleviate some of the burden on nodes by processing input data before distributing it. This frees up processing time on the other nodes and can also reduce network traffic. This is illustrated in Figure 2. </para>
         <para><graphic fileref="figures/DistributeData.png" format="PNG"/></para>
         <para>Figure 2. Processing and Distribution of Input </para>
         <para>By distributing the input to cluster nodes across the network, we can remove the typical cluster computing constraint of having identical computers at each node. To allow different platforms on our nodes, our network communication design needs to account for cross-platform issues. For example, in Figure 2Computer A can be a Linux based machine; Computer B can be a Windows based machine, and Computer C can be an SGI computer. </para>
         <para>Not only does the remote input manager have useful functionality, but it also intends to avoid forcing the application programmer to worry about the location of devices. Once a cluster is set up, the programmer and application can act as if every input device is connected to every cluster node. The remote input manager avoids putting extra burden on application developers and hides the complications of the cluster from them. Figure 3 illustrates this concept.</para>
         <para><graphic fileref="figures/DeviceAccess.png" format="PNG"/></para>
         <para>Figure 3Transparency of Remote Device Access </para>
         <para>Although VR Juggler supports many platforms, new devices require their own drivers for each platform. This can restrict the use of new devices on VR systems because writing device drivers is time consuming. With the help of the ClusterJuggler, devices whose drivers have been integrated into VR Juggler on one platform can be utilized on other platforms as well. By connecting to another computer through ClusterJuggler, other platforms can retrieve device data across the network until drivers for the specific platforms are finally integrated. </para>
      </abstract>
      <abstract>
         <title>Cluster Displays</title>
         <para>Synchronizing multiple displays is one of the biggest challenges in creating immersive VR on PCs. This is because a single PC does not have enough processing power to generate the graphics for multiple displays in VR systems such as a CAVE. Now that graphics hardware is becoming available to synchronize multiple active stereo PCs or show passive stereo, the design in ClusterJuggler must provide a way for a running applications that distributed across multiple PCs and graphic hardware. In order for application synchronization to work, the execution of an application needs to start on all application nodes at the same time. To do this, a barrier can be set up that pauses the start of an application until all nodes are connected and ready to start. Once an application has started, the input to each application is kept identical at all times in order for these nodes to maintain the same state. This input data is updated at a point of synchronization, when the application code is not being processed.</para>
      </abstract>
   </chapter>
   <chapter label="2">
      <title>How to configure a simple cluster application</title>
      <abstract>
         <simpara>In order to configure ClusterJuggler you need to do three things:</simpara>
         <para><orderedlist>
               <listitem>
                  <para>Create a Remote Input Manager chunk for the cluster.</para>
               </listitem>
               <listitem>
                  <para>Create a machine specific chunk for each node in the cluster.</para>
               </listitem>
               <listitem>
                  <para>Point each device to the node in the cluster that it is physically connected to.</para>
               </listitem>
            </orderedlist></para>
         <para><itemizedlist>
               <title>What does a Machine Specific Chunk consist of?</title>
               <listitem>
                  <para>Name - Unique name for the machine</para>
               </listitem>
               <listitem>
                  <para>Display System - Embedded display system chunk for the given machine.</para>
                  <para>chunk that contains the indexed list of display pipes to use on this machine.</para>
               </listitem>
               <listitem>
                  <para>Display Windows - Embedded display window chunks for the given machine.</para>
               </listitem>
               <listitem>
                  <para>Listen Port - TCP/IP port to listen for incoming device requests, only used if a device is connected locally. </para>
                  <para>NOTE: All cluster nodes must have a different port to listen on.</para>
               </listitem>
               <listitem>
                  <para>Hostname - Hostname for given machine.</para>
               </listitem>
               <listitem>
                  <para>Forced Hostname - Use if your machine has two interface cards and you want to use the non-standard card.</para>
               </listitem>
               <listitem>
                  <para>Sync Serial Port - Serial port that you want to use if your synchronization method utilizes serial communications.</para>
               </listitem>
               <listitem>
                  <para>Sync Baud Rate - Baud rate to set the serial port.</para>
               </listitem>
            </itemizedlist><itemizedlist>
               <title>What does a Remote Input Manager Chunk consist of?</title>
               <listitem>
                  <para>Name - Unique name for the cluster</para>
               </listitem>
               <listitem>
                  <para>Cluster Nodes - List of active nodes in the cluster. </para>
                  <para>NOTE: This means that you can have as many machine specific chunks as you want and only select the nodes that you want to use at any given time.</para>
               </listitem>
               <listitem>
                  <para>Sync Machine - Node that is responsible for synchronizing the cluster.</para>
               </listitem>
               <listitem>
                  <para>Sync Method - Enumerated value, 1 - TCP/IP sockets 2- TCP/IP sockets and serial mix, for choosing the method of synchronization.</para>
               </listitem>
            </itemizedlist><itemizedlist>
               <title>How do I point a device to a specific node?</title>
               <listitem>
                  <para>You simply need to select the correct cluster node from a drop down list in each device's Host Node property.</para>
               </listitem>
            </itemizedlist></para>
      </abstract>
      <abstract>
         <title>Step-by-Step Directions (Using vrjconfig)</title>
         <para><itemizedlist>
               <title>Create a new Config chunk for each node of the cluster.</title>
               <listitem>
                  <para>Step 1) Create a new Machine Specific Config chunk</para>
               </listitem>
               <listitem>
                  <para>Step 2) Enter a unique Instance name</para>
               </listitem>
               <listitem>
                  <para>Step 3) Create an embedded display system chunk</para>
               </listitem>
               <listitem>
                  <para>Step 3a) Enter the number of display pipes on this machine into numpipes</para>
               </listitem>
               <listitem>
                  <para>Step 3b) For each display pipe you must create a xpipe and set its location. (ex. ptah-1:0 or ptah-2:0)</para>
               </listitem>
               <listitem>
                  <para>Step 4) Create an embedded Display Window chunk for each display on the given node</para>
               </listitem>
               <listitem>
                  <para>Step 5) Enter the port that the machine will listen for device requests on.</para>
               </listitem>
               <listitem>
                  <para>Step 6) Enter the Hostname for the given machine.</para>
               </listitem>
               <listitem>
                  <para>Step 7) Enter the serial port that will be used for serial synchronization if enabled.</para>
               </listitem>
               <listitem>
                  <para>Step 8) Enter the baud rate for the synchronization port.</para>
               </listitem>
            </itemizedlist><graphic fileref="figures/vrjconfig1.png" format="PNG"/></para>
         <para><itemizedlist>
               <title>Create a new Remote Input Manager Chunk for the cluster.</title>
               <listitem>
                  <para>Step 1) Create a new Remote Input Manager Chunk.</para>
               </listitem>
               <listitem>
                  <para>Step 2) Enter a unique Instance name</para>
               </listitem>
               <listitem>
                  <para>Step 3) Add a reference to each cluster node.</para>
               </listitem>
               <listitem>
                  <para>Step 3a) Click on Add New Value</para>
               </listitem>
               <listitem>
                  <para>Step 3b) Select the node from the list</para>
               </listitem>
               <listitem>
                  <para>Step 4) Select the synchronization machine for the cluster.</para>
               </listitem>
               <listitem>
                  <para>Step 5) Select the synchronization method for the cluster.</para>
               </listitem>
            </itemizedlist><graphic fileref="figures/vrjconfig2.png" format="PNG"/></para>
         <para><itemizedlist>
               <title>Point each shared device to the cluster node that it is physically attached to.</title>
               <listitem>
                  <para>Step 1) Find the device that you want to share.</para>
               </listitem>
               <listitem>
                  <para>Step 2) Select the cluster node from the drop down list in the Host Node property.</para>
               </listitem>
            </itemizedlist><graphic fileref="figures/vrjconfig3.png" format="PNG"/></para>
      </abstract>
      <abstract>
         <title>Sample Configuration</title>
         <para>Lets take a simple example where we have 6 machines with the following settings, the configuration file for this cluster is included with VRJuggler at $(VJ_BASE_DIR)/share/vrjuggler/data/configFiles/ptah.cluster.config. (DR2 Releases do not contain this file. You can obtain it from the VRJuggler CVS on Sourceforge or by downloading <ulink url="http://www.vrjuggler.org/gadgeteer/0.3/clusterjuggler.guide/ptah.cluster.config">ptah.cluster.config</ulink>.</para>
         <para><graphic fileref="figures/ptah.png" format="PNG"/></para>
      </abstract>
      <abstract>
         <title>Developer Release Notes</title>
         <para><itemizedlist>
               <listitem>
                  <para>LOST CONNECTION ERROR: Currently keyboard devices are not able to be shared on the cluster, this causes ClusterJuggler to exit uncleanly at times. This will be a feature the will be included in the next release.</para>
               </listitem>
               <listitem>
                  <para>DEVICE DRIVER INHERITANCE: Please note the change in the inheritance tree for the device drivers. If you have developed your own drivers you will need to change the old line.</para>
                  <blockquote>
                     <para>sampleDevice : public Input, public Digital, public Position</para>
                     <para>to</para>
                     <para>sampleDevice : public InputMixer&lt; Input, InputMixer&lt; Digital, Position &gt;&gt;</para>
                  </blockquote>
               </listitem>
               <listitem>
                  <para>PERFORMER: If you are using Performer on a multiple processor machine, you must uncomment line 264 and comment out line 263 in modules/vrjuggler/vrj/Draw/Pf/PfDrawManager.cpp and rebuild VRJuggler.</para>
               </listitem>
               <listitem>
                  <para>SWAP-LOCK: ClusterJuggler currently only supports two methods of swap-locking the first being pure TCP/IP sockets. And the second being a half socket half serial connection method. The serial connection only needs to be split from the sync master to all sync slaves. We are currently still looking for a very simple and easily expandable method. Until a later release we suggest simply using the TCP/IP socket method.</para>
               </listitem>
            </itemizedlist></para>
      </abstract>
      <abstract>
         <title>Programmer's Notes</title>
         <para><itemizedlist>
               <listitem>
                  <simpara>If your application uses any time based methods or random number generation in your application, you must base them on a time stamp from a shared device.</simpara>
               </listitem>
            </itemizedlist></para>
      </abstract>
   </chapter>
</book>
