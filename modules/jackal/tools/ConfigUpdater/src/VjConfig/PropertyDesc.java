/*************** <auto-copyright.pl BEGIN do not edit this line> **************
 *
 * VR Juggler is (C) Copyright 1998-2003 by Iowa State University
 *
 * Original Authors:
 *   Allen Bierbaum, Christopher Just,
 *   Patrick Hartling, Kevin Meinert,
 *   Carolina Cruz-Neira, Albert Baker
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 *
 * -----------------------------------------------------------------
 * File:          $RCSfile$
 * Date modified: $Date$
 * Version:       $Revision$
 * -----------------------------------------------------------------
 *
 *************** <auto-copyright.pl END do not edit this line> ***************/


package VjConfig;

import java.util.StringTokenizer;
import java.util.*;
import VjConfig.ValType;
import VjConfig.DescEnum;
import java.io.*;

/** Individual PropertyDesc of a ChunkDesc.
 *  The PropertyDesc represents a single property, with its own name and type
 *  and with one or more values.  The PropertyDesc can include help text,
 *  individual labels for each value of the Property, and an enumeration of
 *  possible values.
 *
 *  Note that PropertyDesc doesn't have any inherent synchronization; anyone
 *  modifying a PropertyDesc needs to guarantee that no one else is looking
 *  at it at the same time.
 *
 *  @author Christopher Just
 *  @version $Revision$
 */
public class PropertyDesc implements Cloneable {

   private String name = "";
   private String token = "";
   private String help = "";
   private int num = 1;
   private ValType valtype = ValType.INVALID;
   private Vector mItems = new Vector();
   private int enumval = 0; // for assigning numeric defaults to enum entries

   // items for assisting in GUI displays of chunks.

   /** User level - 0 for beginner, 1 for expert.  default = 0. */
   private int user_level = 0;

   /** Contains a fixed set of possible values with string labels. */
   private ArrayList enums = new ArrayList();

    public Object clone () throws CloneNotSupportedException {
        PropertyDesc p = (PropertyDesc)super.clone();
        p.mItems = (Vector) mItems.clone(); // safe; it's a list of strings
        p.enums = (ArrayList) enums.clone();
//        int i, n = enums.size();
//        for (i = 0; i < n; i++) {
//            p.enums.add (((DescEnum)enums.get(i)).clone());
//        }
        return p;
    }


    /** Creates an "empty" PropertyDesc */
    public PropertyDesc () {
    }



    public PropertyDesc (ConfigStreamTokenizer st) {
	/* note: line is an unparsed configchunk line.  The only 
	 * assumption I'm willing to make about it is that it was
	 * generated by PropertyDesc << on the C++ side.  That
	 * actually lets us assume quite a bit.
	 */
	/* note 2: this gets pretty long & hairy and should probably
	 * be divied up quite a bit
	 */

	try {
	    st.nextToken();
	    token = st.sval;
	    st.nextToken();
	    valtype = ValType.getValType (st.sval);
	    st.nextToken();
	    num = Integer.parseInt(st.sval);
	    st.nextToken();
	    name = st.sval;
            enumval = 0;

	    //System.out.println ("reading property desc: " + name + " " + token);

	    st.nextToken();

	    // note: this next bit with vj_valuelabels and
	    // vj_enumeration tokens needs some cleanup later.
	    // right now vj_enumeration just gets ignored. It
	    // ought to be required, but that would break existing
	    // code, so for now it's just accepted.

	    if ((st.ttype == StreamTokenizer.TT_WORD) 
		&& st.sval.equalsIgnoreCase ("vj_valuelabels")) {
		st.nextToken();
		if (st.ttype != '{') {
		    System.err.println ("Error: parsing " + token + " expected '{' after vj_valuelabels" );
		}
		parseValueLabels (st);
	    }

	    if ((st.ttype == StreamTokenizer.TT_WORD) 
		&& st.sval.equalsIgnoreCase ("vj_enumeration"))
		st.nextToken();
	    if (st.ttype == '{') {
		parseEnumerations (st);
	    }

	    help = st.sval;
	    
	}
	catch (IOException e) {
	    System.err.println ("error in PropertyDesc constructor");
	    System.err.println (e);
	}
	catch (NumberFormatException e2) {
	    System.err.println ("PropertyDesc.<init>(): Invalid number format: " 
				+ st.sval);
	}
    }



    public void setName (String _name) {
        name = _name;
    }

    public String getName () {
        return name;
    }

    public void setToken (String _token) {
        token = _token;
    }

    public String getToken () {
        return token;
    }

    public void setHelp (String _help) {
        help = _help;
    }

    public String getHelp () {
        return help;
    }

    public void setValType (ValType t) {
        valtype = t;
    }

    public ValType getValType () {
        return valtype;
    }

   public void addItem (Item item)
   {
      mItems.add(item);
   }

   public Vector getItems ()
   {
      return mItems;
   }

   public void setItem (int index, Item item)
   {
      if ( index >= mItems.size() )
      {
         mItems.add(index, item);
      }
      else
      {
         mItems.set(index, item);
      }
   }

   /**
    * Returns a reference to the default value at the given index.  If there
    * is no such value, null is returned.
    */
   public VarValue getDefaultValue (int index)
   {
      VarValue val = null;
      if ( index < mItems.size() )
      {
         val = ((Item) mItems.get(index)).getDefaultValue();
      }

      return val;
   }

   /**
    * Returns a copy of the default value at the given index.  If there is
    * no such default value, null is returned.
    */
   public VarValue getDefaultValueCopy (int index)
   {
      VarValue val = getDefaultValue(index);
      VarValue val_copy = null;

      // If we do have a default value at the given index, make the copy.
      if ( val != null )
      {
         val_copy = new VarValue(val);
      }

      return val_copy;
   }

    public void setHasVariableNumberOfValues (boolean b) {
        if (b)
            num = -1;
        else
            num = 1;
    }

    public boolean getHasVariableNumberOfValues () {
        return (num == -1);
    }

    public void setNumValues (int n) {
        num = n;
    }

    public int getNumValues () {
        return num;
    }

    public void setUserLevel (int level) {
        user_level = level;
    }

    public int getUserLevel () {
        return user_level;
    }

    public void appendValueLabel (String label) {
        mItems.add(new Item(label, new VarValue(this.getValType())));
    }

    public int getValueLabelsSize () {
        return mItems.size();
    }

    public String getValueLabel (int i) {
        if (i < mItems.size())
            return ((Item) mItems.get(i)).getLabel();
        else
            return "";
    }

    public void appendEnumeration (String label, String value) {
        DescEnum d;
        VarValue v;
        if (value == "") {
            /* no explicit value */
            if (valtype == ValType.STRING ||
                valtype == ValType.CHUNK ||
                valtype == ValType.EMBEDDEDCHUNK)
                v = new VarValue(label);
            else
                v = new VarValue(enumval++);
        }
        else {
            v = new VarValue(valtype);
            v.set (value);
            /* explicit value */
//              VarValue val = new VarValue(valtype);
//              val.set (value);
//              d = new DescEnum (label, val);
        }
        enums.add (new DescEnum (label, v));
    }


    /* c had better be a collection of DescEnums, or things will get
     * real ugly real fast.
     */
    public void setEnumerations (Collection c) {
        enums.clear();
        enums.addAll (c);
    }

    public DescEnum[] getEnumerations () {
        DescEnum[] e = new DescEnum[enums.size()];
        return (DescEnum[])enums.toArray(e);
    }

    public int getEnumerationsSize() {
        return enums.size();
    }

    public DescEnum getEnumAtIndex (int ind) {
	return (DescEnum)enums.get(ind);
    }



    public boolean equals(PropertyDesc d) {
	DescEnum e1, e2;
	if (d == null)
	  return false;
	if (!name.equalsIgnoreCase(d.name))
	    return false;
	if (!token.equalsIgnoreCase(d.token))
	    return false;
	if (!help.equalsIgnoreCase(d.help))
	    return false;
	if (num != d.num)
	    return false;
	if (valtype != d.valtype)
	    return false;

	/* KLUDGE: This next part returns false if both
	 * PropertyDescs have the same descenums in a
	 * different order.  I'm not sure if the enums
	 * code enforces any kind of order or not, or
	 * if this is reasonable behavior. This should
	 * be examined more carefully.
	 */
	for (int i = 0; i <enums.size(); i++) {
	    try {
		e1 = (DescEnum)enums.get(i);
		e2 = (DescEnum)d.enums.get(i);
		if (!e1.equals(e2))
		    return false;
	    }
	    catch (ArrayIndexOutOfBoundsException e) {
		return false;
	    }
	}
	return true;
    }



    public String toString() {
	String s = token + " " + valtype + " " 
	    + num 
	    + " \"" + name + "\"";

	/* value labels: */
	if (mItems.size() > 0) {
	    DescEnum e;
	    s += " vj_valuelabels { ";
	    for (int i = 0; i < mItems.size(); i++) {
		s += "\"" + ((Item)mItems.get(i)).getLabel() + "\" ";
	    }
	    s += "}";
	}

	/* enumerations */
	if (enums.size() > 0) {
	    DescEnum e;
	    s += " vj_enumeration { ";
	    for (int i = 0; i < enums.size(); i++) {
		e = (DescEnum) enums.get(i);
                if (valtype == ValType.STRING ||
                    valtype == ValType.CHUNK ||
                    valtype == ValType.EMBEDDEDCHUNK)
		    s += "\"" + e.str + "\" ";
		else
		    s += "\"" + e.str + "=" + e.val + "\" ";
	    }
	    s += "}";
	}
	s += " \"" + help + "\"";
	return s;
    }



    public String xmlRep (String pad) {
        int i, n;
        DescEnum e;
        String newpad = pad + pad;
        // string buffer is a lot more painful code-wise but noticeably 
        // faster.
        StringBuffer retval = new StringBuffer (256);
        retval.append(pad);
        retval.append("<PropertyDesc token=\"");
        retval.append(XMLConfigIOHandler.escapeString(token));
        retval.append("\" name=\"");
        retval.append(XMLConfigIOHandler.escapeString(name));
        if (user_level != 0) {
            retval.append("\" userlevel=\"expert");
        }
        retval.append("\" type=\"");
        retval.append(valtype.toString());
        retval.append("\" num=\"");
        if (num == -1)
            retval.append ("variable\">\n");
        else {
            retval.append (num);
            retval.append ("\">\n");
        }
        if (!help.equals ("")) {
            retval.append(newpad);
            retval.append("<help>");
            retval.append(XMLConfigIOHandler.escapeString(help));
            retval.append("</help>\n");
        }

      // Loop over each of the items defined for this description.  The format
      // is <item label="..." defaultvalue="..."/>
      for (i = 0; i < mItems.size(); i++)
      {
         retval.append(newpad);
         retval.append("<item label=\"");
         retval.append(XMLConfigIOHandler.escapeString(((Item) mItems.get(i)).getLabel()));

         if ( this.valtype != ValType.EMBEDDEDCHUNK )
         {
            retval.append("\" defaultvalue=\"");
            retval.append(((Item) mItems.get(i)).getDefaultValue().toString());
         }

         retval.append("\"/>\n");
      }

        n = enums.size();
        if (n > 0) {
            for (i = 0; i < n; i++) {
                e = (DescEnum)enums.get(i);
                retval.append(newpad);
                retval.append("<enumeration name=\"");
                retval.append(XMLConfigIOHandler.escapeString(e.str));
                if (valtype == ValType.STRING ||
                    valtype == ValType.CHUNK ||
                    valtype == ValType.EMBEDDEDCHUNK)
                    retval.append("\"/>\n");
                else {
                    retval.append("\" value=\"");
                    retval.append(XMLConfigIOHandler.escapeString(e.val.toString()));
                    retval.append("\"/>\n");
                }
            }
        }
        retval.append(pad);
        retval.append("</PropertyDesc>\n");
        return retval.toString();
    }



    public VarValue getEnumValue(String val) {
	/* returns the value associated with this enum el */
	DescEnum t;
 	VarValue v;
	
	for (int i = 0; i < enums.size(); i++) {
	    t = (DescEnum)enums.get(i);
	    if (t.str.equalsIgnoreCase(val)) {
		v = new VarValue(t.val);
		return v;
	    }
	}
	v = new VarValue (valtype);
	v.set(val);
	return v;
    }



    public String getEnumString(VarValue val) {
	/* does the reverse mapping of getEnumVal - maps a value 
	 * back to the name of the enum entry 
	 */
	DescEnum t;

	for (int i = 0; i < enums.size(); i++) {
	    t = (DescEnum)enums.get(i);
	    if (t.val.equals(val)) {
		return t.str;
	    }
	}
	return val.toString();
    }



    private void parseEnumerations (ConfigStreamTokenizer st) {
	/* Parses a list of enumerations or valuelabels from
	 * st.  We assume that the opening '{' has already
	 * been read, and we go until we read and consume the
	 * closing '}'
	 */
	DescEnum d;
        String name, val;

	try {
	    /* we've got an enumeration to parse */
	    st.nextToken();
	    int j, enumval = 0;
	    float enumfloatval = 0.0f;
	    int k=0;
	    while (st.ttype != '}') {
		
		//System.out.println (st.sval);
		if (st == null) System.err.println ("foo");
		k++;
		j = st.sval.indexOf('=');
                if (j == -1) {
                    name = st.sval;
                    val = "";
                }
                else {
                    name = st.sval.substring(0,j);
                    val = st.sval.substring(j+1);
                }
                appendEnumeration (name, val);
		st.nextToken();
	    }
	    st.nextToken();
	}
	catch (IOException e) {
	    System.err.println ("error in ParseEnumerations");
	    System.err.println (e);
	}
    }


    private void parseValueLabels (ConfigStreamTokenizer st) {
	/* Parses a list of valuelabels from
	 * st.  We assume that the opening '{' has already
	 * been read, and we go until we read and consume the
	 * closing '}'
	 */
	DescEnum d;
        ArrayList v = new ArrayList();

	try {
	    /* we've got an enumeration to parse */
	    st.nextToken();
	    int j, enumval = 0;
	    float enumfloatval = 0.0f;
	    int k=0;
	    while (st.ttype != '}') {
		if (st == null) 
                    System.err.println ("foo");
                String n = st.sval;
                appendValueLabel (n);
		st.nextToken();
	    }
	    st.nextToken();
	}
	catch (IOException e) {
	    System.err.println ("error in ParseValueLabels");
	    System.err.println (e);
	}
    }

   /**
    * This is used to contain the attributes of a <ProprtyDesc>'s <item>
    * child(ren).
    */
   public static class Item
   {
      public Item (String label, VarValue defaultValue)
      {
         mLabel        = label;
         mDefaultValue = defaultValue;
      }

      public Item (String label, String value, ValType type)
      {
         mLabel = label;
         mDefaultValue = new VarValue(type);
         mDefaultValue.set(value);
      }

      public Object clone () throws CloneNotSupportedException
      {
         Item new_item          = (Item) super.clone();
         new_item.mLabel        = mLabel;
         new_item.mDefaultValue = mDefaultValue;

         return new_item;
      }

      public String getLabel ()
      {
         return mLabel;
      }

      public void setLabel (String label)
      {
         mLabel = label;
      }

      public VarValue getDefaultValue ()
      {
         return mDefaultValue;
      }

      public void setDefaultValue (VarValue value)
      {
         mDefaultValue = value;
      }

      private String   mLabel        = "";
      private VarValue mDefaultValue = null;
   }
}


