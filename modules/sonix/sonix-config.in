#!/usr/bin/env perl

# ***************** <SNX heading BEGIN do not edit this line> *****************
#
# sonix
#
# Original Authors:
#   Kevin Meinert
#
# -----------------------------------------------------------------
# File:          $RCSfile$
# Date modified: $Date$
# Version:       $Revision$
# -----------------------------------------------------------------
#
# ****************** <SNX heading END do not edit this line> ******************

# ************** <auto-copyright.pl BEGIN do not edit this line> **************
#
# VR Juggler is (C) Copyright 1998-2006 by Iowa State University
#
# Original Authors:
#   Allen Bierbaum, Christopher Just,
#   Patrick Hartling, Kevin Meinert,
#   Carolina Cruz-Neira, Albert Baker
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
# *************** <auto-copyright.pl END do not edit this line> ***************

use 5.004;

use strict 'vars';
use vars qw($ECHO_CXXFLAGS $ECHO_EXEC_PREFIX $ECHO_EXTRA_LIBS $ECHO_LIBS
            $ECHO_PREFIX);
use vars qw($exec_prefix $EXEC_PREFIX_SET $prefix $PREFIX_SET $LIBBITSUF
            $PLATFORM $SNX_ABI_FLAGS $SNX_ISA_FLAGS $Win32);

use File::Basename;
use Getopt::Long;

sub usage($);
sub normalizePath($);
sub runDepScript($$$);
sub make_CXXFLAGS($;$);
sub make_INCLUDES($);
sub make_LDFLAGS($;$$$);
sub make_EXTRA_LDFLAGS($;$$$);
sub handleOptArg($$);
sub stripDuplicateCompilerArgs($);
sub stripDuplicateLibraryArgs($);
sub groupLibdirArgs($);

usage(1) if $#ARGV == -1;

my @DEP_SCRIPTS = (['vpr-config', 'VPR_BASE_DIR']);

my $snx_default_abi = qq(@ABI@);
my $snx_default_isa = qq(@ISA@);
my $snx32_flags     = qq(@snx32_flags@);
my $snx64_flags     = qq(@snx64_flags@);
$LIBBITSUF          = qq(@LIBBITSUF@);
$PLATFORM           = qq(@PLATFORM@);

my $use_gcc = '@USE_GCC@';

$SNX_ABI_FLAGS = '';

# The default ABI is IRIX N32 or the default ISA is i386.
if ( $snx_default_abi =~ /32$/i  || "$snx_default_isa" eq 'i386' )
{
   $SNX_ABI_FLAGS = "$snx32_flags";
}
# The default ABI or ISA is 64-bit.
elsif ( "$snx_default_abi" eq '64' || "$snx_default_isa" eq 'x86_64' )
{
   $SNX_ABI_FLAGS = "$snx64_flags";
}

$SNX_ISA_FLAGS = '';

# If we are not using GCC and a known ISA is defined, add define the ISA
# argument for the compiler and linker.
if ( $use_gcc !~ /^y/i && $snx_default_isa =~ /^mips[34]/ )
{
   $SNX_ISA_FLAGS = "-$snx_default_isa";
}

# Set up variables used to determine what the real prefix is.  This is
# important when this script has been installed.
$Win32 = (defined($ENV{'OS'}) && $ENV{'OS'} =~ /^win/i);

# Set the location of the collection of dependencies.  If $VJ_DEPS_DIR is
# not defined, then $deps_dir will be an empty string.  If the dependencies
# are installed in $SNX_BASE_DIR, then the user gets the right compiler and
# linker path options for free.  Otherwise, it is up to the user to provide
# those paths.
my $deps_dir = "$ENV{'VJ_DEPS_DIR'}" if defined($ENV{'VJ_DEPS_DIR'});

# Get the directory where this script is located.
my $base_dir = (fileparse("$0"))[1];

# If we are on Windows and $base_dir contains \'s, set $path_sep to \.
# Otherwise, we use / for the path separator.
my $path_sep = (($Win32 && $base_dir =~ /\\/) ? "\\" : "/");

$base_dir =~ s|${path_sep}+$||o;     # Strip off the trailing slash(es)
$base_dir =~ s|${path_sep}+bin$||io; # If the path ends in "/bin", strip it

# Strip extra slashes from $base_dir.
normalizePath(\$base_dir);

# If we are on Windows, make sure that $base_dir is a full DOS path.
if ( $Win32  && $base_dir !~ /^[A-Za-z]:/ )
{
   chomp($base_dir = `cygpath -w $base_dir`);
   $base_dir =~ s|\\|/|g;   # We want / as the path separator
}

# $exec_prefix may refer to $prefix, so it must be set after $prefix is
# defined.
$prefix      = "$base_dir";
$exec_prefix = qq(@exec_prefix@);

$ECHO_PREFIX      = 0;
$ECHO_EXEC_PREFIX = 0;
$PREFIX_SET       = 0;
$EXEC_PREFIX_SET  = 0;
$ECHO_CXXFLAGS    = 0;
$ECHO_LIBS        = 0;
$ECHO_EXTRA_LIBS  = 0;

my $script_help    = 0;
my $print_min      = 0;
my $echo_includes  = 0;
my $echo_version   = 0;
my $echo_static    = 0;
my $echo_profiled  = 0;
my $use_linker     = 0;

my $cxxflags_arg   = '';
my $libs_arg       = '';
my $extra_libs_arg = '';

GetOptions('help|?' => \$script_help, 'min' => \$print_min,
           'version' => \$echo_version,
           'prefix:s' => \&handleOptArg, 'exec-prefix:s' => \&handleOptArg,
           'cxxflags:s' => \&handleOptArg, 'includes' => \$echo_includes,
           'libs:s' => \&handleOptArg, 'extra-libs:s' => \&handleOptArg,
           'linker' => \$use_linker, 'static' => \$echo_static,
           'profiled' => \$echo_profiled);

usage(0) if $script_help;

# Print out the requested information.
print "$prefix\n" if $ECHO_PREFIX;
print "$exec_prefix\n" if $ECHO_EXEC_PREFIX;
print "@MAJOR_VERSION@.@MINOR_VERSION@.@MICRO_VERSION@\n" if $echo_version;

if ( $ECHO_CXXFLAGS || $echo_includes )
{
   my $cxxflags = make_CXXFLAGS("$cxxflags_arg", $print_min);
   my $includes = make_INCLUDES("$cxxflags");
   print "$cxxflags\n" if $ECHO_CXXFLAGS;
   print "$includes\n" if $echo_includes;
}

if ( $ECHO_LIBS )
{
   my $ldflags = make_LDFLAGS("$libs_arg", $echo_static, $echo_profiled,
                              $use_linker);
   print "$ldflags\n";
}

if ( $ECHO_EXTRA_LIBS )
{
   my $extra_ldflags = make_EXTRA_LDFLAGS("$extra_libs_arg", $use_linker,
                                          $echo_static, $print_min);
   print "$extra_ldflags\n";
}

exit(0);

# =============================================================================
# Subroutines follow.
# =============================================================================

sub usage ($)
{
    print <<EOF;
Usage: $0 [OPTIONS] [LIBRARIES]
Options:
        [--prefix[=DIR]]        Print the installation prefix or set an
                                alternate prefix to use when printing paths
        [--exec-prefix[=DIR]]   Print the executable prefix or set an
                                alternate executable prefix to use when
                                printing paths
        [--version]             Print the installed Sonix' version number
        [--cxxflags [32|64]]    Print the Sonix-specific flags for the C++
                                compiler
        [--includes]            Print out only the header path extension
                                arguments
        [--libs [32|64]]        Print the basic Sonix-specific libraries
        [--extra-libs [32|64]]  Print the extra linker options needed for
                                making an executable
        [--linker]              Print libraries as direct arguments to the
                                linker rather than to the compiler
        [--static]              Print the library arguments using static
                                linking flags
        [--profiled]            Print the profiled library names
EOF

    exit($_[0]);
}

sub normalizePath($)
{
   my $path_ref = shift;

   # If we are on Windows and $base_dir contains \'s, set $path_sep to \.
   # Otherwise, we use / for the path separator.
   my $path_sep = (($Win32 && $$path_ref =~ /\\/) ? "\\" : "/");

   while ( $$path_ref =~ m|${path_sep}{2,}|o )
   {
      $$path_ref =~ s|${path_sep}{2,}|${path_sep}|go;
   }

   $$path_ref =~ s|${path_sep}+$||go;
}

sub runDepScript($$$)
{
   my $script_name = shift;
   my $base_dir    = shift;
   my $args        = shift;

   my $result = `$script_name $args`;
   my $status = $?;

   if ( $status != 0 )
   {
      if ( -x "$base_dir/bin/$script_name" )
      {
         $result = `$base_dir/bin/$script_name $args`;
         $status = $?;
      }
   }

   if ( $status == 0 )
   {
      chomp($result);
   }
   else
   {
      warn "WARNING: Could not find $script_name to execute!\n";
   }

   return $result or undef;
}

sub make_CXXFLAGS ($;$)
{
   my $cxxflags_arg = shift;
   my $print_min    = shift || 0;

   my $dep_cxxflags = '';

   unless ( $print_min )
   {
      my $script_info;
      foreach $script_info ( @DEP_SCRIPTS )
      {
         my $result = runDepScript($$script_info[0], $ENV{"$$script_info[1]"},
                                   "--min --cxxflags $cxxflags_arg");
         $dep_cxxflags = "$result $dep_cxxflags" if $result;
      }
   }

   # Default setting from configure.
   my $snx_extra_cxxflags = qq(@snx_extra_cxxflags@);

   if ( $cxxflags_arg =~ /32$/i )
   {
      $snx_extra_cxxflags = "$snx_extra_cxxflags $snx32_flags $SNX_ISA_FLAGS";
   }
   elsif ( "$cxxflags_arg" eq '64' )
   {
      $snx_extra_cxxflags = "$snx_extra_cxxflags $snx64_flags $SNX_ISA_FLAGS";
   }
   elsif ( "$cxxflags_arg" eq '' )
   {
      $snx_extra_cxxflags = "$snx_extra_cxxflags $SNX_ABI_FLAGS $SNX_ISA_FLAGS";
   }

   my $snx_extra_includes     = '';
#   my $snx_extra_include_dirs = qq(@snx_extra_include_dirs@);

#   if ( "$snx_extra_include_dirs" ne "" )
#   {
#      my $dir;
#      foreach $dir ( split(/\s+/, "$snx_extra_include_dirs") )
#      {
#         $snx_extra_includes .= " -I@includedir@/$dir";
#      }
#   }

   my $cxxflags = qq(@snx_cxxflags@ $dep_cxxflags $snx_extra_cxxflags ) .
                  qq(-I@includedir@ $snx_extra_includes);
   $cxxflags   .= " -I$deps_dir/include" if $deps_dir;

   # Strip out extra whitespace.
   $cxxflags =~ s/\s{2,}/ /g;

   return stripDuplicateCompilerArgs("$cxxflags");
}

sub make_INCLUDES ($)
{
   my(@compiler_flags) = split(/\s+/, "$_[0]");
   return join(" ", grep(/^-I/, @compiler_flags));
}

sub make_LDFLAGS ($;$$$)
{
   my $libs_arg      = shift;
   my $echo_static   = shift || 0;  # Echo static linking flags
   my $echo_profiled = shift || 0;  # Echo profiled libraries
   my $use_linker    = shift || 0;  # Use flags for direct use of the linker

   my $static_begin = '';
   my $static_end   = '';

   if ( $echo_static )
   {
      $static_begin = qq(@static_begin@);
      $static_end   = qq(@static_end@);
   }

   my $ldflags = '';

   if ( $libs_arg =~ /32$/i )
   {
      $ldflags   = "$snx32_flags $SNX_ISA_FLAGS";
      $LIBBITSUF = ("$PLATFORM" eq 'IRIX' ? '32' : '');
   }
   elsif ( "$libs_arg" eq '64' )
   {
      $ldflags   = "$snx64_flags $SNX_ISA_FLAGS";
      $LIBBITSUF = '64';
   }
   elsif ( "$libs_arg" eq '' )
   {
      $ldflags = "$SNX_ABI_FLAGS $SNX_ISA_FLAGS";
   }

   $ldflags .= ($use_linker ? qq( @snx_ldflags_linker@)
                            : qq( @snx_ldflags_compiler@));

   my $snx_libs  = ($echo_profiled ? qq(@snx_prof_libs@)
                                   : qq(@snx_libs@));
   my $full_ldflags = "$ldflags $static_begin $snx_libs $static_end";
   $full_ldflags    =~ s/\s{2,}/ /g;

   return groupLibdirArgs(stripDuplicateLibraryArgs("$full_ldflags"));
}

sub make_EXTRA_LDFLAGS($;$$$)
{
   my $extra_libs_arg = shift;
   my $use_linker     = shift || 0;
   my $use_static     = shift || 0;
   my $print_min      = shift || 0;

   my $dep_libs       = '';
   my $dep_extra_libs = '';

   unless ( $print_min )
   {
      my $linker_arg = ($use_linker ? '--linker' : '');
      my $static_arg = ($use_static ? '--static' : '');

      my $script_info;
      foreach $script_info ( @DEP_SCRIPTS )
      {
         my $cur_dep_libs =
            runDepScript($$script_info[0], $ENV{"$$script_info[1]"},
                         "--min --libs $extra_libs_arg $linker_arg $static_arg");
         $dep_libs .= " $cur_dep_libs";

         my $cur_dep_extra_libs =
            runDepScript($$script_info[0], $ENV{"$$script_info[1]"},
                         "--min --extra-libs $extra_libs_arg $linker_arg $static_arg");
         $dep_extra_libs .= " $cur_dep_extra_libs";
      }
   }

   if ( $extra_libs_arg =~ /32$/i )
   {
      $LIBBITSUF = ("$PLATFORM" eq 'IRIX' ? '32' : '');
   }
   elsif ( "$extra_libs_arg" eq '64' )
   {
      $LIBBITSUF = '64';
   }

   my $extra_ldflags = ($use_linker ? qq(@snx_extra_ldflags_linker@)
                                    : qq(@snx_extra_ldflags_compiler@));
   $extra_ldflags = "-L$deps_dir/lib$LIBBITSUF $extra_ldflags" if $deps_dir;

   # Add the full set of extra flags if the user specified --min on the
   # command line.
   my $snx_extra_libs_addtl = ($print_min ? '' : "$dep_libs $dep_extra_libs");

   my $full_extra_ldflags = qq($extra_ldflags @snx_extra_libs@ ) .
                            "$snx_extra_libs_addtl";
   $full_extra_ldflags    =~ s/\s{2,}/ /g;

   return groupLibdirArgs(stripDuplicateLibraryArgs("$full_extra_ldflags"));
}

# Subroutine for handling command-line parameters that have an optional
# argument.
sub handleOptArg ($$)
{
   my $name  = shift;
   my $value = shift || '';

   SWITCH:
   {
      if ( "$name" eq "prefix" )
      {
         # If $value is defined, we set $prefix to its value.  The value of
         # $prefix will not be printed in this case.
         if ( $value )
         {
            $prefix      = "$value";
            $ECHO_PREFIX = 0;
            $PREFIX_SET  = 1;
         }
         # If $value is undefined, that means that --prefix was specified, but
         # no value was given.  In that case, we just want to print the
         # prefix.
         else
         {
            $ECHO_PREFIX = 1;
         }

         last SWITCH;
      }

      if ( "$name" eq "exec-prefix" )
      {
         # If $value is defined, we set $exec_prefix to its value.  The value
         # of $exec_prefix will not be printed in this case.
         if ( $value )
         {
            $exec_prefix      = "$value";
            $EXEC_PREFIX_SET  = 1;
            $ECHO_EXEC_PREFIX = 0;
         }
         # If $value is undefined, that means that --exec-prefix was specified,
         # but no value was given.  In that case, we just want to print the
         # exec prefix.
         else
         {
            $ECHO_EXEC_PREFIX = 1;
         }

         last SWITCH;
      }

      if ( "$name" eq "cxxflags" )
      {
         $ECHO_CXXFLAGS = 1;
         $cxxflags_arg  = $value;
         last SWITCH;
      }

      if ( "$name" eq "libs" )
      {
         $ECHO_LIBS = 1;
         $libs_arg  = $value;
         last SWITCH;
      }

      if ( "$name" eq "extra-libs" )
      {
         $ECHO_EXTRA_LIBS = 1;
         $extra_libs_arg  = $value;
         last SWITCH;
      }
   }
}

# This is a fairly brute-force method for removing duplicated arguments from
# the given string.  It should not be used for argument lists such as those
# passed to the linker where functionality can be turned on and off (for
# example, the repeated use of -Wl,-Bstatic ... -Wl,-Bdynamic for selective
# static linking).
sub stripDuplicateCompilerArgs($)
{
   my @arg_list   = split(/\s+/, "$_[0]");
   my %known_args = ();
   my @new_args   = ();

   foreach ( @arg_list )
   {
      next if exists($known_args{"$_"});  # Skip previously seen arguments
      $known_args{"$_"} = 1;              # Register this argument
      push(@new_args, "$_");              # Add the argument to the new list
   }

   return join(" ", @new_args);
}

# This function processes the given list of linker arguments and removes
# duplicate references to libraries.  Library dependencies are identified as
# -l arguments, *.lib file references, or -pthread(s) arguments.  The
# duplicates are removed in reverse order so that the last appearance of an
# argument is the version that is retained.
sub stripDuplicateLibraryArgs($)
{
   my @arg_list   = split(/\s+/, "$_[0]");
   my %known_args = ();
   my @new_args   = ();

   my $arg;
   foreach $arg ( reverse(@arg_list) )
   {
      # Only look at arguments that name library dependencies.  All others
      # will be retained no matter what.
      if ( $arg =~ /^-l/ || $arg =~ /\.lib$/ || $arg =~ /^-pthread/ )
      {
         next if exists($known_args{"$arg"});
         $known_args{"$arg"} = 1;
      }

      unshift(@new_args, "$arg");
   }

   return join(" ", @new_args);
}

# This function processes the given list of linker arguments and does two
# things:
#
#    1. Removes duplicate paths to library directories.
#    2. Groups all paths to library directories so that they are at the
#       beginning of the link line.
#
# All other arguments are retained exactly as they came in.
sub groupLibdirArgs($)
{
   my @arg_list    = split(/\s+/, "$_[0]");
   my %known_args  = ();
   my @libdir_args = ();
   my @new_args    = ();

   my $arg;
   foreach $arg ( @arg_list )
   {
      # Only look at arguments that name library directories.  All others
      # will be retained no matter what.
      if ( $arg =~ /^-L/ || $arg =~ /^[-\/]libpath/i )
      {
         next if exists($known_args{"$arg"});
         $known_args{"$arg"} = 1;
         push(@libdir_args, "$arg");
      }
      else
      {
         push(@new_args, "$arg");
      }
   }

   return join(" ", @libdir_args, @new_args);
}
