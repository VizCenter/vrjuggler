

void pfCAVEProjection(pfChannel *chan,CAVE_WALL_ID wall,CAVEID eye)
{
 float frustum[6];
 pfMatrix caveviewmat,pfviewmat;
 CAVEGetProjection(wall,eye,frustum,caveviewmat);
 pfInvertAffMat(pfviewmat,caveviewmat);
 pfChanViewMat(chan,pfviewmat);
 pfChanAutoAspect(chan, PFFRUST_CALC_NONE);		/* Don't allow auto aspect */
 pfChanNearFar(chan, frustum[4], frustum[5]);
 pfMakePerspChan(chan,frustum[0],frustum[1],frustum[2],frustum[3]);
}


/**************************************************************************
 void CAVEGetProjection(CAVE_WALL_ID wall,CAVEID eye,float *frustum,Matrix viewmat)
**************************************************************************/
void CAVEGetProjection(CAVE_WALL_ID wall,CAVEID eye,float *frustum,Matrix viewmat)
{
 switch (wall)
	{
/* Allow only simulator display for those who have not bought the full
   CAVE license */
#ifndef CAPITALISTPIGS
	case CAVE_FRONT_WALL:
	case CAVE_LEFT_WALL:
	case CAVE_FLOOR_WALL:
	case CAVE_ARPAFLOOR_WALL:
	case CAVE_RIGHT_WALL:
	case CAVE_BACK_WALL:
	case CAVE_CEILING_WALL:
		CAVEGetWallProjection(wall,eye,frustum,viewmat);
		break;
	case CAVE_SCREEN0_WALL:
	case CAVE_SCREEN1_WALL:
	case CAVE_SCREEN2_WALL:
	case CAVE_SCREEN3_WALL:
	case CAVE_SCREEN4_WALL:
	case CAVE_SCREEN5_WALL:
	case CAVE_SCREEN6_WALL:
	case CAVE_SCREEN7_WALL:
		CAVEGetScreenProjection(wall,eye,frustum,viewmat);
		break;
	case CAVE_DUAL_EYE_WALL:
		CAVEGetDualEyeProjection(wall,eye,frustum,viewmat);
		break;
	case CAVE_LEFT_EYE_WALL:
	case CAVE_RIGHT_EYE_WALL:
		CAVEGetHMDProjection(wall,eye,frustum,viewmat);
		break;
#endif
	case CAVE_SIMULATOR_WALL:
	case CAVE_SIMULATOR1_WALL:
	case CAVE_SIMULATOR2_WALL:
		CAVEGetSimulatorProjection(wall,eye,frustum,viewmat);
		break;
	default:
		fprintf(stderr,"CAVE ERROR (CAVEGetProjection): No projection for"
			" wallid %d\n",CAVEWall);
	}
}

/**************************************************************************
 void CAVEGetWallProjection(CAVE_WALL_ID wall,CAVEID eye,float *frustum,Matrix viewmat)
 
    OK: Documnetation:
	Frustrum is the view frustrum down the -z axis
	viewmat is the translation mat to apply to get the frustrum into the right location
**************************************************************************/
static void CAVEGetWallProjection(CAVE_WALL_ID wall,CAVEID eye,float *frustum,
				Matrix viewmat)
{
 register float dfront,dback,dleft,dright,dceiling,dfloor;
 register float Factor,Left, Right, Top, Bottom;
 float Xprime,Zprime,OrigXprime,OrigZprime,eyeX,eyeY,eyeZ;

/* Compute distance to each wall */
 CAVEGetEyePosition(eye,&eyeX,&eyeY,&eyeZ);
#ifdef ZUP_COORDS
 dfront = CAVEConfig->OrigY - eyeY;
 dleft = CAVEConfig->OrigX + eyeX;
 dfloor = CAVEConfig->OrigZ + eyeZ;
#else
 dfront = CAVEConfig->OrigZ + eyeZ;                                                                                        
 dleft = CAVEConfig->OrigX + eyeX;
 dfloor = CAVEConfig->OrigY + eyeY;
#endif
 dback = CAVEConfig->CAVEWidth - dfront;
 dright = CAVEConfig->CAVEWidth - dleft;
 dceiling = CAVEConfig->CAVEHeight - dfloor;

/* Determine frustum parameters */
 switch (wall)
	{
	case CAVE_FRONT_WALL:
		Factor = CAVENear / dfront;
		Left = -Factor * dleft;
		Right = Factor * dright;
		Bottom = -Factor * dfloor;
		Top = Factor * dceiling;
		break;
	case CAVE_LEFT_WALL:
		Factor = CAVENear / dleft;
		Left = -Factor * dback;
		Right = Factor * dfront;
		Bottom = -Factor * dfloor;
		Top = Factor * dceiling;
		break;
	case CAVE_RIGHT_WALL:
		Factor = CAVENear / dright;
		Left = -Factor * dfront;
		Right = Factor * dback;
		Bottom = -Factor * dfloor;
		Top = Factor * dceiling;
		break;
	case CAVE_FLOOR_WALL:
		Factor = CAVENear / dfloor;
		Left = -Factor * dleft;
		Right = Factor * dright;
		Bottom = -Factor * dback;
		Top = Factor * dfront;
		break;
	case CAVE_CEILING_WALL:
		Factor = CAVENear / dceiling;
		Left = -Factor * dleft;
		Right = Factor * dright;
		Bottom = -Factor * dfront;
		Top = Factor * dback;
		break;
	case CAVE_BACK_WALL:
		Factor = CAVENear / dback;
		Left = -Factor * dright;
		Right = Factor * dleft;
		Bottom = -Factor * dfloor;
		Top = Factor * dceiling;
		break;
/* Crude specialized hack for 45degree rotation of ARPA's floor */
	case CAVE_ARPAFLOOR_WALL:
		Factor = CAVENear / dfloor;
		Xprime = .707107f * (eyeX - eyeZ);
		Zprime = .707107f * (eyeX + eyeZ);
		OrigXprime = 1.414214f * CAVEConfig->OrigX;
		OrigZprime = 1.414214f * CAVEConfig->OrigZ;
		Left = -Factor * (OrigXprime + Xprime);
		Right = Factor * (CAVEConfig->CAVEWidth*1.414214f - OrigXprime - Xprime);
		Bottom = -Factor*(CAVEConfig->CAVEWidth*1.414214f - OrigZprime - Zprime);
		Top = Factor * (OrigZprime + Zprime);
		break;
	}

 frustum[0] = Left;      frustum[1] = Right;
 frustum[2] = Bottom;    frustum[3] = Top;
 frustum[4] = CAVENear;  frustum[5] = CAVEFar;

 switch (wall)
	{
	case CAVE_FRONT_WALL:
		{ static Matrix frontmat = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
		  bcopy(frontmat,viewmat,sizeof(Matrix));
		}
		break;
	case CAVE_LEFT_WALL:
#ifdef ZUP_COORDS
		{ static Matrix leftmat = {{0,-1,0,0},{1,0,0,0},{0,0,1,0},{0,0,0,1}};
#else
		{ static Matrix leftmat = {{0,0,1,0},{0,1,0,0},{-1,0,0,0},{0,0,0,1}};
#endif
		  bcopy(leftmat,viewmat,sizeof(Matrix));
		}
		break;
	case CAVE_RIGHT_WALL:
#ifdef ZUP_COORDS
		{ static Matrix rightmat = {{0,1,0,0},{-1,0,0,0},{0,0,1,0},{0,0,0,1}};
#else
		{ static Matrix rightmat = {{0,0,-1,0},{0,1,0,0},{1,0,0,0},{0,0,0,1}};
#endif
		  bcopy(rightmat,viewmat,sizeof(Matrix));
		}
		break;
	case CAVE_FLOOR_WALL:
#ifdef ZUP_COORDS
		{ static Matrix floormat = {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,0,0,1}};
#else
		{ static Matrix floormat = {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,0,0,1}};
#endif
		  bcopy(floormat,viewmat,sizeof(Matrix));
		}
		break;
	case CAVE_CEILING_WALL:
#ifdef ZUP_COORDS
		{ static Matrix ceilmat = {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,0,1}};
#else
		{ static Matrix ceilmat = {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,0,1}};
#endif
		  bcopy(ceilmat,viewmat,sizeof(Matrix));
		}
		break;
	case CAVE_BACK_WALL:
#ifdef ZUP_COORDS
		{ static Matrix backmat = {{-1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,0,0,1}};
#else
		{ static Matrix backmat = {{-1,0,0,0},{0,1,0,0},{0,0,-1,0},{0,0,0,1}};
#endif
		  bcopy(backmat,viewmat,sizeof(Matrix));
		}
		break;
	case CAVE_ARPAFLOOR_WALL:
#ifdef ZUP_COORDS
		{ static Matrix afloormat = {{.7071,.7071,0,0},{0,0,-1,0},
					{-.7071,.7071,0,0},{0,0,0,1}};
#else
		{ static Matrix afloormat = {{.7071,-.7071,0,0},{0,0,1,0},
					{-.7071,-.7071,0,0},{0,0,0,1}};
#endif
		  bcopy(afloormat,viewmat,sizeof(Matrix));
		}
		break;
	}
 CAVEPreTranslateMatrix(viewmat,-eyeX,-eyeY,-eyeZ);
}

/**************************************************************************
 void CAVEGetScreenProjection(CAVE_WALL_ID wall,CAVEID eye,float *frustum,Matrix viewmat)
**************************************************************************/
static void CAVEGetScreenProjection(CAVE_WALL_ID wall,CAVEID eye,float *frustum,
			Matrix viewmat)
{
 float Factor, Left, Right, Top, Bottom;
 float eyex,eyey,eyez,eye2[3];
 CAVEGetEyePosition(eye,&eyex,&eyey,&eyez);
 eye2[0] = eyex - CAVEConfig->ProjectionData[wall].lowerleft[0];
 eye2[1] = eyey - CAVEConfig->ProjectionData[wall].lowerleft[1];
 eye2[2] = eyez - CAVEConfig->ProjectionData[wall].lowerleft[2];

#ifdef ZUP_COORDS
 Factor = - CAVENear / DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Yaxis);
 Left = DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Xaxis);
 Bottom = DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Zaxis);
#else
 Factor = CAVENear / DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Zaxis);
 Left = DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Xaxis);
 Bottom = DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Yaxis);
#endif 

 Factor = CAVENear / DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Zaxis);
 Left = DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Xaxis);
 Right = CAVEptr->disp->screenData[wall].width - Left;
 Bottom = DOTPRODUCT(eye2,CAVEptr->disp->screenData[wall].Yaxis);
 Top = CAVEptr->disp->screenData[wall].height - Bottom;
 Left *= -Factor;
 Right *= Factor;
 Bottom *= -Factor;
 Top *= Factor;
 frustum[0] = Left;      frustum[1] = Right;
 frustum[2] = Bottom;    frustum[3] = Top;
 frustum[4] = CAVENear;  frustum[5] = CAVEFar;
 bcopy(CAVEptr->disp->screenData[wall].transform,viewmat,sizeof(Matrix));
 CAVEPreTranslateMatrix(viewmat,-eyex,-eyey,-eyez);
}


